1650263728756	geckodriver	INFO	Listening on 127.0.0.1:60655
1650263731811	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "60656" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileZxFC5K"
1650263733432	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileZxFC5K\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:60656/devtools/browser/aeac0fdc-a14d-4a22-9bdb-39266f8e9f39
1650263736843	Marionette	INFO	Listening on port 60661
1650263737057	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
1650263771682	Marionette	INFO	Stopped listening on port 60661650263773800	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "60710" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileV1azda"
1650263774306	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileV1azda\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:60710/devtools/browser/c5af4ec7-48c8-46c6-ad16-39199926b1ee
1650263776992	Marionette	INFO	Listening on port 60717
1650263777505	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
SourceActor threw an exception: [Exception... "Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]"  nsresult: "0x80470002 (NS_BASE_STREAM_CLOSED)"  location: "JS frame :: resource://devtools/shared/DevToolsUtils.js :: onResponse :: line 567"  data: no]
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:567:34
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 567, column: 0
console.error: ({})
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 567: NS_BASE_STREAM_CLOSED: Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
JavaScript error: resource://gre/modules/LoginManagerParent.jsm, line 136: TypeError: gRecipeManager is null
console.error: (new TypeError("currentNode is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 66))
TypeError: currentNode is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:66:20
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

JavaScript error: resource://gre/modules/AsyncShutdown.jsm, 1650263868296	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "60775" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofilemhtnff"
1650263868854	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofilemhtnff\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:60775/devtools/browser/a8607567-8a10-43d8-b3e6-d76ea90890de
1650263871498	Marionette	INFO	Listening on port 60781
1650263871539	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
JavaScript error: resource://gre/modules/LoginManagerParent.jsm, line 136: TypeError: gRecipeManager is null
JavaScript warning: https://gen-bizbd.com/web/content/50439-cea8e0c/web.assets_backend.js, line 5009: unreachable code after return statement
SourceActor threw an exception: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:556:16
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 556, column: 16
console.error: (new Error("Failed to fetch https://gen-bizbd.com/web. Code 2152924148.", "resource://devtools/shared/DevToolsUtils.js", 556))
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 556: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
SourceActor threw an exception: [Exception... "Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]"  nsresult: "0x80470002 (NS_BASE_STREAM_CLOSED)"  location: "JS frame :: resource://devtools/shared/DevToolsUtils.js :: onResponse :: line 567"  data: no]
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:567:34
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 567, column: 0
console.error: ({})
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 567: NS_BASE_STREAM_CLOSED: Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, 1650263991600	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "53970" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofilec5R9US"
1650263992149	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofilec5R9US\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:53970/devtools/browser/2d524c8c-dd68-4669-a832-7a50a81bda30
1650263994789	Marionette	INFO	Listening on port 53976
1650263994826	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
JavaScript error: resource://gre/modules/LoginManagerParent.jsm, line 136: TypeError: gRecipeManager is null
JavaScript warning: https://gen-bizbd.com/web/content/50439-cea8e0c/web.assets_backend.js, line 5009: unreachable code after return statement
SourceActor threw an exception: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:556:16
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 556, column: 16
console.error: (new Error("Failed to fetch https://gen-bizbd.com/web. Code 2152924148.", "resource://devtools/shared/DevToolsUtils.js", 556))
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 556: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
SourceActor threw an exception: [Exception... "Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]"  nsresult: "0x80470002 (NS_BASE_STREAM_CLOSED)"  location: "JS frame :: resource://devtools/shared/DevToolsUtils.js :: onResponse :: line 567"  data: no]
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:567:34
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 567, column: 0
console.error: ({})
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 567: NS_BASE_STREAM_CLOSED: Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]
JavaScript error: , line 0: NotFoundError: No such JSWindowActor 'DevToolsFrame'
SourceActor threw an exception: [Exception... "Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]"  nsresult: "0x80470002 (NS_BASE_STREAM_CLOSED)"  location: "JS frame :: resource://devtools/shared/DevToolsUtils.js :: onResponse :: line 567"  data: no]
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:567:34
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 567, column: 0
console.error: ({})
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 567: NS_BASE_STREAM_CLOSED: Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]
SourceActor threw an exception: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:556:16
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 556, column: 16
console.error: (new Error("Failed to fetch https://gen-bizbd.com/web. Code 2152924148.", "resource://devtools/shared/DevToolsUtils.js", 556))
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 556: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, 1650264112683	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "54048" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofile1q7FW1"
1650264113245	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofile1q7FW1\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:54048/devtools/browser/72b8811d-5f88-4795-a2a5-636aefb08532
1650264115761	Marionette	INFO	Listening on port 54053
1650264115899	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
JavaScript error: resource://gre/modules/LoginManagerParent.jsm, line 136: TypeError: gRecipeManager is null
JavaScript warning: https://gen-bizbd.com/web/content/50439-cea8e0c/web.assets_backend.js, line 5009: unreachable code after return statement
SourceActor threw an exception: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:556:16
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 556, column: 16
console.error: (new Error("Failed to fetch https://gen-bizbd.com/web. Code 2152924148.", "resource://devtools/shared/DevToolsUtils.js", 556))
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 556: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
SourceActor threw an exception: [Exception... "Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]"  nsresult: "0x80470002 (NS_BASE_STREAM_CLOSED)"  location: "JS frame :: resource://devtools/shared/DevToolsUtils.js :: onResponse :: line 567"  data: no]
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:567:34
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 567, column: 0
console.error: ({})
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 567: NS_BASE_STREAM_CLOSED: Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, 1650264234098	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "58450" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileGLoF8s"
1650264234604	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileGLoF8s\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:58450/devtools/browser/025282b0-779f-45fd-8dd6-19a5a2dbaa2c
1650264237311	Marionette	INFO	Listening on port 58456
1650264237342	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
JavaScript error: resource://gre/modules/LoginManagerParent.jsm, line 136: TypeError: gRecipeManager is null
JavaScript warning: https://gen-bizbd.com/web/content/50439-cea8e0c/web.assets_backend.js, line 5009: unreachable code after return statement
SourceActor threw an exception: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:556:16
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 556, column: 16
console.error: (new Error("Failed to fetch https://gen-bizbd.com/web. Code 2152924148.", "resource://devtools/shared/DevToolsUtils.js", 556))
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 556: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
SourceActor threw an exception: [Exception... "Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]"  nsresult: "0x80470002 (NS_BASE_STREAM_CLOSED)"  location: "JS frame :: resource://devtools/shared/DevToolsUtils.js :: onResponse :: line 567"  data: no]
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:567:34
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 567, column: 0
console.error: ({})
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 567: NS_BASE_STREAM_CLOSED: Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]
console.error: (new TypeError("parent is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: parent is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

JavaScript error: resource://gre/modules/AsyncShutdown.jsm, 1650264407810	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "50045" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofiletSHRm9"
1650264408331	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofiletSHRm9\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:50045/devtools/browser/59b8b8b9-b0c2-4670-bfe8-9b61d1134b94
1650264411064	Marionette	INFO	Listening on port 50051
1650264411538	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
JavaScript error: resource://gre/modules/LoginManagerParent.jsm, line 136: TypeError: gRecipeManager is null
JavaScript warning: https://gen-bizbd.com/web/content/50439-cea8e0c/web.assets_backend.js, line 5009: unreachable code after return statement
SourceActor threw an exception: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:556:16
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 556, column: 16
console.error: (new Error("Failed to fetch https://gen-bizbd.com/web. Code 2152924148.", "resource://devtools/shared/DevToolsUtils.js", 556))
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 556: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
SourceActor threw an exception: [Exception... "Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]"  nsresult: "0x80470002 (NS_BASE_STREAM_CLOSED)"  location: "JS frame :: resource://devtools/shared/DevToolsUtils.js :: onResponse :: line 567"  data: no]
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:567:34
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 567, column: 0
console.error: ({})
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 567: NS_BASE_STREAM_CLOSED: Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, 1650264547496	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "50131" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofile5aXEvk"
1650264548185	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofile5aXEvk\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:50131/devtools/browser/392b24c9-134f-463d-bd30-fdd004fb1873
1650264550730	Marionette	INFO	Listening on port 50136
1650264550861	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
JavaScript error: resource://gre/modules/LoginManagerParent.jsm, line 136: TypeError: gRecipeManager is null
JavaScript warning: https://gen-bizbd.com/web/content/50439-cea8e0c/web.assets_backend.js, line 5009: unreachable code after return statement
SourceActor threw an exception: [Exception... "Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]"  nsresult: "0x80470002 (NS_BASE_STREAM_CLOSED)"  location: "JS frame :: resource://devtools/shared/DevToolsUtils.js :: onResponse :: line 567"  data: no]
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:567:34
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 567, column: 0
console.error: ({})
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 567: NS_BASE_STREAM_CLOSED: Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]
SourceActor threw an exception: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:556:16
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 556, column: 16
console.error: (new Error("Failed to fetch https://gen-bizbd.com/web. Code 2152924148.", "resource://devtools/shared/DevToolsUtils.js", 556))
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 556: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, 1650264674229	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "65130" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofilewlUdf5"
1650264674830	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofilewlUdf5\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:65130/devtools/browser/cdab76fa-fb85-4a22-8103-2215cbd31638
1650264677339	Marionette	INFO	Listening on port 65135
1650264677450	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
JavaScript error: resource://gre/modules/LoginManagerParent.jsm, line 136: TypeError: gRecipeManager is null
JavaScript warning: https://gen-bizbd.com/web/content/50439-cea8e0c/web.assets_backend.js, line 5009: unreachable code after return statement
SourceActor threw an exception: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:556:16
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 556, column: 16
console.error: (new Error("Failed to fetch https://gen-bizbd.com/web. Code 2152924148.", "resource://devtools/shared/DevToolsUtils.js", 556))
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 556: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
SourceActor threw an exception: [Exception... "Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]"  nsresult: "0x80470002 (NS_BASE_STREAM_CLOSED)"  location: "JS frame :: resource://devtools/shared/DevToolsUtils.js :: onResponse :: line 567"  data: no]
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:567:34
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 567, column: 0
console.error: ({})
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 567: NS_BASE_STREAM_CLOSED: Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]
console.error: (new TypeError("parent is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: parent is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

console.error: (new TypeError("container.node.targetFront is null", "resource://devtools/client/inspector/markup/markup.js", 2320))
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, 1650264856295	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "57522" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileBZTvuW"
1650264856854	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileBZTvuW\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:57522/devtools/browser/81ad4938-2616-400f-93d4-4790dd914ef5
1650264859666	Marionette	INFO	Listening on port 57527
1650264860024	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
JavaScript error: resource://gre/modules/LoginManagerParent.jsm, line 136: TypeError: gRecipeManager is null
JavaScript warning: https://gen-bizbd.com/web/content/50439-cea8e0c/web.assets_backend.js, line 5009: unreachable code after return statement
SourceActor threw an exception: [Exception... "Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]"  nsresult: "0x80470002 (NS_BASE_STREAM_CLOSED)"  location: "JS frame :: resource://devtools/shared/DevToolsUtils.js :: onResponse :: line 567"  data: no]
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:567:34
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 567, column: 0
console.error: ({})
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 567: NS_BASE_STREAM_CLOSED: Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]
SourceActor threw an exception: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:556:16
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 556, column: 16
console.error: (new Error("Failed to fetch https://gen-bizbd.com/web. Code 2152924148.", "resource://devtools/shared/DevToolsUtils.js", 556))
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 556: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, 1650264991766	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "65210" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileOatYLr"
1650264992267	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileOatYLr\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:65210/devtools/browser/0807f889-e236-4bfa-8db1-6bdf4eed4406
1650264994760	Marionette	INFO	Listening on port 65216
1650264995007	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
JavaScript error: resource://gre/modules/LoginManagerParent.jsm, line 136: TypeError: gRecipeManager is null
JavaScript warning: https://gen-bizbd.com/web/content/50439-cea8e0c/web.assets_backend.js, line 5009: unreachable code after return statement
SourceActor threw an exception: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:556:16
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 556, column: 16
console.error: (new Error("Failed to fetch https://gen-bizbd.com/web. Code 2152924148.", "resource://devtools/shared/DevToolsUtils.js", 556))
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 556: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
SourceActor threw an exception: [Exception... "Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]"  nsresult: "0x80470002 (NS_BASE_STREAM_CLOSED)"  location: "JS frame :: resource://devtools/shared/DevToolsUtils.js :: onResponse :: line 567"  data: no]
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:567:34
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 567, column: 0
console.error: ({})
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 567: NS_BASE_STREAM_CLOSED: Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]
JavaScript error: , line 0: NotFoundError: No such JSWindowActor 'DevToolsFrame'
SourceActor threw an exception: [Exception... "Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]"  nsresult: "0x80470002 (NS_BASE_STREAM_CLOSED)"  location: "JS frame :: resource://devtools/shared/DevToolsUtils.js :: onResponse :: line 567"  data: no]
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:567:34
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 567, column: 0
console.error: ({})
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 567: NS_BASE_STREAM_CLOSED: Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]
SourceActor threw an exception: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:556:16
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 556, column: 16
console.error: (new Error("Failed to fetch https://gen-bizbd.com/web. Code 2152924148.", "resource://devtools/shared/DevToolsUtils.js", 556))
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 556: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
console.error: (new TypeError("parent is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: parent is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

console.error: (new TypeError("container.node.targetFront is null", "resource://devtools/client/inspector/markup/markup.js", 2320))
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, 1650265199404	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "65276" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileenIwlY"
1650265199960	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileenIwlY\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:65276/devtools/browser/84b262c1-c3a1-4b47-bf34-babcfc41f00e
1650265202900	Marionette	INFO	Listening on port 65282
1650265203141	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
JavaScript error: resource://gre/modules/LoginManagerParent.jsm, line 136: TypeError: gRecipeManager is null
JavaScript warning: https://gen-bizbd.com/web/content/50439-cea8e0c/web.assets_backend.js, line 5009: unreachable code after return statement
SourceActor threw an exception: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:556:16
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 556, column: 16
console.error: (new Error("Failed to fetch https://gen-bizbd.com/web. Code 2152924148.", "resource://devtools/shared/DevToolsUtils.js", 556))
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 556: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
SourceActor threw an exception: [Exception... "Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]"  nsresult: "0x80470002 (NS_BASE_STREAM_CLOSED)"  location: "JS frame :: resource://devtools/shared/DevToolsUtils.js :: onResponse :: line 567"  data: no]
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:567:34
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 567, column: 0
console.error: ({})
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 567: NS_BASE_STREAM_CLOSED: Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]
console.error: (new TypeError("parent is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: parent is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 575: NotFoundError: No such JSWindowActor 'DevToolsFrame'
1650265397337	Marionette	INFO	Stopped listening on port 65282
console.warn: TopSitesFeed: Failed to fetch data from Contile server: NetworkError when attempting to fetch resource.
1650274564183	geckodriver	INFO	Listening on 127.0.0.1:63635
1650274567180	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "63636" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileGQfN9L"
1650274568432	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileGQfN9L\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:63636/devtools/browser/b66053bc-d66a-478c-9bdd-720348452c7e
1650274572541	Marionette	INFO	Listening on port 63641
1650274573093	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
JavaScript error: resource://gre/modules/LoginManagerParent.jsm, line 136: TypeError: gRecipeManager is null
JavaScript warning: https://gen-bizbd.com/web/content/50439-cea8e0c/web.assets_backend.js, line 5009: unreachable code after return statement
SourceActor threw an exception: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:556:16
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 556, column: 16
console.error: (new Error("Failed to fetch https://gen-bizbd.com/web. Code 2152924148.", "resource://devtools/shared/DevToolsUtils.js", 556))
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 556: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
SourceActor threw an exception: [Exception... "Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]"  nsresult: "0x80470002 (NS_BASE_STREAM_CLOSED)"  location: "JS frame :: resource://devtools/shared/DevToolsUtils.js :: onResponse :: line 567"  data: no]
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:567:34
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 567, column: 0
console.error: ({})
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 567: NS_BASE_STREAM_CLOSED: Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 575: NotFoundError: No such JSWindowActor 'DevToolsFrame'
1650274805181	Marionette	INFO	Stopped listening on port 63641
console.warn: TopSitesFeed: Failed to fetch data from Contile server: NetworkError when attempting to fetch resource.
UNbz"
1650274691146	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofilemKUNbz\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:55038/devtools/browser/59dc85b5-d87c-4ccf-b2c2-be149c6bd37e
1650274694005	Marionette	INFO	Listening on port 55043
1650274694294	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
JavaScript error: resource://gre/modules/LoginManagerParent.jsm, line 136: TypeError: gRecipeManager is null
JavaScript warning: https://gen-bizbd.com/web/content/50439-cea8e0c/web.assets_backend.js, line 5009: unreachable code after return statement
SourceActor threw an exception: [Exception... "Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]"  nsresult: "0x80470002 (NS_BASE_STREAM_CLOSED)"  location: "JS frame :: resource://devtools/shared/DevToolsUtils.js :: onResponse :: line 567"  data: no]
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:567:34
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 567, column: 0
console.error: ({})
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 567: NS_BASE_STREAM_CLOSED: Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]
SourceActor threw an exception: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:556:16
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 556, column: 16
console.error: (new Error("Failed to fetch https://gen-bizbd.com/web. Code 2152924148.", "resource://devtools/shared/DevToolsUtils.js", 556))
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 556: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
console.error: (new TypeError("currentNode is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 66))
TypeError: currentNode is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:66:20
onMutations@resource://devtools/client/inspe1650274846187	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileuqxOqK\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:55119/devtools/browser/158b03e1-1467-49a4-b4f1-f11dd16ceae3
1650274849678	Marionette	INFO	Listening on port 55124
1650274849785	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
JavaScript error: resource://gre/modules/LoginManagerParent.jsm, line 136: TypeError: gRecipeManager is null
JavaScript warning: https://gen-bizbd.com/web/content/50439-cea8e0c/web.assets_backend.js, line 5009: unreachable code after return statement
SourceActor threw an exception: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:556:16
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 556, column: 16
console.error: (new Error("Failed to fetch https://gen-bizbd.com/web. Code 2152924148.", "resource://devtools/shared/DevToolsUtils.js", 556))
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 556: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
SourceActor threw an exception: [Exception... "Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]"  nsresult: "0x80470002 (NS_BASE_STREAM_CLOSED)"  location: "JS frame :: resource://devtools/shared/DevToolsUtils.js :: onResponse :: line 567"  data: no]
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:567:34
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 567, column: 0
console.error: ({})
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 567: NS_BASE_STREAM_CLOSED: Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]
console.error: (new TypeError("currentNode is null", "resour1650274962969	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "58289" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofilevgIGH2"
1650274963843	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofilevgIGH2\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:58289/devtools/browser/42b1779a-6313-406c-9699-d277b2ea1060
1650274967318	Marionette	INFO	Listening on port 58295
1650274967854	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
JavaScript error: resource://gre/modules/LoginManagerParent.jsm, line 136: TypeError: gRecipeManager is null
1650274977808	Marionette	WARN	TimedPromise timed out after 500 ms: stacktrace:
TimedPromise/<@chrome://remote/content/marionette/sync.js:235:19
TimedPromise@chrome://remote/content/marionette/sync.js:220:10
interaction.flushEventLoop@chrome://remote/content/marionette/interaction.js:431:10
webdriverClickElement@chrome://remote/content/marionette/interaction.js:179:31
JavaScript warning: https://gen-bizbd.com/web/content/50439-cea8e0c/web.assets_backend.js, line 5009: unreachable code after return statement
1650274992212	Marionette	WARN	TimedPromise timed out after 500 ms: stacktrace:
TimedPromise/<@chrome://remote/content/marionette/sync.js:235:19
TimedPromise@chrome://remote/content/marionette/sync.js:220:10
interaction.flushEventLoop@chrome://remote/content/marionette/interaction.js:431:10
webdriverClickElement@chrome://remote/content/marionette/interaction.js:179:31
1650275151560	Marionette	INFO	Stopped listening on port 58295
console.warn: TopSitesFeed: Failed to fetch data from Contile server: NetworkError when attempting to fetch resource.
e" "--remote-debugging-port" "52480" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileTJ8mT3"
1650275143586	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileTJ8mT3\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:52480/devtools/browser/a7cc8255-cdd7-4b32-8b6c-e0d61bcbbc11
1650275146560	Marionette	INFO	Listening on port 52485
1650275146748	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
JavaScript error: resource://gre/modules/LoginManagerParent.jsm, line 136: TypeError: gRecipeManager is null
JavaScript warning: https://gen-bizbd.com/web/content/50439-cea8e0c/web.assets_backend.js, line 5009: unreachable code after return statement
1650275216223	Marionette	INFO	Stopped listening on port 52481650275217675	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "60192" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileOYd23h"
1650275218296	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileOYd23h\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:60192/devtools/browser/d7d0dc93-6135-4e51-a6fd-68eb6b1c1b95
1650275221013	Marionette	INFO	Listening on port 60198
1650275221428	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
JavaScript error: resource://gre/modules/LoginManagerParent.jsm, line 136: TypeError: gRecipeManager is null
JavaScript warning: https://gen-bizbd.com/web/content/50439-cea8e0c/web.assets_backend.js, line 5009: unreachable code after return statement
1650275273243	Marionette	INFO	Stopped listening on port 60191650275274686	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "60255" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofiley3u4UI"
1650275275258	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofiley3u4UI\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:60255/devtools/browser/0686f1f6-364a-4c58-be83-8b8b4e6a65fc
1650275277760	Marionette	INFO	Listening on port 60261
1650275277928	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
JavaScript error: resource://gre/modules/LoginManagerParent.jsm, line 136: TypeError: gRecipeManager is null
JavaScript warning: https://gen-bizbd.com/web/content/50439-cea8e0c/web.assets_backend.js, line 5009: unreachable code after return statement
SourceActor threw an exception: [Exception... "Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]"  nsresult: "0x80470002 (NS_BASE_STREAM_CLOSED)"  location: "JS frame :: resource://devtools/shared/DevToolsUtils.js :: onResponse :: line 567"  data: no]
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:567:34
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 567, column: 0
console.error: ({})
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 567: NS_BASE_STREAM_CLOSED: Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]
SourceActor threw an exception: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:556:16
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 556, column: 16
console.error: (new Error("Failed to fetch https://gen-bizbd.com/web. Code 2152924148.", "resource://devtools/shared/DevToolsUtils.js", 556))
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 556: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
console.error: (new TypeError("parent is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: parent is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

JavaScript error: resource://gre/modules/AsyncShutdown.jsm, 1650275580175	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "59919" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileJiHmWx"
1650275580821	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileJiHmWx\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:59919/devtools/browser/f6e545ac-1ada-44b7-888c-5ae4514afc62
1650275583955	Marionette	INFO	Listening on port 59927
1650275584421	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
JavaScript error: resource://gre/modules/LoginManagerParent.jsm, line 136: TypeError: gRecipeManager is null
JavaScript warning: https://gen-bizbd.com/web/content/50439-cea8e0c/web.assets_backend.js, line 5009: unreachable code after return statement
1650275683410	Marionette	INFO	Stopped listening on port 59921650275685600	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "59570" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofiledgcd3c"
1650275686108	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofiledgcd3c\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:59570/devtools/browser/3ddeae88-d8f7-4247-aa47-2eeb36e697bb
1650275688579	Marionette	INFO	Listening on port 59576
1650275688831	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
JavaScript error: resource://gre/modules/LoginManagerParent.jsm, line 136: TypeError: gRecipeManager is null
JavaScript warning: https://gen-bizbd.com/web/content/50439-cea8e0c/web.assets_backend.js, line 5009: unreachable code after return statement
1650275756124	Marionette	INFO	Stopped listening on port 59576
console.warn: TopSitesFeed: Failed to fetch data from Contile server: NetworkError when attempting to fetch resource.

###!!! [Parent][PGPUParent] Error: RunMessage(msgname=PGPU::Msg_ShutdownVR) Channel closing: too late to send/recv, messages will be lost

1650278994513	geckodriver	INFO	Listening on 127.0.0.1:51455
1650278997586	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "51456" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileCTgqVZ"
1650278998143	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileCTgqVZ\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:51456/devtools/browser/2d92c4b3-1b30-4d21-bb37-b711de45f041
1650279000939	Marionette	INFO	Listening on port 59052
1650279001330	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
JavaScript error: resource://gre/modules/LoginManagerParent.jsm, line 136: TypeError: gRecipeManager is null
JavaScript warning: https://gen-bizbd.com/web/content/53594-92c9dad/web.assets_backend.js, line 5051: unreachable code after return statement
1650279137171	Marionette	INFO	Stopped listening on port 59051650279137716	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "57534" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileuFRVzq"
1650279138303	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileuFRVzq\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:57534/devtools/browser/53ee4b55-35ed-4b00-a4e9-bfc6287a0646
1650279141521	Marionette	INFO	Listening on port 57539
1650279141975	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
JavaScript error: resource://gre/modules/LoginManagerParent.jsm, line 136: TypeError: gRecipeManager is null
JavaScript warning: https://gen-bizbd.com/web/content/53594-92c9dad/web.assets_backend.js, line 5051: unreachable code after return statement
1650279257733	Marionette	INFO	Stopped listening on port 57539

###!!! [Parent][PContentParent] Error: Send(msgname=PContent::Reply_DiscardBrowsingContext) Closed channel: cannot send/recv


###!!! [Parent][PContentParent] Error: Send(msgname=PContent::Msg_DestroyBrowsingContextGroup) Closed channel: cannot send/recv


###!!! [Child][PContentChild] Error: RunMessage(msgname=PContent::Msg_DiscardBrowsingContext) Channel closing: too late to send/recv, messages will be lost


###!!! [Child][PContentChild] Error: RunMessage(msgname=PContent::Reply_DiscardBrowsingContext) Channel closing: too late to send/recv, messages will be lost


###!!! [Child][PContentChild] Error: RunMessage(msgname=PHttpChannel::Msg_DeleteSelf) Channel closing: too late to send/recv, messages will be lost

1650280338292	geckodriver	INFO	Listening on 127.0.0.1:52449
1650280341369	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "52450" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileaj12eA"
1650280341930	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileaj12eA\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:52450/devtools/browser/835046c3-89f0-45e1-bb97-d3c5e2851fe6
1650280344891	Marionette	INFO	Listening on port 52455
1650280345139	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
JavaScript error: resource://gre/modules/LoginManagerParent.jsm, line 136: TypeError: gRecipeManager is null
JavaScript warning: https://gen-bizbd.com/web/content/53594-92c9dad/web.assets_backend.js, line 5051: unreachable code after return statement
SourceActor threw an exception: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:556:16
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 556, column: 16
console.error: (new Error("Failed to fetch https://gen-bizbd.com/web. Code 2152924148.", "resource://devtools/shared/DevToolsUtils.js", 556))
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 556: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
SourceActor threw an exception: [Exception... "Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]"  nsresult: "0x80470002 (NS_BASE_STREAM_CLOSED)"  location: "JS frame :: resource://devtools/shared/DevToolsUtils.js :: onResponse :: line 567"  data: no]
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:567:34
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 567, column: 0
console.error: ({})
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 567: NS_BASE_STREAM_CLOSED: Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]
JavaScript error: , line 0: NotFoundError: No such JSWindowActor 'DevToolsFrame'
SourceActor threw an exception: [Exception... "Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]"  nsresult: "0x80470002 (NS_BASE_STREAM_CLOSED)"  location: "JS frame :: resource://devtools/shared/DevToolsUtils.js :: onResponse :: line 567"  data: no]
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:567:34
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 567, column: 0
console.error: ({})
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 567: NS_BASE_STREAM_CLOSED: Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]
SourceActor threw an exception: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:556:16
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 556, column: 16
console.error: (new Error("Failed to fetch https://gen-bizbd.com/web. Code 2152924148.", "resource://devtools/shared/DevToolsUtils.js", 556))
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 556: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
console.error: (new TypeError("currentNode is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 66))
TypeError: currentNode is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:66:20
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@rconsole.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofilekydzXD\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:60778/devtools/browser/56edfc77-338c-45c2-b312-cb186c96d34f
1650280565529	Marionette	INFO	Listening on port 60783
1650280566025	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
JavaScript error: resource://gre/modules/LoginManagerParent.jsm, line 136: TypeError: gRecipeManager is null
JavaScript warning: https://gen-bizbd.com/web/content/53594-92c9dad/web.assets_backend.js, line 5051: unreachable code after return statement
1650280607022	Marionette	INFO	Stopped listening on port 60783
console.warn: TopSitesFeed: Failed to fetch data from Contile server: NetworkError when attempting to fetch resource.
bd.com/web/content/8719-90fa03d/web.assets_frontend.0.css'"
console.error: ({})
console.error: "Error while calling actor 'pagestyle's method 'getApplied'" "Failed to open input source 'https://gen-bizbd.com/web/content/8719-90fa03d/web.assets_frontend.0.css'"
console.error: ({})
console.error: "Tried to send a 'getLayout' method reply on an already destroyed actor 'pagestyle'"

###!!! [Child][PContentChild] Error: RunMessage(msgname=PHttpChannel::Msg_DeleteSelf) Channel closing: too late to send/recv, messages will be lost


###!!! [Child][PContentChild] Error: Send(msgname=PContent::Msg_ScriptError) Channel closing: too late to send/recv, messages will be lost


###!!! [Parent][PGPUParent] Error: RunMessage(msgname=PGPU::Msg_ShutdownVR) Channel closing: too late to send/recv, messages will be lost

1650280609351	geckodriver	INFO	Listening on 127.0.0.1:60839
1650280612425	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "60840" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileNpEUQx"
1650280612981	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileNpEUQx\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:60840/devtools/browser/a712dbea-0707-4719-8e20-dbd024c8cb94
1650280615691	Marionette	INFO	Listening on port 60846
1650280616160	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
JavaScript error: resource://gre/modules/LoginManagerParent.jsm, line 136: TypeError: gRecipeManager is null
JavaScript warning: https://gen-bizbd.com/web/content/53594-92c9dad/web.assets_backend.js, line 5051: unreachable code after return statement
JavaScript error: , line 0: NS_ERROR_NOT_AVAILABLE
1650286508423	Marionette	INFO	Stopped listening on port 60846
console.warn: TopSitesFeed: Failed to fetch data from Contile server: NetworkError when attempting to fetch resource.

###!!! [Parent][PGPUParent] Error: RunMessage(msgname=PGPU::Msg_ShutdownVR) Channel closing: too late to send/recv, messages will be lost

1650358977458	geckodriver	INFO	Listening on 127.0.0.1:63498
1650358980567	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "63499" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofilekp3B7Z"
1650358981249	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofilekp3B7Z\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:63499/devtools/browser/6b854645-2f1c-4fde-8b8f-250e19aaaa23
1650358984856	Marionette	INFO	Listening on port 63504
1650358984934	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
JavaScript error: resource://gre/modules/LoginManagerParent.jsm, line 136: TypeError: gRecipeManager is null
1650359023849	Marionette	INFO	Stopped listening on port 63501650359025472	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "64321" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileEMzeh6"
1650359026099	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileEMzeh6\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:64321/devtools/browser/bccfa884-ba94-4d78-af33-d3723b2fb1b4
1650359028936	Marionette	INFO	Listening on port 64327
1650359029216	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
JavaScript error: resource://gre/modules/LoginManagerParent.jsm, line 136: TypeError: gRecipeManager is null
JavaScript warning: https://gen-bizbd.com/web/content/53594-92c9dad/web.assets_backend.js, line 5051: unreachable code after return statement
SourceActor threw an exception: [Exception... "Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]"  nsresult: "0x80470002 (NS_BASE_STREAM_CLOSED)"  location: "JS frame :: resource://devtools/shared/DevToolsUtils.js :: onResponse :: line 567"  data: no]
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:567:34
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 567, column: 0
console.error: ({})
SourceActor threw an exception: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:556:16
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 556, column: 16
console.error: (new Error("Failed to fetch https://gen-bizbd.com/web. Code 2152924148.", "resource://devtools/shared/DevToolsUtils.js", 556))
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 567: NS_BASE_STREAM_CLOSED: Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 556: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
console.error: (new TypeError("parent is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: parent is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

JavaScript error: resource://gre/modules/AsyncShutdown.jsm, 1650359282399	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "59581" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofile2JciYP"
1650359283010	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofile2JciYP\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:59581/devtools/browser/2e665e63-f6a6-48b8-b22a-1c1733c43042
1650359286144	Marionette	INFO	Listening on port 59589
1650359286663	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
JavaScript error: resource://gre/modules/LoginManagerParent.jsm, line 136: TypeError: gRecipeManager is null
JavaScript warning: https://gen-bizbd.com/web/content/53594-92c9dad/web.assets_backend.js, line 5051: unreachable code after return statement
1650359339660	Marionette	INFO	Stopped listening on port 59581650359341725	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "51790" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileTrgDOf"
1650359342374	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileTrgDOf\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:51790/devtools/browser/8b864bc1-d3b6-41d7-b54b-5391e0f1d360
1650359344991	Marionette	INFO	Listening on port 51798
1650359345471	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
JavaScript error: resource://gre/modules/LoginManagerParent.jsm, line 136: TypeError: gRecipeManager is null
JavaScript warning: https://gen-bizbd.com/web/content/53594-92c9dad/web.assets_backend.js, line 5051: unreachable code after return statement
SourceActor threw an exception: [Exception... "Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]"  nsresult: "0x80470002 (NS_BASE_STREAM_CLOSED)"  location: "JS frame :: resource://devtools/shared/DevToolsUtils.js :: onResponse :: line 567"  data: no]
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:567:34
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 567, column: 0
console.error: ({})
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 567: NS_BASE_STREAM_CLOSED: Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]
SourceActor threw an exception: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:556:16
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 556, column: 16
console.error: (new Error("Failed to fetch https://gen-bizbd.com/web. Code 2152924148.", "resource://devtools/shared/DevToolsUtils.js", 556))
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 556: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, 1650359647179	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "58807" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileYYFh8r"
1650359647750	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileYYFh8r\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:58807/devtools/browser/a4eabfda-1bba-41e1-a309-6fe0af97f03b
1650359650319	Marionette	INFO	Listening on port 58813
1650359650402	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
JavaScript error: resource://gre/modules/LoginManagerParent.jsm, line 136: TypeError: gRecipeManager is null
JavaScript warning: https://gen-bizbd.com/web/content/53594-92c9dad/web.assets_backend.js, line 5051: unreachable code after return statement
JavaScript error: , line 0: NS_ERROR_NOT_AVAILABLE
1650360492061	Marionette	INFO	Stopped listening on port 58813
console.warn: TopSitesFeed: Failed to fetch data from Contile server: NetworkError when attempting to fetch resource.
e" "--remote-debugging-port" "61856" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofile7NgN1v"
1650360492802	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofile7NgN1v\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:61856/devtools/browser/3aa5d473-b56e-47b2-9d7e-562f043e23b0
1650360495429	Marionette	INFO	Listening on port 61861
1650360495489	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
JavaScript error: resource://gre/modules/LoginManagerParent.jsm, line 136: TypeError: gRecipeManager is null
JavaScript warning: https://gen-bizbd.com/web/content/53594-92c9dad/web.assets_backend.js, line 5051: unreachable code after return statement
1650360517394	Marionette	WARN	TimedPromise timed out after 500 ms: stacktrace:
TimedPromise/<@chrome://remote/content/marionette/sync.js:235:19
TimedPromise@chrome://remote/content/marionette/sync.js:220:10
interaction.flushEventLoop@chrome://remote/content/marionette/interaction.js:431:10
webdriverClickElement@chrome://remote/content/marionette/interaction.js:179:31
SourceActor threw an exception: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:556:16
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 556, column: 16
console.error: (new Error("Failed to fetch https://gen-bizbd.com/web. Code 2152924148.", "resource://devtools/shared/DevToolsUtils.js", 556))
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 556: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
SourceActor threw an exception: [Exception... "Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]"  nsresult: "0x80470002 (NS_BASE_STREAM_CLOSED)"  location: "JS frame :: resource://devtools/shared/DevToolsUtils.js :: onResponse :: line 567"  data: no]
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:567:34
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 567, column: 0
console.error: ({})
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 567: NS_BASE_STREAM_CLOSED: Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, 1650360565458	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "61920" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileH93K7e"
1650360566049	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileH93K7e\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:61920/devtools/browser/ea43871b-7f25-4a4b-a205-6becb6b90ec1
1650360568640	Marionette	INFO	Listening on port 61925
1650360568692	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
JavaScript error: resource://gre/modules/LoginManagerParent.jsm, line 136: TypeError: gRecipeManager is null
JavaScript warning: https://gen-bizbd.com/web/content/53594-92c9dad/web.assets_backend.js, line 5051: unreachable code after return statement
SourceActor threw an exception: [Exception... "Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]"  nsresult: "0x80470002 (NS_BASE_STREAM_CLOSED)"  location: "JS frame :: resource://devtools/shared/DevToolsUtils.js :: onResponse :: line 567"  data: no]
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:567:34
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 567, column: 0
console.error: ({})
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 567: NS_BASE_STREAM_CLOSED: Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]
SourceActor threw an exception: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:556:16
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 556, column: 16
console.error: (new Error("Failed to fetch https://gen-bizbd.com/web. Code 2152924148.", "resource://devtools/shared/DevToolsUtils.js", 556))
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 556: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, 1650360679090	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "61990" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileEJ7KMs"
1650360679698	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileEJ7KMs\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:61990/devtools/browser/5b806ad1-d4c2-45c8-a18d-7c2e70fb8bd7
1650360682203	Marionette	INFO	Listening on port 61995
1650360682379	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
JavaScript error: resource://gre/modules/LoginManagerParent.jsm, line 136: TypeError: gRecipeManager is null
JavaScript warning: https://gen-bizbd.com/web/content/53594-92c9dad/web.assets_backend.js, line 5051: unreachable code after return statement
SourceActor threw an exception: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:556:16
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 556, column: 16
console.error: (new Error("Failed to fetch https://gen-bizbd.com/web. Code 2152924148.", "resource://devtools/shared/DevToolsUtils.js", 556))
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 556: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
SourceActor threw an exception: [Exception... "Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]"  nsresult: "0x80470002 (NS_BASE_STREAM_CLOSED)"  location: "JS frame :: resource://devtools/shared/DevToolsUtils.js :: onResponse :: line 567"  data: no]
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:567:34
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 567, column: 0
console.error: ({})
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 567: NS_BASE_STREAM_CLOSED: Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, 1650360766793	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "64215" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofilecFYdN3"
1650360767356	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofilecFYdN3\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:64215/devtools/browser/2735b30f-9f8e-4fac-ad3a-6f3b9a8febfa
1650360769908	Marionette	INFO	Listening on port 64220
1650360770016	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
JavaScript error: resource://gre/modules/LoginManagerParent.jsm, line 136: TypeError: gRecipeManager is null
JavaScript warning: https://gen-bizbd.com/web/content/53594-92c9dad/web.assets_backend.js, line 5051: unreachable code after return statement
SourceActor threw an exception: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:556:16
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 556, column: 16
console.error: (new Error("Failed to fetch https://gen-bizbd.com/web. Code 2152924148.", "resource://devtools/shared/DevToolsUtils.js", 556))
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 556: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
SourceActor threw an exception: [Exception... "Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]"  nsresult: "0x80470002 (NS_BASE_STREAM_CLOSED)"  location: "JS frame :: resource://devtools/shared/DevToolsUtils.js :: onResponse :: line 567"  data: no]
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:567:34
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 567, column: 0
console.error: ({})
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 567: NS_BASE_STREAM_CLOSED: Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]
JavaScript error: , line 0: NotFoundError: No such JSWindowActor 'DevToolsFrame'
SourceActor threw an exception: [Exception... "Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]"  nsresult: "0x80470002 (NS_BASE_STREAM_CLOSED)"  location: "JS frame :: resource://devtools/shared/DevToolsUtils.js :: onResponse :: line 567"  data: no]
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:567:34
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 567, column: 0
console.error: ({})
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 567: NS_BASE_STREAM_CLOSED: Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]
SourceActor threw an exception: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:556:16
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 556, column: 16
console.error: (new Error("Failed to fetch https://gen-bizbd.com/web. Code 2152924148.", "resource://devtools/shared/DevToolsUtils.js", 556))
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 556: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
console.error: "Error when attaching target:" (new Error("Connection closed, pending request to server0.conn1.windowGlobal4294967313/thread1, type isAttached failed\n\nRequest stack:\nrequest@resource://devtools/shared/protocol/Front.js:292:14\ngenerateRequestMethods/</frontProto[name]@resource://devtools/shared/protocol/Front/FrontClassWithSpec.js:46:19\nattachThread@resource://devtools/client/fronts/targets/target-mixin.js:573:49\n", "resource://devtools/shared/protocol/Front.js", 106))
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
console.error: (new TypeError("parent is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: parent is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

console.error: (new TypeError("container.node.targetFront is null", "resource://devtools/client/inspector/markup/markup.js", 2320))
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
Handler function threw an exception: [Exception... "Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]"  nsresult: "0x80040111 (NS_ERROR_NOT_AVAILABLE)"  location: "JS frame :: resource://devtools/server/actors/targets/window-global.js :: watch :: line 1662"  data: no]
Stack: watch@resource://devtools/server/actors/targets/window-global.js:1662:28
_watchDocshells@resource://devtools/server/actors/targets/window-global.js:773:28
initialize/<@resource://devtools/server/actors/targets/window-global.js:346:42
exports.makeInfallible/<@resource://devtools/shared/ThreadSafeDevToolsUtils.js:103:22
Line: 1662, column: 0
console.error: ({})
console.error: "Error while calling actor 'thread's method 'isAttached'" "JSWindowActorChild.sendAsyncMessage: JSWindowActorChild cannot send at the moment"
console.error: (new InvalidStateError("JSWindowActorChild.sendAsyncMessage: JSWindowActorChild cannot send at the moment", (void 0), 402))
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
console.error: "Error when destroying StyleSheet manager for" ({notifyResourceAvailable:function bound notifyResourceAvailable() {
    [native code]
}, notifyResourceDestroyed:function bound notifyResourceDestroyed() {
    [native code]
}, notifyResourceUpdated:function bound notifyResourceUpdated() {
    [native code]
}, conn:{_prefix:"server0.conn1.windowGlobal4294967313/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn1.windowGlobal4294967313", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {conn:{}, __poolMap:{}}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, actorID:"server0.conn1.windowGlobal4294967313/windowGlobalTarget2", _actorSpec:{typeName:"windowGlobalTarget", methods:[{name:"detach", request:{type:"detach", template:{type:"detach"}, args:[]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"ensureCSSErrorReportingEnabled", request:{type:"ensureCSSErrorReportingEnabled", template:{type:"ensureCSSErrorReportingEnabled"}, args:[]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"focus", request:{type:"focus", template:{type:"focus"}, args:[]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"goForward", request:{type:"goForward", template:{type:"goForward"}, args:[]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"goBack", request:{type:"goBack", template:{type:"goBack"}, args:[]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"reload", request:{type:"reload", template:{type:"reload", options:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["options"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"navigateTo", request:{type:"navigateTo", template:{type:"navigateTo", url:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["url"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"reconfigure", request:{type:"reconfigure", template:{type:"reconfigure", options:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["options"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"switchToFrame", request:{type:"switchToFrame", template:{type:"switchToFrame", windowId:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["windowId"]}]}, response:{template:{_type:"windowGlobalTarget.switchtoframe", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, retVal:{_type:"windowGlobalTarget.switchtoframe", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:[]}, release:(void 0), oneway:(void 0)}, {name:"listFrames", request:{type:"listFrames", template:{type:"listFrames"}, args:[]}, response:{template:{_type:"windowGlobalTarget.listframes", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, retVal:{_type:"windowGlobalTarget.listframes", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:[]}, release:(void 0), oneway:(void 0)}, {name:"listWorkers", request:{type:"listWorkers", template:{type:"listWorkers"}, args:[]}, response:{template:{_type:"windowGlobalTarget.workers", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, retVal:{_type:"windowGlobalTarget.workers", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:[]}, release:(void 0), oneway:(void 0)}, {name:"logInPage", request:{type:"logInPage", template:{type:"logInPage", text:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, category:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, flags:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["text"]}, {placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["category"]}, {placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["flags"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}], events:{}}, docShell:({}), _originalWindow:{get window() {
    [native code]
}, get document() {
    [native code]
}, get location() {
    [native code]
}, set location() {
    [native code]
}, get top() {
    [native code]
}, close:function close() {
    [native code]
}, stop:function stop() {
    [native code]
}, focus:function focus() {
    [native code]
}, blur:function blur() {
    [native code]
}, open:function open() {
    [native code]
}, alert:function alert() {
    [native code]
}, confirm:function confirm() {
    [native code]
}, prompt:function prompt() {
    [native code]
}, print:function print() {
    [native code]
}, printPreview:function printPreview() {
    [native code]
}, postMessage:function postMessage() {
    [native code]
}, captureEvents:function captureEvents() {
    [native code]
}, releaseEvents:function releaseEvents() {
    [native code]
}, getSelection:function getSelection() {
    [native code]
}, getComputedStyle:function getComputedStyle() {
    [native code]
}, matchMedia:function matchMedia() {
    [native code]
}, moveTo:function moveTo() {
    [native code]
}, moveBy:function moveBy() {
    [native code]
}, resizeTo:function resizeTo() {
    [native code]
}, resizeBy:function resizeBy() {
    [native code]
}, scroll:function scroll() {
    [native code]
}, scrollTo:function scrollTo() {
    [native code]
}, scrollBy:function scrollBy() {
    [native code]
}, getDefaultComputedStyle:function getDefaultComputedStyle() {
    [native code]
}, scrollByLines:function scrollByLines() {
    [native code]
}, scrollByPages:function scrollByPages() {
    [native code]
}, sizeToContent:function sizeToContent() {
    [native code]
}, updateCommands:function updateCommands() {
    [native code]
}, find:function find() {
    [native code]
}, dump:function dump() {
    [native code]
}, setResizable:function setResizable() {
    [native code]
}, requestIdleCallback:function requestIdleCallback() {
    [native code]
}, cancelIdleCallback:function cancelIdleCallback() {
    [native code]
}, getRegionalPrefsLocales:function getRegionalPrefsLocales() {
    [native code]
}, getWebExposedLocales:function getWebExposedLocales() {
    [native code]
}, requestAnimationFrame:function requestAnimationFrame() {
    [native code]
}, cancelAnimationFrame:function cancelAnimationFrame() {
    [native code]
}, reportError:function reportError() {
    [native code]
}, btoa:function btoa() {
    [native code]
}, atob:function atob() {
    [native code]
}, setTimeout:function setTimeout() {
    [native code]
}, clearTimeout:function clearTimeout() {
    [native code]
}, setInterval:function setInterval() {
    [native code]
}, clearInterval:function clearInterval() {
    [native code]
}, queueMicrotask:function queueMicrotask() {
    [native code]
}, createImageBitmap:function createImageBitmap() {
    [native code]
}, structuredClone:function structuredClone() {
    [native code]
}, fetch:function fetch() {
    [native code]
}, get self() {
    [native code]
}, set self() {
    [native code]
}, get name() {
    [native code]
}, set name() {
    [native code]
}, get history() {
    [native code]
}, get customElements() {
    [native code]
}, get locationbar() {
    [native code]
}, set locationbar() {
    [native code]
}, get menubar() {
    [native code]
}, set menubar() {
    [native code]
}, get personalbar() {
    [native code]
}, set personalbar() {
    [native code]
}, get scrollbars() {
    [native code]
}, set scrollbars() {
    [native code]
}, get statusbar() {
    [native code]
}, set statusbar() {
    [native code]
}, get toolbar() {
    [native code]
}, set toolbar() {
    [native code]
}, get status() {
    [native code]
}, set status() {
    [native code]
}, get closed() {
    [native code]
}, get event() {
    [native code]
}, set event() {
    [native code]
}, get frames() {
    [native code]
}, set frames() {
    [native code]
}, get length() {
    [native code]
}, set length() {
    [native code]
}, get opener() {
    [native code]
}, set opener() {
    [native code]
}, get parent() {
    [native code]
}, set parent() {
    [native code]
}, get frameElement() {
    [native code]
}, get navigator() {
    [native code]
}, get clientInformation() {
    [native code]
}, get external() {
    [native code]
}, set external() {
    [native code]
}, get screen() {
    [native code]
}, set screen() {
    [native code]
}, get innerWidth() {
    [native code]
}, set innerWidth() {
    [native code]
}, get innerHeight() {
    [native code]
}, set innerHeight() {
    [native code]
}, get scrollX() {
    [native code]
}, set scrollX() {
    [native code]
}, get pageXOffset() {
    [native code]
}, set pageXOffset() {
    [native code]
}, get scrollY() {
    [native code]
}, set scrollY() {
    [native code]
}, get pageYOffset() {
    [native code]
}, set pageYOffset() {
    [native code]
}, get screenLeft() {
    [native code]
}, set screenLeft() {
    [native code]
}, get screenTop() {
    [native code]
}, set screenTop() {
    [native code]
}, get screenX() {
    [native code]
}, set screenX() {
    [native code]
}, get screenY() {
    [native code]
}, set screenY() {
    [native code]
}, get outerWidth() {
    [native code]
}, set outerWidth() {
    [native code]
}, get outerHeight() {
    [native code]
}, set outerHeight() {
    [native code]
}, get performance() {
    [native code]
}, set performance() {
    [native code]
}, get mozInnerScreenX() {
    [native code]
}, get mozInnerScreenY() {
    [native code]
}, get devicePixelRatio() {
    [native code]
}, set devicePixelRatio() {
    [native code]
}, get scrollMaxX() {
    [native code]
}, set scrollMaxX() {
    [native code]
}, get scrollMaxY() {
    [native code]
}, set scrollMaxY() {
    [native code]
}, get fullScreen() {
    [native code]
}, set fullScreen() {
    [native code]
}, get ondevicemotion() {
    [native code]
}, set ondevicemotion() {
    [native code]
}, get ondeviceorientation() {
    [native code]
}, set ondeviceorientation() {
    [native code]
}, get onabsolutedeviceorientation() {
    [native code]
}, set onabsolutedeviceorientation() {
    [native code]
}, get InstallTrigger() {
    [native code]
}, set InstallTrigger() {
    [native code]
}, get intlUtils() {
    [native code]
}, get visualViewport() {
    [native code]
}, set visualViewport() {
    [native code]
}, get crypto() {
    [native code]
}, get onabort() {
    [native code]
}, set onabort() {
    [native code]
}, get onblur() {
    [native code]
}, set onblur() {
    [native code]
}, get onfocus() {
    [native code]
}, set onfocus() {
    [native code]
}, get onauxclick() {
    [native code]
}, set onauxclick() {
    [native code]
}, get onbeforeinput() {
    [native code]
}, set onbeforeinput() {
    [native code]
}, get oncanplay() {
    [native code]
}, set oncanplay() {
    [native code]
}, get oncanplaythrough() {
    [native code]
}, set oncanplaythrough() {
    [native code]
}, get onchange() {
    [native code]
}, set onchange() {
    [native code]
}, get onclick() {
    [native code]
}, set onclick() {
    [native code]
}, get onclose() {
    [native code]
}, set onclose() {
    [native code]
}, get oncontextmenu() {
    [native code]
}, set oncontextmenu() {
    [native code]
}, get oncuechange() {
    [native code]
}, set oncuechange() {
    [native code]
}, get ondblclick() {
    [native code]
}, set ondblclick() {
    [native code]
}, get ondrag() {
    [native code]
}, set ondrag() {
    [native code]
}, get ondragend() {
    [native code]
}, set ondragend() {
    [native code]
}, get ondragenter() {
    [native code]
}, set ondragenter() {
    [native code]
}, get ondragexit() {
    [native code]
}, set ondragexit() {
    [native code]
}, get ondragleave() {
    [native code]
}, set ondragleave() {
    [native code]
}, get ondragover() {
    [native code]
}, set ondragover() {
    [native code]
}, get ondragstart() {
    [native code]
}, set ondragstart() {
    [native code]
}, get ondrop() {
    [native code]
}, set ondrop() {
    [native code]
}, get ondurationchange() {
    [native code]
}, set ondurationchange() {
    [native code]
}, get onemptied() {
    [native code]
}, set onemptied() {
    [native code]
}, get onended() {
    [native code]
}, set onended() {
    [native code]
}, get onformdata() {
    [native code]
}, set onformdata() {
    [native code]
}, get oninput() {
    [native code]
}, set oninput() {
    [native code]
}, get oninvalid() {
    [native code]
}, set oninvalid() {
    [native code]
}, get onkeydown() {
    [native code]
}, set onkeydown() {
    [native code]
}, get onkeypress() {
    [native code]
}, set onkeypress() {
    [native code]
}, get onkeyup() {
    [native code]
}, set onkeyup() {
    [native code]
}, get onload() {
    [native code]
}, set onload() {
    [native code]
}, get onloadeddata() {
    [native code]
}, set onloadeddata() {
    [native code]
}, get onloadedmetadata() {
    [native code]
}, set onloadedmetadata() {
    [native code]
}, get onloadend() {
    [native code]
}, set onloadend() {
    [native code]
}, get onloadstart() {
    [native code]
}, set onloadstart() {
    [native code]
}, get onmousedown() {
    [native code]
}, set onmousedown() {
    [native code]
}, get onmouseenter() {
    [native code]
}, set onmouseenter() {
    [native code]
}, get onmouseleave() {
    [native code]
}, set onmouseleave() {
    [native code]
}, get onmousemove() {
    [native code]
}, set onmousemove() {
    [native code]
}, get onmouseout() {
    [native code]
}, set onmouseout() {
    [native code]
}, get onmouseover() {
    [native code]
}, set onmouseover() {
    [native code]
}, get onmouseup() {
    [native code]
}, set onmouseup() {
    [native code]
}, get onwheel() {
    [native code]
}, set onwheel() {
    [native code]
}, get onpause() {
    [native code]
}, set onpause() {
    [native code]
}, get onplay() {
    [native code]
}, set onplay() {
    [native code]
}, get onplaying() {
    [native code]
}, set onplaying() {
    [native code]
}, get onprogress() {
    [native code]
}, set onprogress() {
    [native code]
}, get onratechange() {
    [native code]
}, set onratechange() {
    [native code]
}, get onreset() {
    [native code]
}, set onreset() {
    [native code]
}, get onresize() {
    [native code]
}, set onresize() {
    [native code]
}, get onscroll() {
    [native code]
}, set onscroll() {
    [native code]
}, get onsecuritypolicyviolation() {
    [native code]
}, set onsecuritypolicyviolation() {
    [native code]
}, get onseeked() {
    [native code]
}, set onseeked() {
    [native code]
}, get onseeking() {
    [native code]
}, set onseeking() {
    [native code]
}, get onselect() {
    [native code]
}, set onselect() {
    [native code]
}, get onslotchange() {
    [native code]
}, set onslotchange() {
    [native code]
}, get onstalled() {
    [native code]
}, set onstalled() {
    [native code]
}, get onsubmit() {
    [native code]
}, set onsubmit() {
    [native code]
}, get onsuspend() {
    [native code]
}, set onsuspend() {
    [native code]
}, get ontimeupdate() {
    [native code]
}, set ontimeupdate() {
    [native code]
}, get onvolumechange() {
    [native code]
}, set onvolumechange() {
    [native code]
}, get onwaiting() {
    [native code]
}, set onwaiting() {
    [native code]
}, get onselectstart() {
    [native code]
}, set onselectstart() {
    [native code]
}, get onselectionchange() {
    [native code]
}, set onselectionchange() {
    [native code]
}, get ontoggle() {
    [native code]
}, set ontoggle() {
    [native code]
}, get onpointercancel() {
    [native code]
}, set onpointercancel() {
    [native code]
}, get onpointerdown() {
    [native code]
}, set onpointerdown() {
    [native code]
}, get onpointerup() {
    [native code]
}, set onpointerup() {
    [native code]
}, get onpointermove() {
    [native code]
}, set onpointermove() {
    [native code]
}, get onpointerout() {
    [native code]
}, set onpointerout() {
    [native code]
}, get onpointerover() {
    [native code]
}, set onpointerover() {
    [native code]
}, get onpointerenter() {
    [native code]
}, set onpointerenter() {
    [native code]
}, get onpointerleave() {
    [native code]
}, set onpointerleave() {
    [native code]
}, get ongotpointercapture() {
    [native code]
}, set ongotpointercapture() {
    [native code]
}, get onlostpointercapture() {
    [native code]
}, set onlostpointercapture() {
    [native code]
}, get onmozfullscreenchange() {
    [native code]
}, set onmozfullscreenchange() {
    [native code]
}, get onmozfullscreenerror() {
    [native code]
}, set onmozfullscreenerror() {
    [native code]
}, get onanimationcancel() {
    [native code]
}, set onanimationcancel() {
    [native code]
}, get onanimationend() {
    [native code]
}, set onanimationend() {
    [native code]
}, get onanimationiteration() {
    [native code]
}, set onanimationiteration() {
    [native code]
}, get onanimationstart() {
    [native code]
}, set onanimationstart() {
    [native code]
}, get ontransitioncancel() {
    [native code]
}, set ontransitioncancel() {
    [native code]
}, get ontransitionend() {
    [native code]
}, set ontransitionend() {
    [native code]
}, get ontransitionrun() {
    [native code]
}, set ontransitionrun() {
    [native code]
}, get ontransitionstart() {
    [native code]
}, set ontransitionstart() {
    [native code]
}, get onwebkitanimationend() {
    [native code]
}, set onwebkitanimationend() {
    [native code]
}, get onwebkitanimationiteration() {
    [native code]
}, set onwebkitanimationiteration() {
    [native code]
}, get onwebkitanimationstart() {
    [native code]
}, set onwebkitanimationstart() {
    [native code]
}, get onwebkittransitionend() {
    [native code]
}, set onwebkittransitionend() {
    [native code]
}, get u2f() {
    [native code]
}, set u2f() {
    [native code]
}, get onerror() {
    [native code]
}, set onerror() {
    [native code]
}, get speechSynthesis() {
    [native code]
}, get onafterprint() {
    [native code]
}, set onafterprint() {
    [native code]
}, get onbeforeprint() {
    [native code]
}, set onbeforeprint() {
    [native code]
}, get onbeforeunload() {
    [native code]
}, set onbeforeunload() {
    [native code]
}, get onhashchange() {
    [native code]
}, set onhashchange() {
    [native code]
}, get onlanguagechange() {
    [native code]
}, set onlanguagechange() {
    [native code]
}, get onmessage() {
    [native code]
}, set onmessage() {
    [native code]
}, get onmessageerror() {
    [native code]
}, set onmessageerror() {
    [native code]
}, get onoffline() {
    [native code]
}, set onoffline() {
    [native code]
}, get ononline() {
    [native code]
}, set ononline() {
    [native code]
}, get onpagehide() {
    [native code]
}, set onpagehide() {
    [native code]
}, get onpageshow() {
    [native code]
}, set onpageshow() {
    [native code]
}, get onpopstate() {
    [native code]
}, set onpopstate() {
    [native code]
}, get onrejectionhandled() {
    [native code]
}, set onrejectionhandled() {
    [native code]
}, get onstorage() {
    [native code]
}, set onstorage() {
    [native code]
}, get onunhandledrejection() {
    [native code]
}, set onunhandledrejection() {
    [native code]
}, get onunload() {
    [native code]
}, set onunload() {
    [native code]
}, get ongamepadconnected() {
    [native code]
}, set ongamepadconnected() {
    [native code]
}, get ongamepaddisconnected() {
    [native code]
}, set ongamepaddisconnected() {
    [native code]
}, get localStorage() {
    [native code]
}, get origin() {
    [native code]
}, set origin() {
    [native code]
}, get crossOriginIsolated() {
    [native code]
}, get isSecureContext() {
    [native code]
}, get indexedDB() {
    [native code]
}, get caches() {
    [native code]
}, get sessionStorage() {
    [native code]
}, mozScrollSnap:function mozScrollSnap() {
    [native code]
}, openDialog:function openDialog() {
    [native code]
}, getInterface:function getInterface() {
    [native code]
}, shouldReportForServiceWorkerScope:function shouldReportForServiceWorkerScope() {
    [native code]
}, setScrollMarks:function setScrollMarks() {
    [native code]
}, get controllers() {
    [native code]
}, set controllers() {
    [native code]
}, get realFrameElement() {
    [native code]
}, get docShell() {
    [native code]
}, get browsingContext() {
    [native code]
}, get desktopToDeviceScale() {
    [native code]
}, get scrollMinX() {
    [native code]
}, get scrollMinY() {
    [native code]
}, get windowRoot() {
    [native code]
}, get windowUtils() {
    [native code]
}, get windowGlobalChild() {
    [native code]
}, get clientPrincipal() {
    [native code]
}, get isChromeWindow() {
    [native code]
}, get Glean() {
    [native code]
}, get GleanPings() {
    [native code]
}}, followWindowGlobalLifeCycle:true, isTopLevelTarget:false, ignoreSubFrames:true, sessionContext:{type:"browser-element", browserId:8, isServerTargetSwitchingEnabled:true, isPopupDebuggingEnabled:false}, _extraActors:{consoleActor:{_options:{id:"devtools/server/actors/webconsole", prefix:"console", constructorName:"WebConsoleActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"consoleActor", _pool:{conn:{_prefix:"server0.conn1.windowGlobal4294967313/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn1.windowGlobal4294967313", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"consoleActor", actorID:"server0.conn1.windowGlobal4294967313/consoleActor3", parentPool:{conn:{_prefix:"server0.conn1.windowGlobal4294967313/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn1.windowGlobal4294967313", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, inspectorActor:{_options:{id:"devtools/server/actors/inspector/inspector", prefix:"inspector", constructorName:"InspectorActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"inspectorActor", _pool:{conn:{_prefix:"server0.conn1.windowGlobal4294967313/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn1.windowGlobal4294967313", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"inspectorActor", actorID:"server0.conn1.windowGlobal4294967313/inspectorActor4", parentPool:{conn:{_prefix:"server0.conn1.windowGlobal4294967313/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn1.windowGlobal4294967313", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, styleSheetsActor:{_options:{id:"devtools/server/actors/style-sheets", prefix:"styleSheets", constructorName:"StyleSheetsActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"styleSheetsActor", _pool:{conn:{_prefix:"server0.conn1.windowGlobal4294967313/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn1.windowGlobal4294967313", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"styleSheetsActor", actorID:"server0.conn1.windowGlobal4294967313/styleSheetsActor5", parentPool:{conn:{_prefix:"server0.conn1.windowGlobal4294967313/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn1.windowGlobal4294967313", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, storageActor:{_options:{id:"devtools/server/actors/storage", prefix:"storage", constructorName:"StorageActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"storageActor", _pool:{conn:{_prefix:"server0.conn1.windowGlobal4294967313/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn1.windowGlobal4294967313", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"storageActor", actorID:"server0.conn1.windowGlobal4294967313/storageActor6", parentPool:{conn:{_prefix:"server0.conn1.windowGlobal4294967313/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn1.windowGlobal4294967313", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, memoryActor:{_options:{id:"devtools/server/actors/memory", prefix:"memory", constructorName:"MemoryActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"memoryActor", _pool:{conn:{_prefix:"server0.conn1.windowGlobal4294967313/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn1.windowGlobal4294967313", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"memoryActor", actorID:"server0.conn1.windowGlobal4294967313/memoryActor7", parentPool:{conn:{_prefix:"server0.conn1.windowGlobal4294967313/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn1.windowGlobal4294967313", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, framerateActor:{_options:{id:"devtools/server/actors/framerate", prefix:"framerate", constructorName:"FramerateActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"framerateActor", _pool:{conn:{_prefix:"server0.conn1.windowGlobal4294967313/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn1.windowGlobal4294967313", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"framerateActor", actorID:"server0.conn1.windowGlobal4294967313/framerateActor8", parentPool:{conn:{_prefix:"server0.conn1.windowGlobal4294967313/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn1.windowGlobal4294967313", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, reflowActor:{_options:{id:"devtools/server/actors/reflow", prefix:"reflow", constructorName:"ReflowActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"reflowActor", _pool:{conn:{_prefix:"server0.conn1.windowGlobal4294967313/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn1.windowGlobal4294967313", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"reflowActor", actorID:"server0.conn1.windowGlobal4294967313/reflowActor9", parentPool:{conn:{_prefix:"server0.conn1.windowGlobal4294967313/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn1.windowGlobal4294967313", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, cssPropertiesActor:{_options:{id:"devtools/server/actors/css-properties", prefix:"cssProperties", constructorName:"CssPropertiesActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"cssPropertiesActor", _pool:{conn:{_prefix:"server0.conn1.windowGlobal4294967313/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn1.windowGlobal4294967313", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"cssPropertiesActor", actorID:"server0.conn1.windowGlobal4294967313/cssPropertiesActor10", parentPool:{conn:{_prefix:"server0.conn1.windowGlobal4294967313/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn1.windowGlobal4294967313", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, performanceActor:{_options:{id:"devtools/server/actors/performance", prefix:"performance", constructorName:"PerformanceActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"performanceActor", _pool:{conn:{_prefix:"server0.conn1.windowGlobal4294967313/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn1.windowGlobal4294967313", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"performanceActor", actorID:"server0.conn1.windowGlobal4294967313/performanceActor11", parentPool:{conn:{_prefix:"server0.conn1.windowGlobal4294967313/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn1.windowGlobal4294967313", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, animationsActor:{_options:{id:"devtools/server/actors/animation", prefix:"animations", constructorName:"AnimationsActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"animationsActor", _pool:{conn:{_prefix:"server0.conn1.windowGlobal4294967313/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn1.windowGlobal4294967313", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"animationsActor", actorID:"server0.conn1.windowGlobal4294967313/animationsActor12", parentPool:{conn:{_prefix:"server0.conn1.windowGlobal4294967313/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn1.windowGlobal4294967313", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, responsiveActor:{_options:{id:"devtools/server/actors/emulation/responsive", prefix:"responsive", constructorName:"ResponsiveActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"responsiveActor", _pool:{conn:{_prefix:"server0.conn1.windowGlobal4294967313/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn1.windowGlobal4294967313", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"responsiveActor", actorID:"server0.conn1.windowGlobal4294967313/responsiveActor13", parentPool:{conn:{_prefix:"server0.conn1.windowGlobal4294967313/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn1.windowGlobal4294967313", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, webExtensionInspectedWindowActor:{_options:{id:"devtools/server/actors/addon/webextension-inspected-window", prefix:"webExtensionInspectedWindow", constructorName:"WebExtensionInspectedWindowActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"webExtensionInspectedWindowActor", _pool:{conn:{_prefix:"server0.conn1.windowGlobal4294967313/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn1.windowGlobal4294967313", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"webExtensionInspectedWindowActor", actorID:"server0.conn1.windowGlobal4294967313/webExtensionInspectedWindowActor14", parentPool:{conn:{_prefix:"server0.conn1.windowGlobal4294967313/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn1.windowGlobal4294967313", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, accessibilityActor:{_options:{id:"devtools/server/actors/accessibility/accessibility", prefix:"accessibility", constructorName:"AccessibilityActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"accessibilityActor", _pool:{conn:{_prefix:"server0.conn1.windowGlobal4294967313/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn1.windowGlobal4294967313", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"accessibilityActor", actorID:"server0.conn1.windowGlobal4294967313/accessibilityActor15", parentPool:{conn:{_prefix:"server0.conn1.windowGlobal4294967313/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn1.windowGlobal4294967313", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, changesActor:{_options:{id:"devtools/server/actors/changes", prefix:"changes", constructorName:"ChangesActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"changesActor", _pool:{conn:{_prefix:"server0.conn1.windowGlobal4294967313/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn1.windowGlobal4294967313", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"changesActor", actorID:"server0.conn1.windowGlobal4294967313/changesActor16", parentPool:{conn:{_prefix:"server0.conn1.windowGlobal4294967313/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn1.windowGlobal4294967313", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, webSocketActor:{_options:{id:"devtools/server/actors/network-monitor/websocket-actor", prefix:"webSocket", constructorName:"WebSocketActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"webSocketActor", _pool:{conn:{_prefix:"server0.conn1.windowGlobal4294967313/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn1.windowGlobal4294967313", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"webSocketActor", actorID:"server0.conn1.windowGlobal4294967313/webSocketActor17", parentPool:{conn:{_prefix:"server0.conn1.windowGlobal4294967313/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn1.windowGlobal4294967313", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, eventSourceActor:{_options:{id:"devtools/server/actors/network-monitor/eventsource-actor", prefix:"eventSource", constructorName:"EventSourceActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"eventSourceActor", _pool:{conn:{_prefix:"server0.conn1.windowGlobal4294967313/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn1.windowGlobal4294967313", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"eventSourceActor", actorID:"server0.conn1.windowGlobal4294967313/eventSourceActor18", parentPool:{conn:{_prefix:"server0.conn1.windowGlobal4294967313/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn1.windowGlobal4294967313", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, manifestActor:{_options:{id:"devtools/server/actors/manifest", prefix:"manifest", constructorName:"ManifestActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"manifestActor", _pool:{conn:{_prefix:"server0.conn1.windowGlobal4294967313/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn1.windowGlobal4294967313", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"manifestActor", actorID:"server0.conn1.windowGlobal4294967313/manifestActor19", parentPool:{conn:{_prefix:"server0.conn1.windowGlobal4294967313/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn1.windowGlobal4294967313", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, networkContentActor:{_options:{id:"devtools/server/actors/network-monitor/network-content", prefix:"networkContent", constructorName:"NetworkContentActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"networkContentActor", _pool:{conn:{_prefix:"server0.conn1.windowGlobal4294967313/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn1.windowGlobal4294967313", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"networkContentActor", actorID:"server0.conn1.windowGlobal4294967313/networkContentActor20", parentPool:{conn:{_prefix:"server0.conn1.windowGlobal4294967313/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn1.windowGlobal4294967313", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, screenshotContentActor:{_options:{id:"devtools/server/actors/screenshot-content", prefix:"screenshotContent", constructorName:"ScreenshotContentActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"screenshotContentActor", _pool:{conn:{_prefix:"server0.conn1.windowGlobal4294967313/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn1.windowGlobal4294967313", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"screenshotContentActor", actorID:"server0.conn1.windowGlobal4294967313/screenshotContentActor21", parentPool:{conn:{_prefix:"server0.conn1.windowGlobal4294967313/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn1.windowGlobal4294967313", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}}, _sourcesManager:{_thread:{conn:{_prefix:"server0.conn1.windowGlobal4294967313/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn1.windowGlobal4294967313", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {conn:{}, __poolMap:{}}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, actorID:"server0.conn1.windowGlobal4294967313/thread1", _actorSpec:{typeName:"thread", methods:[{name:"attach", request:{type:"attach", template:{type:"attach", options:{index:0, type:{toString() {
        return "[protocol type:" + name + "]";
      }, name:"json", primitive:true, read:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}, write:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}}}}, args:[{placeholder:{index:0, type:{toString() {
        return "[protocol type:" + name + "]";
      }, name:"json", primitive:true, read:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}, write:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}}}, path:["options"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"reconfigure", request:{type:"reconfigure", template:{type:"reconfigure", options:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["options"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"resume", request:{type:"resume", template:{type:"resume", resumeLimit:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, frameActorID:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["resumeLimit"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["frameActorID"]}]}, response:{template:{_type:"nullable:json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, retVal:{_type:"nullable:json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:[]}, release:(void 0), oneway:(void 0)}, {name:"frames", request:{type:"frames", template:{type:"frames", start:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, count:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["start"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["count"]}]}, response:{template:{_type:"thread.frames", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, retVal:{_type:"thread.frames", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:[]}, release:(void 0), oneway:(void 0)}, {name:"interrupt", request:{type:"interrupt", template:{type:"interrupt", when:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["when"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"sources", request:{type:"sources", template:{type:"sources"}, args:[]}, response:{template:{sources:{_type:"array:json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, retVal:{_type:"array:json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["sources"]}, release:(void 0), oneway:(void 0)}, {name:"skipBreakpoints", request:{type:"skipBreakpoints", template:{type:"skipBreakpoints", skip:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["skip"]}]}, response:{template:{skip:{index:0, type:{toString() {
        return "[protocol type:" + name + "]";
      }, name:"json", primitive:true, read:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}, write:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}}}}}, release:(void 0), oneway:(void 0)}, {name:"dumpThread", request:{type:"dumpThread", template:{type:"dumpThread"}, args:[]}, response:{template:{_type:"json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, retVal:{_type:"json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:[]}, release:(void 0), oneway:(void 0)}, {name:"dumpPools", request:{type:"dumpPools", template:{type:"dumpPools"}, args:[]}, response:{template:{_type:"json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, retVal:{_type:"json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:[]}, release:(void 0), oneway:(void 0)}, {name:"setBreakpoint", request:{type:"setBreakpoint", template:{type:"setBreakpoint", location:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, options:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["location"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["options"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"removeBreakpoint", request:{type:"removeBreakpoint", template:{type:"removeBreakpoint", location:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["location"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"setXHRBreakpoint", request:{type:"setXHRBreakpoint", template:{type:"setXHRBreakpoint", path:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, method:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["path"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["method"]}]}, response:{template:{value:{_type:"boolean", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, retVal:{_type:"boolean", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["value"]}, release:(void 0), oneway:(void 0)}, {name:"removeXHRBreakpoint", request:{type:"removeXHRBreakpoint", template:{type:"removeXHRBreakpoint", path:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, method:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["path"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["method"]}]}, response:{template:{value:{_type:"boolean", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, retVal:{_type:"boolean", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["value"]}, release:(void 0), oneway:(void 0)}, {name:"getAvailableEventBreakpoints", request:{type:"getAvailableEventBreakpoints", template:{type:"getAvailableEventBreakpoints"}, args:[]}, response:{template:{value:{_type:"array:available-breakpoint-group", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, retVal:{_type:"array:available-breakpoint-group", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["value"]}, release:(void 0), oneway:(void 0)}, {name:"getActiveEventBreakpoints", request:{type:"getActiveEventBreakpoints", template:{type:"getActiveEventBreakpoints"}, args:[]}, response:{template:{ids:{_type:"array:string", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, retVal:{_type:"array:string", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["ids"]}, release:(void 0), oneway:(void 0)}, {name:"setActiveEventBreakpoints", request:{type:"setActiveEventBreakpoints", template:{type:"setActiveEventBreakpoints", ids:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["ids"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"pauseOnExceptions", request:{type:"pauseOnExceptions", template:{type:"pauseOnExceptions", pauseOnExceptions:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, ignoreCaughtExceptions:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["pauseOnExceptions"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["ignoreCaughtExceptions"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"toggleEventLogging", request:{type:"toggleEventLogging", template:{type:"toggleEventLogging", logEventBreakpoints:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["logEventBreakpoints"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"isAttached", request:{type:"isAttached", template:{type:"isAttached"}, args:[]}, response:{template:{value:{_type:"boolean", type:{toString() {
        return "[protocol type:" + name + "]";
      }, name:"boolean", primitive:true, read:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}, write:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}}}}, retVal:{_type:"boolean", type:{toString() {
        return "[protocol type:" + name + "]";
      }, name:"boolean", primitive:true, read:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}, write:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}}}, path:["value"]}, release:(void 0), oneway:(void 0)}], events:{}}, _state:"running", _parent:{}, global:{get window() {
    [native code]
}, get document() {
    [native code]
}, get location() {
    [native code]
}, set location() {
    [native code]
}, get top() {
    [native code]
}, close:function close() {
    [native code]
}, stop:function stop() {
    [native code]
}, focus:function focus() {
    [native code]
}, blur:function blur() {
    [native code]
}, open:function open() {
    [native code]
}, alert:function alert() {
    [native code]
}, confirm:function confirm() {
    [native code]
}, prompt:function prompt() {
    [native code]
}, print:function print() {
    [native code]
}, printPreview:function printPreview() {
    [native code]
}, postMessage:function postMessage() {
    [native code]
}, captureEvents:function captureEvents() {
    [native code]
}, releaseEvents:function releaseEvents() {
    [native code]
}, getSelection:function getSelection() {
    [native code]
}, getComputedStyle:function getComputedStyle() {
    [native code]
}, matchMedia:function matchMedia() {
    [native code]
}, moveTo:function moveTo() {
    [native code]
}, moveBy:function moveBy() {
    [native code]
}, resizeTo:function resizeTo() {
    [native code]
}, resizeBy:function resizeBy() {
    [native code]
}, scroll:function scroll() {
    [native code]
}, scrollTo:function scrollTo() {
    [native code]
}, scrollBy:function scrollBy() {
    [native code]
}, getDefaultComputedStyle:function getDefaultComputedStyle() {
    [native code]
}, scrollByLines:function scrollByLines() {
    [native code]
}, scrollByPages:function scrollByPages() {
    [native code]
}, sizeToContent:function sizeToContent() {
    [native code]
}, updateCommands:function updateCommands() {
    [native code]
}, find:function find() {
    [native code]
}, dump:function dump() {
    [native code]
}, setResizable:function setResizable() {
    [native code]
}, requestIdleCallback:function requestIdleCallback() {
    [native code]
}, cancelIdleCallback:function cancelIdleCallback() {
    [native code]
}, getRegionalPrefsLocales:function getRegionalPrefsLocales() {
    [native code]
}, getWebExposedLocales:function getWebExposedLocales() {
    [native code]
}, requestAnimationFrame:function requestAnimationFrame() {
    [native code]
}, cancelAnimationFrame:function cancelAnimationFrame() {
    [native code]
}, reportError:function reportError() {
    [native code]
}, btoa:function btoa() {
    [native code]
}, atob:function atob() {
    [native code]
}, setTimeout:function setTimeout() {
    [native code]
}, clearTimeout:function clearTimeout() {
    [native code]
}, setInterval:function setInterval() {
    [native code]
}, clearInterval:function clearInterval() {
    [native code]
}, queueMicrotask:function queueMicrotask() {
    [native code]
}, createImageBitmap:function createImageBitmap() {
    [native code]
}, structuredClone:function structuredClone() {
    [native code]
}, fetch:function fetch() {
    [native code]
}, get self() {
    [native code]
}, set self() {
    [native code]
}, get name() {
    [native code]
}, set name() {
    [native code]
}, get history() {
    [native code]
}, get customElements() {
    [native code]
}, get locationbar() {
    [native code]
}, set locationbar() {
    [native code]
}, get menubar() {
    [native code]
}, set menubar() {
    [native code]
}, get personalbar() {
    [native code]
}, set personalbar() {
    [native code]
}, get scrollbars() {
    [native code]
}, set scrollbars() {
    [native code]
}, get statusbar() {
    [native code]
}, set statusbar() {
    [native code]
}, get toolbar() {
    [native code]
}, set toolbar() {
    [native code]
}, get status() {
    [native code]
}, set status() {
    [native code]
}, get closed() {
    [native code]
}, get event() {
    [native code]
}, set event() {
    [native code]
}, get frames() {
    [native code]
}, set frames() {
    [native code]
}, get length() {
    [native code]
}, set length() {
    [native code]
}, get opener() {
    [native code]
}, set opener() {
    [native code]
}, get parent() {
    [native code]
}, set parent() {
    [native code]
}, get frameElement() {
    [native code]
}, get navigator() {
    [native code]
}, get clientInformation() {
    [native code]
}, get external() {
    [native code]
}, set external() {
    [native code]
}, get screen() {
    [native code]
}, set screen() {
    [native code]
}, get innerWidth() {
    [native code]
}, set innerWidth() {
    [native code]
}, get innerHeight() {
    [native code]
}, set innerHeight() {
    [native code]
}, get scrollX() {
    [native code]
}, set scrollX() {
    [native code]
}, get pageXOffset() {
    [native code]
}, set pageXOffset() {
    [native code]
}, get scrollY() {
    [native code]
}, set scrollY() {
    [native code]
}, get pageYOffset() {
    [native code]
}, set pageYOffset() {
    [native code]
}, get screenLeft() {
    [native code]
}, set screenLeft() {
    [native code]
}, get screenTop() {
    [native code]
}, set screenTop() {
    [native code]
}, get screenX() {
    [native code]
}, set screenX() {
    [native code]
}, get screenY() {
    [native code]
}, set screenY() {
    [native code]
}, get outerWidth() {
    [native code]
}, set outerWidth() {
    [native code]
}, get outerHeight() {
    [native code]
}, set outerHeight() {
    [native code]
}, get performance() {
    [native code]
}, set performance() {
    [native code]
}, get mozInnerScreenX() {
    [native code]
}, get mozInnerScreenY() {
    [native code]
}, get devicePixelRatio() {
    [native code]
}, set devicePixelRatio() {
    [native code]
}, get scrollMaxX() {
    [native code]
}, set scrollMaxX() {
    [native code]
}, get scrollMaxY() {
    [native code]
}, set scrollMaxY() {
    [native code]
}, get fullScreen() {
    [native code]
}, set fullScreen() {
    [native code]
}, get ondevicemotion() {
    [native code]
}, set ondevicemotion() {
    [native code]
}, get ondeviceorientation() {
    [native code]
}, set ondeviceorientation() {
    [native code]
}, get onabsolutedeviceorientation() {
    [native code]
}, set onabsolutedeviceorientation() {
    [native code]
}, get InstallTrigger() {
    [native code]
}, set InstallTrigger() {
    [native code]
}, get intlUtils() {
    [native code]
}, get visualViewport() {
    [native code]
}, set visualViewport() {
    [native code]
}, get crypto() {
    [native code]
}, get onabort() {
    [native code]
}, set onabort() {
    [native code]
}, get onblur() {
    [native code]
}, set onblur() {
    [native code]
}, get onfocus() {
    [native code]
}, set onfocus() {
    [native code]
}, get onauxclick() {
    [native code]
}, set onauxclick() {
    [native code]
}, get onbeforeinput() {
    [native code]
}, set onbeforeinput() {
    [native code]
}, get oncanplay() {
    [native code]
}, set oncanplay() {
    [native code]
}, get oncanplaythrough() {
    [native code]
}, set oncanplaythrough() {
    [native code]
}, get onchange() {
    [native code]
}, set onchange() {
    [native code]
}, get onclick() {
    [native code]
}, set onclick() {
    [native code]
}, get onclose() {
    [native code]
}, set onclose() {
    [native code]
}, get oncontextmenu() {
    [native code]
}, set oncontextmenu() {
    [native code]
}, get oncuechange() {
    [native code]
}, set oncuechange() {
    [native code]
}, get ondblclick() {
    [native code]
}, set ondblclick() {
    [native code]
}, get ondrag() {
    [native code]
}, set ondrag() {
    [native code]
}, get ondragend() {
    [native code]
}, set ondragend() {
    [native code]
}, get ondragenter() {
    [native code]
}, set ondragenter() {
    [native code]
}, get ondragexit() {
    [native code]
}, set ondragexit() {
    [native code]
}, get ondragleave() {
    [native code]
}, set ondragleave() {
    [native code]
}, get ondragover() {
    [native code]
}, set ondragover() {
    [native code]
}, get ondragstart() {
    [native code]
}, set ondragstart() {
    [native code]
}, get ondrop() {
    [native code]
}, set ondrop() {
    [native code]
}, get ondurationchange() {
    [native code]
}, set ondurationchange() {
    [native code]
}, get onemptied() {
    [native code]
}, set onemptied() {
    [native code]
}, get onended() {
    [native code]
}, set onended() {
    [native code]
}, get onformdata() {
    [native code]
}, set onformdata() {
    [native code]
}, get oninput() {
    [native code]
}, set oninput() {
    [native code]
}, get oninvalid() {
    [native code]
}, set oninvalid() {
    [native code]
}, get onkeydown() {
    [native code]
}, set onkeydown() {
    [native code]
}, get onkeypress() {
    [native code]
}, set onkeypress() {
    [native code]
}, get onkeyup() {
    [native code]
}, set onkeyup() {
    [native code]
}, get onload() {
    [native code]
}, set onload() {
    [native code]
}, get onloadeddata() {
    [native code]
}, set onloadeddata() {
    [native code]
}, get onloadedmetadata() {
    [native code]
}, set onloadedmetadata() {
    [native code]
}, get onloadend() {
    [native code]
}, set onloadend() {
    [native code]
}, get onloadstart() {
    [native code]
}, set onloadstart() {
    [native code]
}, get onmousedown() {
    [native code]
}, set onmousedown() {
    [native code]
}, get onmouseenter() {
    [native code]
}, set onmouseenter() {
    [native code]
}, get onmouseleave() {
    [native code]
}, set onmouseleave() {
    [native code]
}, get onmousemove() {
    [native code]
}, set onmousemove() {
    [native code]
}, get onmouseout() {
    [native code]
}, set onmouseout() {
    [native code]
}, get onmouseover() {
    [native code]
}, set onmouseover() {
    [native code]
}, get onmouseup() {
    [native code]
}, set onmouseup() {
    [native code]
}, get onwheel() {
    [native code]
}, set onwheel() {
    [native code]
}, get onpause() {
    [native code]
}, set onpause() {
    [native code]
}, get onplay() {
    [native code]
}, set onplay() {
    [native code]
}, get onplaying() {
    [native code]
}, set onplaying() {
    [native code]
}, get onprogress() {
    [native code]
}, set onprogress() {
    [native code]
}, get onratechange() {
    [native code]
}, set onratechange() {
    [native code]
}, get onreset() {
    [native code]
}, set onreset() {
    [native code]
}, get onresize() {
    [native code]
}, set onresize() {
    [native code]
}, get onscroll() {
    [native code]
}, set onscroll() {
    [native code]
}, get onsecuritypolicyviolation() {
    [native code]
}, set onsecuritypolicyviolation() {
    [native code]
}, get onseeked() {
    [native code]
}, set onseeked() {
    [native code]
}, get onseeking() {
    [native code]
}, set onseeking() {
    [native code]
}, get onselect() {
    [native code]
}, set onselect() {
    [native code]
}, get onslotchange() {
    [native code]
}, set onslotchange() {
    [native code]
}, get onstalled() {
    [native code]
}, set onstalled() {
    [native code]
}, get onsubmit() {
    [native code]
}, set onsubmit() {
    [native code]
}, get onsuspend() {
    [native code]
}, set onsuspend() {
    [native code]
}, get ontimeupdate() {
    [native code]
}, set ontimeupdate() {
    [native code]
}, get onvolumechange() {
    [native code]
}, set onvolumechange() {
    [native code]
}, get onwaiting() {
    [native code]
}, set onwaiting() {
    [native code]
}, get onselectstart() {
    [native code]
}, set onselectstart() {
    [native code]
}, get onselectionchange() {
    [native code]
}, set onselectionchange() {
    [native code]
}, get ontoggle() {
    [native code]
}, set ontoggle() {
    [native code]
}, get onpointercancel() {
    [native code]
}, set onpointercancel() {
    [native code]
}, get onpointerdown() {
    [native code]
}, set onpointerdown() {
    [native code]
}, get onpointerup() {
    [native code]
}, set onpointerup() {
    [native code]
}, get onpointermove() {
    [native code]
}, set onpointermove() {
    [native code]
}, get onpointerout() {
    [native code]
}, set onpointerout() {
    [native code]
}, get onpointerover() {
    [native code]
}, set onpointerover() {
    [native code]
}, get onpointerenter() {
    [native code]
}, set onpointerenter() {
    [native code]
}, get onpointerleave() {
    [native code]
}, set onpointerleave() {
    [native code]
}, get ongotpointercapture() {
    [native code]
}, set ongotpointercapture() {
    [native code]
}, get onlostpointercapture() {
    [native code]
}, set onlostpointercapture() {
    [native code]
}, get onmozfullscreenchange() {
    [native code]
}, set onmozfullscreenchange() {
    [native code]
}, get onmozfullscreenerror() {
    [native code]
}, set onmozfullscreenerror() {
    [native code]
}, get onanimationcancel() {
    [native code]
}, set onanimationcancel() {
    [native code]
}, get onanimationend() {
    [native code]
}, set onanimationend() {
    [native code]
}, get onanimationiteration() {
    [native code]
}, set onanimationiteration() {
    [native code]
}, get onanimationstart() {
    [native code]
}, set onanimationstart() {
    [native code]
}, get ontransitioncancel() {
    [native code]
}, set ontransitioncancel() {
    [native code]
}, get ontransitionend() {
    [native code]
}, set ontransitionend() {
    [native code]
}, get ontransitionrun() {
    [native code]
}, set ontransitionrun() {
    [native code]
}, get ontransitionstart() {
    [native code]
}, set ontransitionstart() {
    [native code]
}, get onwebkitanimationend() {
    [native code]
}, set onwebkitanimationend() {
    [native code]
}, get onwebkitanimationiteration() {
    [native code]
}, set onwebkitanimationiteration() {
    [native code]
}, get onwebkitanimationstart() {
    [native code]
}, set onwebkitanimationstart() {
    [native code]
}, get onwebkittransitionend() {
    [native code]
}, set onwebkittransitionend() {
    [native code]
}, get u2f() {
    [native code]
}, set u2f() {
    [native code]
}, get onerror() {
    [native code]
}, set onerror() {
    [native code]
}, get speechSynthesis() {
    [native code]
}, get onafterprint() {
    [native code]
}, set onafterprint() {
    [native code]
}, get onbeforeprint() {
    [native code]
}, set onbeforeprint() {
    [native code]
}, get onbeforeunload() {
    [native code]
}, set onbeforeunload() {
    [native code]
}, get onhashchange() {
    [native code]
}, set onhashchange() {
    [native code]
}, get onlanguagechange() {
    [native code]
}, set onlanguagechange() {
    [native code]
}, get onmessage() {
    [native code]
}, set onmessage() {
    [native code]
}, get onmessageerror() {
    [native code]
}, set onmessageerror() {
    [native code]
}, get onoffline() {
    [native code]
}, set onoffline() {
    [native code]
}, get ononline() {
    [native code]
}, set ononline() {
    [native code]
}, get onpagehide() {
    [native code]
}, set onpagehide() {
    [native code]
}, get onpageshow() {
    [native code]
}, set onpageshow() {
    [native code]
}, get onpopstate() {
    [native code]
}, set onpopstate() {
    [native code]
}, get onrejectionhandled() {
    [native code]
}, set onrejectionhandled() {
    [native code]
}, get onstorage() {
    [native code]
}, set onstorage() {
    [native code]
}, get onunhandledrejection() {
    [native code]
}, set onunhandledrejection() {
    [native code]
}, get onunload() {
    [native code]
}, set onunload() {
    [native code]
}, get ongamepadconnected() {
    [native code]
}, set ongamepadconnected() {
    [native code]
}, get ongamepaddisconnected() {
    [native code]
}, set ongamepaddisconnected() {
    [native code]
}, get localStorage() {
    [native code]
}, get origin() {
    [native code]
}, set origin() {
    [native code]
}, get crossOriginIsolated() {
    [native code]
}, get isSecureContext() {
    [native code]
}, get indexedDB() {
    [native code]
}, get caches() {
    [native code]
}, get sessionStorage() {
    [native code]
}, mozScrollSnap:function mozScrollSnap() {
    [native code]
}, openDialog:function openDialog() {
    [native code]
}, getInterface:function getInterface() {
    [native code]
}, shouldReportForServiceWorkerScope:function shouldReportForServiceWorkerScope() {
    [native code]
}, setScrollMarks:function setScrollMarks() {
    [native code]
}, get controllers() {
    [native code]
}, set controllers() {
    [native code]
}, get realFrameElement() {
    [native code]
}, get docShell() {
    [native code]
}, get browsingContext() {
    [native code]
}, get desktopToDeviceScale() {
    [native code]
}, get scrollMinX() {
    [native code]
}, get scrollMinY() {
    [native code]
}, get windowRoot() {
    [native code]
}, get windowUtils() {
    [native code]
}, get windowGlobalChild() {
    [native code]
}, get clientPrincipal() {
    [native code]
}, get isChromeWindow() {
    [native code]
}, get Glean() {
    [native code]
}, get GleanPings() {
    [native code]
}}, _options:{skipBreakpoints:false, pauseOnExceptions:false, ignoreCaughtExceptions:true, shouldShowOverlay:true, shouldIncludeSavedFrames:true, shouldIncludeAsyncLiveFrames:false, logEventBreakpoints:false, observeAsmJS:true}, _gripDepth:0, _parentClosed:false, _observingNetwork:false, _frameActors:[], _xhrBreakpoints:[], _dbg:{addDebuggees:(function() {
    for (const global of findDebuggees(this)) {
      safeAddDebuggee(this, global);
    }
  }), disable:(function() {
    dbg.removeAllDebuggees();
    dbg.onNewGlobalObject = undefined;
  }), enable:(function() {
    dbg.addDebuggees();
    dbg.onNewGlobalObject = onNewGlobalObject;
  }), onNewDebuggee:function bound _onNewDebuggee() {
    [native code]
}}, _threadLifetimePool:null, _activeEventPause:null, _pauseOverlay:null, _priorPause:null, _activeEventBreakpoints:{}, _frameActorMap:{}, _debuggerSourcesSeen:{}, _onLoadBreakpointURLs:{}, _handledFrameExceptions:{}, _watchpointsMap:{threadActor:{}, _watchpoints:{}}, breakpointActorMap:{_threadActor:{}, _actors:{}}, _nestedEventLoop:{_thread:{}, _entered:false, _resolved:false}, onNewSourceEvent:function bound onNewSourceEvent() {
    [native code]
}, createCompletionGrip:function bound createCompletionGrip() {
    [native code]
}, onDebuggerStatement:function bound onDebuggerStatement() {
    [native code]
}, onNewScript:function bound onNewScript() {
    [native code]
}, objectGrip:function bound objectGrip() {
    [native code]
}, pauseObjectGrip:function bound pauseObjectGrip() {
    [native code]
}, _onOpeningRequest:function bound _onOpeningRequest() {
    [native code]
}, _onNewDebuggee:function bound _onNewDebuggee() {
    [native code]
}, _onExceptionUnwind:function bound _onExceptionUnwind() {
    [native code]
}, _eventBreakpointListener:function bound _eventBreakpointListener() {
    [native code]
}, _onWindowReady:function bound _onWindowReady() {
    [native code]
}, _onWillNavigate:function bound _onWillNavigate() {
    [native code]
}, _onNavigate:function bound _onNavigate() {
    [native code]
}, _firstStatementBreakpoint:null, _debuggerNotificationObserver:{}, parentPool:{}, alreadyAttached:true, wrappedJSObject:{}, _shouldEmitNewSource:false, _pendingResponse:{}, [Symbol("EventEmitter/listeners")]:{}}, blackBoxedSources:{}, _sourceActors:{}, _urlContents:{}, _urlWaiters:{}, _sourcesByInternalSourceId:null, [Symbol("EventEmitter/listeners")]:{}}, _styleSheetActors:{}, _shouldAddNewGlobalAsDebuggee:function bound _shouldAddNewGlobalAsDebuggee() {
    [native code]
}, makeDebugger:function bound makeDebugger() {
    [native code]
}, watchNewDocShells:false, _isNewPerfPanelEnabled:true, _workerDescriptorActorList:null, _workerDescriptorActorPool:null, _onWorkerDescriptorActorListChanged:function bound _onWorkerDescriptorActorListChanged() {
    [native code]
}, _onConsoleApiProfilerEvent:function bound _onConsoleApiProfilerEvent() {
    [native code]
}, threadActor:{conn:{_prefix:"server0.conn1.windowGlobal4294967313/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn1.windowGlobal4294967313", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {conn:{}, __poolMap:{}}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, actorID:"server0.conn1.windowGlobal4294967313/thread1", _actorSpec:{typeName:"thread", methods:[{name:"attach", request:{type:"attach", template:{type:"attach", options:{index:0, type:{toString() {
        return "[protocol type:" + name + "]";
      }, name:"json", primitive:true, read:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}, write:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}}}}, args:[{placeholder:{index:0, type:{toString() {
        return "[protocol type:" + name + "]";
      }, name:"json", primitive:true, read:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}, write:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}}}, path:["options"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"reconfigure", request:{type:"reconfigure", template:{type:"reconfigure", options:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["options"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"resume", request:{type:"resume", template:{type:"resume", resumeLimit:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, frameActorID:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["resumeLimit"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["frameActorID"]}]}, response:{template:{_type:"nullable:json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, retVal:{_type:"nullable:json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:[]}, release:(void 0), oneway:(void 0)}, {name:"frames", request:{type:"frames", template:{type:"frames", start:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, count:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["start"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["count"]}]}, response:{template:{_type:"thread.frames", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, retVal:{_type:"thread.frames", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:[]}, release:(void 0), oneway:(void 0)}, {name:"interrupt", request:{type:"interrupt", template:{type:"interrupt", when:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["when"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"sources", request:{type:"sources", template:{type:"sources"}, args:[]}, response:{template:{sources:{_type:"array:json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, retVal:{_type:"array:json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["sources"]}, release:(void 0), oneway:(void 0)}, {name:"skipBreakpoints", request:{type:"skipBreakpoints", template:{type:"skipBreakpoints", skip:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["skip"]}]}, response:{template:{skip:{index:0, type:{toString() {
        return "[protocol type:" + name + "]";
      }, name:"json", primitive:true, read:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}, write:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}}}}}, release:(void 0), oneway:(void 0)}, {name:"dumpThread", request:{type:"dumpThread", template:{type:"dumpThread"}, args:[]}, response:{template:{_type:"json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, retVal:{_type:"json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:[]}, release:(void 0), oneway:(void 0)}, {name:"dumpPools", request:{type:"dumpPools", template:{type:"dumpPools"}, args:[]}, response:{template:{_type:"json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, retVal:{_type:"json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:[]}, release:(void 0), oneway:(void 0)}, {name:"setBreakpoint", request:{type:"setBreakpoint", template:{type:"setBreakpoint", location:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, options:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["location"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["options"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"removeBreakpoint", request:{type:"removeBreakpoint", template:{type:"removeBreakpoint", location:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["location"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"setXHRBreakpoint", request:{type:"setXHRBreakpoint", template:{type:"setXHRBreakpoint", path:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, method:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["path"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["method"]}]}, response:{template:{value:{_type:"boolean", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, retVal:{_type:"boolean", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["value"]}, release:(void 0), oneway:(void 0)}, {name:"removeXHRBreakpoint", request:{type:"removeXHRBreakpoint", template:{type:"removeXHRBreakpoint", path:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, method:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["path"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["method"]}]}, response:{template:{value:{_type:"boolean", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, retVal:{_type:"boolean", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["value"]}, release:(void 0), oneway:(void 0)}, {name:"getAvailableEventBreakpoints", request:{type:"getAvailableEventBreakpoints", template:{type:"getAvailableEventBreakpoints"}, args:[]}, response:{template:{value:{_type:"array:available-breakpoint-group", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, retVal:{_type:"array:available-breakpoint-group", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["value"]}, release:(void 0), oneway:(void 0)}, {name:"getActiveEventBreakpoints", request:{type:"getActiveEventBreakpoints", template:{type:"getActiveEventBreakpoints"}, args:[]}, response:{template:{ids:{_type:"array:string", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, retVal:{_type:"array:string", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["ids"]}, release:(void 0), oneway:(void 0)}, {name:"setActiveEventBreakpoints", request:{type:"setActiveEventBreakpoints", template:{type:"setActiveEventBreakpoints", ids:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["ids"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"pauseOnExceptions", request:{type:"pauseOnExceptions", template:{type:"pauseOnExceptions", pauseOnExceptions:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, ignoreCaughtExceptions:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["pauseOnExceptions"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["ignoreCaughtExceptions"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"toggleEventLogging", request:{type:"toggleEventLogging", template:{type:"toggleEventLogging", logEventBreakpoints:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["logEventBreakpoints"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"isAttached", request:{type:"isAttached", template:{type:"isAttached"}, args:[]}, response:{template:{value:{_type:"boolean", type:{toString() {
        return "[protocol type:" + name + "]";
      }, name:"boolean", primitive:true, read:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}, write:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}}}}, retVal:{_type:"boolean", type:{toString() {
        return "[protocol type:" + name + "]";
      }, name:"boolean", primitive:true, read:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}, write:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}}}, path:["value"]}, release:(void 0), oneway:(void 0)}], events:{}}, _state:"running", _parent:{}, global:{get window() {
    [native code]
}, get document() {
    [native code]
}, get location() {
    [native code]
}, set location() {
    [native code]
}, get top() {
    [native code]
}, close:function close() {
    [native code]
}, stop:function stop() {
    [native code]
}, focus:function focus() {
    [native code]
}, blur:function blur() {
    [native code]
}, open:function open() {
    [native code]
}, alert:function alert() {
    [native code]
}, confirm:function confirm() {
    [native code]
}, prompt:function prompt() {
    [native code]
}, print:function print() {
    [native code]
}, printPreview:function printPreview() {
    [native code]
}, postMessage:function postMessage() {
    [native code]
}, captureEvents:function captureEvents() {
    [native code]
}, releaseEvents:function releaseEvents() {
    [native code]
}, getSelection:function getSelection() {
    [native code]
}, getComputedStyle:function getComputedStyle() {
    [native code]
}, matchMedia:function matchMedia() {
    [native code]
}, moveTo:function moveTo() {
    [native code]
}, moveBy:function moveBy() {
    [native code]
}, resizeTo:function resizeTo() {
    [native code]
}, resizeBy:function resizeBy() {
    [native code]
}, scroll:function scroll() {
    [native code]
}, scrollTo:function scrollTo() {
    [native code]
}, scrollBy:function scrollBy() {
    [native code]
}, getDefaultComputedStyle:function getDefaultComputedStyle() {
    [native code]
}, scrollByLines:function scrollByLines() {
    [native code]
}, scrollByPages:function scrollByPages() {
    [native code]
}, sizeToContent:function sizeToContent() {
    [native code]
}, updateCommands:function updateCommands() {
    [native code]
}, find:function find() {
    [native code]
}, dump:function dump() {
    [native code]
}, setResizable:function setResizable() {
    [native code]
}, requestIdleCallback:function requestIdleCallback() {
    [native code]
}, cancelIdleCallback:function cancelIdleCallback() {
    [native code]
}, getRegionalPrefsLocales:function getRegionalPrefsLocales() {
    [native code]
}, getWebExposedLocales:function getWebExposedLocales() {
    [native code]
}, requestAnimationFrame:function requestAnimationFrame() {
    [native code]
}, cancelAnimationFrame:function cancelAnimationFrame() {
    [native code]
}, reportError:function reportError() {
    [native code]
}, btoa:function btoa() {
    [native code]
}, atob:function atob() {
    [native code]
}, setTimeout:function setTimeout() {
    [native code]
}, clearTimeout:function clearTimeout() {
    [native code]
}, setInterval:function setInterval() {
    [native code]
}, clearInterval:function clearInterval() {
    [native code]
}, queueMicrotask:function queueMicrotask() {
    [native code]
}, createImageBitmap:function createImageBitmap() {
    [native code]
}, structuredClone:function structuredClone() {
    [native code]
}, fetch:function fetch() {
    [native code]
}, get self() {
    [native code]
}, set self() {
    [native code]
}, get name() {
    [native code]
}, set name() {
    [native code]
}, get history() {
    [native code]
}, get customElements() {
    [native code]
}, get locationbar() {
    [native code]
}, set locationbar() {
    [native code]
}, get menubar() {
    [native code]
}, set menubar() {
    [native code]
}, get personalbar() {
    [native code]
}, set personalbar() {
    [native code]
}, get scrollbars() {
    [native code]
}, set scrollbars() {
    [native code]
}, get statusbar() {
    [native code]
}, set statusbar() {
    [native code]
}, get toolbar() {
    [native code]
}, set toolbar() {
    [native code]
}, get status() {
    [native code]
}, set status() {
    [native code]
}, get closed() {
    [native code]
}, get event() {
    [native code]
}, set event() {
    [native code]
}, get frames() {
    [native code]
}, set frames() {
    [native code]
}, get length() {
    [native code]
}, set length() {
    [native code]
}, get opener() {
    [native code]
}, set opener() {
    [native code]
}, get parent() {
    [native code]
}, set parent() {
    [native code]
}, get frameElement() {
    [native code]
}, get navigator() {
    [native code]
}, get clientInformation() {
    [native code]
}, get external() {
    [native code]
}, set external() {
    [native code]
}, get screen() {
    [native code]
}, set screen() {
    [native code]
}, get innerWidth() {
    [native code]
}, set innerWidth() {
    [native code]
}, get innerHeight() {
    [native code]
}, set innerHeight() {
    [native code]
}, get scrollX() {
    [native code]
}, set scrollX() {
    [native code]
}, get pageXOffset() {
    [native code]
}, set pageXOffset() {
    [native code]
}, get scrollY() {
    [native code]
}, set scrollY() {
    [native code]
}, get pageYOffset() {
    [native code]
}, set pageYOffset() {
    [native code]
}, get screenLeft() {
    [native code]
}, set screenLeft() {
    [native code]
}, get screenTop() {
    [native code]
}, set screenTop() {
    [native code]
}, get screenX() {
    [native code]
}, set screenX() {
    [native code]
}, get screenY() {
    [native code]
}, set screenY() {
    [native code]
}, get outerWidth() {
    [native code]
}, set outerWidth() {
    [native code]
}, get outerHeight() {
    [native code]
}, set outerHeight() {
    [native code]
}, get performance() {
    [native code]
}, set performance() {
    [native code]
}, get mozInnerScreenX() {
    [native code]
}, get mozInnerScreenY() {
    [native code]
}, get devicePixelRatio() {
    [native code]
}, set devicePixelRatio() {
    [native code]
}, get scrollMaxX() {
    [native code]
}, set scrollMaxX() {
    [native code]
}, get scrollMaxY() {
    [native code]
}, set scrollMaxY() {
    [native code]
}, get fullScreen() {
    [native code]
}, set fullScreen() {
    [native code]
}, get ondevicemotion() {
    [native code]
}, set ondevicemotion() {
    [native code]
}, get ondeviceorientation() {
    [native code]
}, set ondeviceorientation() {
    [native code]
}, get onabsolutedeviceorientation() {
    [native code]
}, set onabsolutedeviceorientation() {
    [native code]
}, get InstallTrigger() {
    [native code]
}, set InstallTrigger() {
    [native code]
}, get intlUtils() {
    [native code]
}, get visualViewport() {
    [native code]
}, set visualViewport() {
    [native code]
}, get crypto() {
    [native code]
}, get onabort() {
    [native code]
}, set onabort() {
    [native code]
}, get onblur() {
    [native code]
}, set onblur() {
    [native code]
}, get onfocus() {
    [native code]
}, set onfocus() {
    [native code]
}, get onauxclick() {
    [native code]
}, set onauxclick() {
    [native code]
}, get onbeforeinput() {
    [native code]
}, set onbeforeinput() {
    [native code]
}, get oncanplay() {
    [native code]
}, set oncanplay() {
    [native code]
}, get oncanplaythrough() {
    [native code]
}, set oncanplaythrough() {
    [native code]
}, get onchange() {
    [native code]
}, set onchange() {
    [native code]
}, get onclick() {
    [native code]
}, set onclick() {
    [native code]
}, get onclose() {
    [native code]
}, set onclose() {
    [native code]
}, get oncontextmenu() {
    [native code]
}, set oncontextmenu() {
    [native code]
}, get oncuechange() {
    [native code]
}, set oncuechange() {
    [native code]
}, get ondblclick() {
    [native code]
}, set ondblclick() {
    [native code]
}, get ondrag() {
    [native code]
}, set ondrag() {
    [native code]
}, get ondragend() {
    [native code]
}, set ondragend() {
    [native code]
}, get ondragenter() {
    [native code]
}, set ondragenter() {
    [native code]
}, get ondragexit() {
    [native code]
}, set ondragexit() {
    [native code]
}, get ondragleave() {
    [native code]
}, set ondragleave() {
    [native code]
}, get ondragover() {
    [native code]
}, set ondragover() {
    [native code]
}, get ondragstart() {
    [native code]
}, set ondragstart() {
    [native code]
}, get ondrop() {
    [native code]
}, set ondrop() {
    [native code]
}, get ondurationchange() {
    [native code]
}, set ondurationchange() {
    [native code]
}, get onemptied() {
    [native code]
}, set onemptied() {
    [native code]
}, get onended() {
    [native code]
}, set onended() {
    [native code]
}, get onformdata() {
    [native code]
}, set onformdata() {
    [native code]
}, get oninput() {
    [native code]
}, set oninput() {
    [native code]
}, get oninvalid() {
    [native code]
}, set oninvalid() {
    [native code]
}, get onkeydown() {
    [native code]
}, set onkeydown() {
    [native code]
}, get onkeypress() {
    [native code]
}, set onkeypress() {
    [native code]
}, get onkeyup() {
    [native code]
}, set onkeyup() {
    [native code]
}, get onload() {
    [native code]
}, set onload() {
    [native code]
}, get onloadeddata() {
    [native code]
}, set onloadeddata() {
    [native code]
}, get onloadedmetadata() {
    [native code]
}, set onloadedmetadata() {
    [native code]
}, get onloadend() {
    [native code]
}, set onloadend() {
    [native code]
}, get onloadstart() {
    [native code]
}, set onloadstart() {
    [native code]
}, get onmousedown() {
    [native code]
}, set onmousedown() {
    [native code]
}, get onmouseenter() {
    [native code]
}, set onmouseenter() {
    [native code]
}, get onmouseleave() {
    [native code]
}, set onmouseleave() {
    [native code]
}, get onmousemove() {
    [native code]
}, set onmousemove() {
    [native code]
}, get onmouseout() {
    [native code]
}, set onmouseout() {
    [native code]
}, get onmouseover() {
    [native code]
}, set onmouseover() {
    [native code]
}, get onmouseup() {
    [native code]
}, set onmouseup() {
    [native code]
}, get onwheel() {
    [native code]
}, set onwheel() {
    [native code]
}, get onpause() {
    [native code]
}, set onpause() {
    [native code]
}, get onplay() {
    [native code]
}, set onplay() {
    [native code]
}, get onplaying() {
    [native code]
}, set onplaying() {
    [native code]
}, get onprogress() {
    [native code]
}, set onprogress() {
    [native code]
}, get onratechange() {
    [native code]
}, set onratechange() {
    [native code]
}, get onreset() {
    [native code]
}, set onreset() {
    [native code]
}, get onresize() {
    [native code]
}, set onresize() {
    [native code]
}, get onscroll() {
    [native code]
}, set onscroll() {
    [native code]
}, get onsecuritypolicyviolation() {
    [native code]
}, set onsecuritypolicyviolation() {
    [native code]
}, get onseeked() {
    [native code]
}, set onseeked() {
    [native code]
}, get onseeking() {
    [native code]
}, set onseeking() {
    [native code]
}, get onselect() {
    [native code]
}, set onselect() {
    [native code]
}, get onslotchange() {
    [native code]
}, set onslotchange() {
    [native code]
}, get onstalled() {
    [native code]
}, set onstalled() {
    [native code]
}, get onsubmit() {
    [native code]
}, set onsubmit() {
    [native code]
}, get onsuspend() {
    [native code]
}, set onsuspend() {
    [native code]
}, get ontimeupdate() {
    [native code]
}, set ontimeupdate() {
    [native code]
}, get onvolumechange() {
    [native code]
}, set onvolumechange() {
    [native code]
}, get onwaiting() {
    [native code]
}, set onwaiting() {
    [native code]
}, get onselectstart() {
    [native code]
}, set onselectstart() {
    [native code]
}, get onselectionchange() {
    [native code]
}, set onselectionchange() {
    [native code]
}, get ontoggle() {
    [native code]
}, set ontoggle() {
    [native code]
}, get onpointercancel() {
    [native code]
}, set onpointercancel() {
    [native code]
}, get onpointerdown() {
    [native code]
}, set onpointerdown() {
    [native code]
}, get onpointerup() {
    [native code]
}, set onpointerup() {
    [native code]
}, get onpointermove() {
    [native code]
}, set onpointermove() {
    [native code]
}, get onpointerout() {
    [native code]
}, set onpointerout() {
    [native code]
}, get onpointerover() {
    [native code]
}, set onpointerover() {
    [native code]
}, get onpointerenter() {
    [native code]
}, set onpointerenter() {
    [native code]
}, get onpointerleave() {
    [native code]
}, set onpointerleave() {
    [native code]
}, get ongotpointercapture() {
    [native code]
}, set ongotpointercapture() {
    [native code]
}, get onlostpointercapture() {
    [native code]
}, set onlostpointercapture() {
    [native code]
}, get onmozfullscreenchange() {
    [native code]
}, set onmozfullscreenchange() {
    [native code]
}, get onmozfullscreenerror() {
    [native code]
}, set onmozfullscreenerror() {
    [native code]
}, get onanimationcancel() {
    [native code]
}, set onanimationcancel() {
    [native code]
}, get onanimationend() {
    [native code]
}, set onanimationend() {
    [native code]
}, get onanimationiteration() {
    [native code]
}, set onanimationiteration() {
    [native code]
}, get onanimationstart() {
    [native code]
}, set onanimationstart() {
    [native code]
}, get ontransitioncancel() {
    [native code]
}, set ontransitioncancel() {
    [native code]
}, get ontransitionend() {
    [native code]
}, set ontransitionend() {
    [native code]
}, get ontransitionrun() {
    [native code]
}, set ontransitionrun() {
    [native code]
}, get ontransitionstart() {
    [native code]
}, set ontransitionstart() {
    [native code]
}, get onwebkitanimationend() {
    [native code]
}, set onwebkitanimationend() {
    [native code]
}, get onwebkitanimationiteration() {
    [native code]
}, set onwebkitanimationiteration() {
    [native code]
}, get onwebkitanimationstart() {
    [native code]
}, set onwebkitanimationstart() {
    [native code]
}, get onwebkittransitionend() {
    [native code]
}, set onwebkittransitionend() {
    [native code]
}, get u2f() {
    [native code]
}, set u2f() {
    [native code]
}, get onerror() {
    [native code]
}, set onerror() {
    [native code]
}, get speechSynthesis() {
    [native code]
}, get onafterprint() {
    [native code]
}, set onafterprint() {
    [native code]
}, get onbeforeprint() {
    [native code]
}, set onbeforeprint() {
    [native code]
}, get onbeforeunload() {
    [native code]
}, set onbeforeunload() {
    [native code]
}, get onhashchange() {
    [native code]
}, set onhashchange() {
    [native code]
}, get onlanguagechange() {
    [native code]
}, set onlanguagechange() {
    [native code]
}, get onmessage() {
    [native code]
}, set onmessage() {
    [native code]
}, get onmessageerror() {
    [native code]
}, set onmessageerror() {
    [native code]
}, get onoffline() {
    [native code]
}, set onoffline() {
    [native code]
}, get ononline() {
    [native code]
}, set ononline() {
    [native code]
}, get onpagehide() {
    [native code]
}, set onpagehide() {
    [native code]
}, get onpageshow() {
    [native code]
}, set onpageshow() {
    [native code]
}, get onpopstate() {
    [native code]
}, set onpopstate() {
    [native code]
}, get onrejectionhandled() {
    [native code]
}, set onrejectionhandled() {
    [native code]
}, get onstorage() {
    [native code]
}, set onstorage() {
    [native code]
}, get onunhandledrejection() {
    [native code]
}, set onunhandledrejection() {
    [native code]
}, get onunload() {
    [native code]
}, set onunload() {
    [native code]
}, get ongamepadconnected() {
    [native code]
}, set ongamepadconnected() {
    [native code]
}, get ongamepaddisconnected() {
    [native code]
}, set ongamepaddisconnected() {
    [native code]
}, get localStorage() {
    [native code]
}, get origin() {
    [native code]
}, set origin() {
    [native code]
}, get crossOriginIsolated() {
    [native code]
}, get isSecureContext() {
    [native code]
}, get indexedDB() {
    [native code]
}, get caches() {
    [native code]
}, get sessionStorage() {
    [native code]
}, mozScrollSnap:function mozScrollSnap() {
    [native code]
}, openDialog:function openDialog() {
    [native code]
}, getInterface:function getInterface() {
    [native code]
}, shouldReportForServiceWorkerScope:function shouldReportForServiceWorkerScope() {
    [native code]
}, setScrollMarks:function setScrollMarks() {
    [native code]
}, get controllers() {
    [native code]
}, set controllers() {
    [native code]
}, get realFrameElement() {
    [native code]
}, get docShell() {
    [native code]
}, get browsingContext() {
    [native code]
}, get desktopToDeviceScale() {
    [native code]
}, get scrollMinX() {
    [native code]
}, get scrollMinY() {
    [native code]
}, get windowRoot() {
    [native code]
}, get windowUtils() {
    [native code]
}, get windowGlobalChild() {
    [native code]
}, get clientPrincipal() {
    [native code]
}, get isChromeWindow() {
    [native code]
}, get Glean() {
    [native code]
}, get GleanPings() {
    [native code]
}}, _options:{skipBreakpoints:false, pauseOnExceptions:false, ignoreCaughtExceptions:true, shouldShowOverlay:true, shouldIncludeSavedFrames:true, shouldIncludeAsyncLiveFrames:false, logEventBreakpoints:false, observeAsmJS:true}, _gripDepth:0, _parentClosed:false, _observingNetwork:false, _frameActors:[], _xhrBreakpoints:[], _dbg:{addDebuggees:(function() {
    for (const global of findDebuggees(this)) {
      safeAddDebuggee(this, global);
    }
  }), disable:(function() {
    dbg.removeAllDebuggees();
    dbg.onNewGlobalObject = undefined;
  }), enable:(function() {
    dbg.addDebuggees();
    dbg.onNewGlobalObject = onNewGlobalObject;
  }), onNewDebuggee:function bound _onNewDebuggee() {
    [native code]
}}, _threadLifetimePool:null, _activeEventPause:null, _pauseOverlay:null, _priorPause:null, _activeEventBreakpoints:{}, _frameActorMap:{}, _debuggerSourcesSeen:{}, _onLoadBreakpointURLs:{}, _handledFrameExceptions:{}, _watchpointsMap:{threadActor:{}, _watchpoints:{}}, breakpointActorMap:{_threadActor:{}, _actors:{}}, _nestedEventLoop:{_thread:{}, _entered:false, _resolved:false}, onNewSourceEvent:function bound onNewSourceEvent() {
    [native code]
}, createCompletionGrip:function bound createCompletionGrip() {
    [native code]
}, onDebuggerStatement:function bound onDebuggerStatement() {
    [native code]
}, onNewScript:function bound onNewScript() {
    [native code]
}, objectGrip:function bound objectGrip() {
    [native code]
}, pauseObjectGrip:function bound pauseObjectGrip() {
    [native code]
}, _onOpeningRequest:function bound _onOpeningRequest() {
    [native code]
}, _onNewDebuggee:function bound _onNewDebuggee() {
    [native code]
}, _onExceptionUnwind:function bound _onExceptionUnwind() {
    [native code]
}, _eventBreakpointListener:function bound _eventBreakpointListener() {
    [native code]
}, _onWindowReady:function bound _onWindowReady() {
    [native code]
}, _onWillNavigate:function bound _onWillNavigate() {
    [native code]
}, _onNavigate:function bound _onNavigate() {
    [native code]
}, _firstStatementBreakpoint:null, _debuggerNotificationObserver:{}, parentPool:{}, alreadyAttached:true, wrappedJSObject:{}, _shouldEmitNewSource:false, _pendingResponse:{}, [Symbol("EventEmitter/listeners")]:{}}, __poolMap:{}, _progressListener:{_targetActor:{}, _onWindowCreated:function bound () {
    [native code]
}, _onWindowHidden:function bound () {
    [native code]
}, _knownWindowIDs:{}, _watchedDocShells:{}}, _docShellsObserved:true, parentPool:{}, createdFromJsWindowActor:true, _targetScopedActorPool:{conn:{_prefix:"server0.conn1.windowGlobal4294967313/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn1.windowGlobal4294967313", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, _dbg:{addDebuggees:(function() {
    for (const global of findDebuggees(this)) {
      safeAddDebuggee(this, global);
    }
  }), disable:(function() {
    dbg.removeAllDebuggees();
    dbg.onNewGlobalObject = undefined;
  }), enable:(function() {
    dbg.addDebuggees();
    dbg.onNewGlobalObject = onNewGlobalObject;
  }), onNewDebuggee:function bound _onNewDebuggee() {
    [native code]
}}, _styleSheetManager:{_styleSheetCount:0, _styleSheetMap:{}, _mqlList:[], _targetActor:{}, _onApplicableStateChanged:function bound _onApplicableStateChanged() {
    [native code]
}, _onTargetActorWindowReady:function bound _onTargetActorWindowReady() {
    [native code]
}, [Symbol("EventEmitter/listeners")]:{}}, [Symbol("EventEmitter/listeners")]:{}}) ": " (new TypeError("this._targetActor.chromeEventHandler is null", "resource://devtools/server/actors/utils/stylesheets-manager.js", 868))
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 1710: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
console.error: "Error while calling actor 'pagestyle's method 'getLayout'" "node is null"
console.error: (new TypeError("node is null", "resource://devtools/server/actors/page-style.js", 1001))
console.error: (new Error("Protocol error (TypeError): node is null from: server0.conn1.windowGlobal4294967299/pagestyle24 (resource://devtools/server/actors/page-style.js:1001:5)", "resource://devtools/shared/protocol/Front.js", 365))
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/connectors/js-window-actor/DevToolsFrameChild.jsm, line 402: InvalidStateError: JSWindowActorChild.sendAsyncMessage: JSWindowActorChild cannot send at the moment
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 420: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
console.error: (new TypeError("container.node.targetFront is null", "resource://devtools/client/inspector/markup/markup.js", 2320))
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/1650361002834	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "52701" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofile93xkGW"
1650361003440	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofile93xkGW\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:52701/devtools/browser/3a66cdbf-d704-431d-acbb-c96f8a6488e9
1650361006082	Marionette	INFO	Listening on port 52706
1650361006602	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
JavaScript error: resource://gre/modules/LoginManagerParent.jsm, line 136: TypeError: gRecipeManager is null
JavaScript warning: https://gen-bizbd.com/web/content/53594-92c9dad/web.assets_backend.js, line 5051: unreachable code after return statement
SourceActor threw an exception: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:556:16
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 556, column: 16
console.error: (new Error("Failed to fetch https://gen-bizbd.com/web. Code 2152924148.", "resource://devtools/shared/DevToolsUtils.js", 556))
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 556: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
SourceActor threw an exception: [Exception... "Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]"  nsresult: "0x80470002 (NS_BASE_STREAM_CLOSED)"  location: "JS frame :: resource://devtools/shared/DevToolsUtils.js :: onResponse :: line 567"  data: no]
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:567:34
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 567, column: 0
console.error: ({})
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 567: NS_BASE_STREAM_CLOSED: Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]
console.error: (new TypeError("container.node.targetFront is null", "resource://devtools/client/inspector/markup/markup.js", 2320))
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, 1650361305757	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "55823" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileL4aeX0"
1650361306334	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileL4aeX0\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:55823/devtools/browser/a20b33bc-c03e-48fe-875f-3e1f603813b6
1650361309547	Marionette	INFO	Listening on port 55828
1650361310015	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
JavaScript error: resource://gre/modules/LoginManagerParent.jsm, line 136: TypeError: gRecipeManager is null
JavaScript warning: https://gen-bizbd.com/web/content/53594-92c9dad/web.assets_backend.js, line 5051: unreachable code after return statement
SourceActor threw an exception: [Exception... "Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]"  nsresult: "0x80470002 (NS_BASE_STREAM_CLOSED)"  location: "JS frame :: resource://devtools/shared/DevToolsUtils.js :: onResponse :: line 567"  data: no]
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:567:34
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 567, column: 0
console.error: ({})
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 567: NS_BASE_STREAM_CLOSED: Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]
SourceActor threw an exception: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:556:16
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 556, column: 16
console.error: (new Error("Failed to fetch https://gen-bizbd.com/web. Code 2152924148.", "resource://devtools/shared/DevToolsUtils.js", 556))
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 556: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
JavaScript error: , line 0: NotFoundError: No such JSWindowActor 'DevToolsFrame'
SourceActor threw an exception: [Exception... "Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]"  nsresult: "0x80470002 (NS_BASE_STREAM_CLOSED)"  location: "JS frame :: resource://devtools/shared/DevToolsUtils.js :: onResponse :: line 567"  data: no]
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:567:34
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 567, column: 0
console.error: ({})
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 567: NS_BASE_STREAM_CLOSED: Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]
SourceActor threw an exception: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:556:16
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 556, column: 16
console.error: (new Error("Failed to fetch https://gen-bizbd.com/web. Code 2152924148.", "resource://devtools/shared/DevToolsUtils.js", 556))
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 556: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
console.error: (new TypeError("parent is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: parent is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

JavaScript error: resource://devtools/server/actors/page-style.js, line 570: TypeError: node is null
console.error: "Error while calling actor 'pagestyle's method 'getApplied'" "node is null"
console.error: (new TypeError("node is null", "resource://devtools/server/actors/page-style.js", 570))
console.error: (new Error("Protocol error (TypeError): node is null from: server0.conn1.windowGlobal4294967299/pagestyle24 (resource://devtools/server/actors/page-style.js:570:5)", "resource://devtools/shared/protocol/Front.js", 365))
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, 1650361563904	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "53105" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofilesGMmFe"
1650361564505	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofilesGMmFe\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:53105/devtools/browser/c8856f25-ee58-45cb-af82-edaa57cc6328
1650361567743	Marionette	INFO	Listening on port 53113
1650361568148	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
JavaScript error: resource://gre/modules/LoginManagerParent.jsm, line 136: TypeError: gRecipeManager is null
JavaScript warning: https://gen-bizbd.com/web/content/53594-92c9dad/web.assets_backend.js, line 5051: unreachable code after return statement
SourceActor threw an exception: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:556:16
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 556, column: 16
console.error: (new Error("Failed to fetch https://gen-bizbd.com/web. Code 2152924148.", "resource://devtools/shared/DevToolsUtils.js", 556))
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 556: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
SourceActor threw an exception: [Exception... "Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]"  nsresult: "0x80470002 (NS_BASE_STREAM_CLOSED)"  location: "JS frame :: resource://devtools/shared/DevToolsUtils.js :: onResponse :: line 567"  data: no]
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:567:34
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 567, column: 0
console.error: ({})
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 567: NS_BASE_STREAM_CLOSED: Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, 1650361680352	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "52765" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofile4OOOlX"
1650361680987	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofile4OOOlX\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:52765/devtools/browser/b2bfc836-2d4c-47f6-857d-13a03dc50698
1650361684268	Marionette	INFO	Listening on port 52770
1650361684604	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
JavaScript error: resource://gre/modules/LoginManagerParent.jsm, line 136: TypeError: gRecipeManager is null
JavaScript warning: https://gen-bizbd.com/web/content/53594-92c9dad/web.assets_backend.js, line 5051: unreachable code after return statement
1650361772051	Marionette	INFO	Stopped listening on port 52771650361772855	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "52829" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofile5DusBT"
1650361773400	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofile5DusBT\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:52829/devtools/browser/da31bf78-f8bf-4d90-8be4-2cfe479905ba
1650361776156	Marionette	INFO	Listening on port 52834
1650361776579	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
JavaScript error: resource://gre/modules/LoginManagerParent.jsm, line 136: TypeError: gRecipeManager is null
JavaScript warning: https://gen-bizbd.com/web/content/53594-92c9dad/web.assets_backend.js, line 5051: unreachable code after return statement
SourceActor threw an exception: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:556:16
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 556, column: 16
console.error: (new Error("Failed to fetch https://gen-bizbd.com/web. Code 2152924148.", "resource://devtools/shared/DevToolsUtils.js", 556))
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 556: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
SourceActor threw an exception: [Exception... "Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]"  nsresult: "0x80470002 (NS_BASE_STREAM_CLOSED)"  location: "JS frame :: resource://devtools/shared/DevToolsUtils.js :: onResponse :: line 567"  data: no]
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:567:34
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 567, column: 0
console.error: ({})
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 567: NS_BASE_STREAM_CLOSED: Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, 1650361853597	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "52892" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileZRpQup"
1650361854150	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileZRpQup\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:52892/devtools/browser/72fa313e-7273-44b9-b714-161eff84e232
1650361856652	Marionette	INFO	Listening on port 52897
1650361856843	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
JavaScript error: resource://gre/modules/LoginManagerParent.jsm, line 136: TypeError: gRecipeManager is null
JavaScript warning: https://gen-bizbd.com/web/content/53594-92c9dad/web.assets_backend.js, line 5051: unreachable code after return statement
SourceActor threw an exception: [Exception... "Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]"  nsresult: "0x80470002 (NS_BASE_STREAM_CLOSED)"  location: "JS frame :: resource://devtools/shared/DevToolsUtils.js :: onResponse :: line 567"  data: no]
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:567:34
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 567, column: 0
console.error: ({})
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 567: NS_BASE_STREAM_CLOSED: Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]
SourceActor threw an exception: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:556:16
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 556, column: 16
console.error: (new Error("Failed to fetch https://gen-bizbd.com/web. Code 2152924148.", "resource://devtools/shared/DevToolsUtils.js", 556))
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 556: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, 1650361939480	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "60372" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileK3YFom"
1650361940053	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileK3YFom\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:60372/devtools/browser/17e72480-fa2c-4469-9a46-0b96118141d2
1650361942609	Marionette	INFO	Listening on port 60377
1650361942717	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
JavaScript error: resource://gre/modules/LoginManagerParent.jsm, line 136: TypeError: gRecipeManager is null
JavaScript warning: https://gen-bizbd.com/web/content/53594-92c9dad/web.assets_backend.js, line 5051: unreachable code after return statement
SourceActor threw an exception: [Exception... "Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]"  nsresult: "0x80470002 (NS_BASE_STREAM_CLOSED)"  location: "JS frame :: resource://devtools/shared/DevToolsUtils.js :: onResponse :: line 567"  data: no]
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:567:34
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 567, column: 0
console.error: ({})
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 567: NS_BASE_STREAM_CLOSED: Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]
SourceActor threw an exception: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:556:16
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 556, column: 16
console.error: (new Error("Failed to fetch https://gen-bizbd.com/web. Code 2152924148.", "resource://devtools/shared/DevToolsUtils.js", 556))
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 556: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
JavaScript error: , line 0: NS_ERROR_NOT_AVAILABLE
console.error: (new TypeError("currentNode is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 66))
TypeError: currentNode is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:66:20
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 575: NotFoundError: No such JSWindowActor 'DevToolsFrame'
1650370394441	Marionette	INFO	Stopped listening on port 60377
console.warn: TopSitesFeed: Failed to fetch data from Contile server: NetworkError when attempting to fetch resource.
1650434087694	geckodriver	INFO	Listening on 127.0.0.1:60612
1650434090780	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "60613" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileu9xFQh"
1650434092109	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileu9xFQh\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:60613/devtools/browser/4a12e16b-d6ad-43a7-8649-dbcf2d82d5b4
1650434095480	Marionette	INFO	Listening on port 60618
1650434095685	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
JavaScript error: resource://gre/modules/LoginManagerParent.jsm, line 136: TypeError: gRecipeManager is null
JavaScript warning: https://gen-bizbd.com/web/content/53594-92c9dad/web.assets_backend.js, line 5051: unreachable code after return statement
SourceActor threw an exception: [Exception... "Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]"  nsresult: "0x80470002 (NS_BASE_STREAM_CLOSED)"  location: "JS frame :: resource://devtools/shared/DevToolsUtils.js :: onResponse :: line 567"  data: no]
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:567:34
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 567, column: 0
console.error: ({})
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 567: NS_BASE_STREAM_CLOSED: Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]
SourceActor threw an exception: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:556:16
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 556, column: 16
console.error: (new Error("Failed to fetch https://gen-bizbd.com/web. Code 2152924148.", "resource://devtools/shared/DevToolsUtils.js", 556))
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 556: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
console.warn: "Error while destroying front:" "inspector" (new Error("Connection closed, pending request to server0.conn0.windowGlobal4294967335/inspectorActor4, type getWalker failed\n\nRequest stack:\nrequest@resource://devtools/shared/protocol/Front.js:292:14\ngenerateRequestMethods/</frontProto[name]@resource://devtools/shared/protocol/Front/FrontClassWithSpec.js:46:19\n_getWalker@resource://devtools/client/fronts/inspector.js:90:30\ninitialize@resource://devtools/client/fronts/inspector.js:79:12\n", "resource://devtools/shared/protocol/Front.js", 106))
console.error: "Failed to start [root-node] legacy listener for target null" (new Error("Connection closed, pending request to server0.conn0.windowGlobal4294967335/inspectorActor4, type getWalker failed\n\nRequest stack:\nrequest@resource://devtools/shared/protocol/Front.js:292:14\ngenerateRequestMethods/</frontProto[name]@resource://devtools/shared/protocol/Front/FrontClassWithSpec.js:46:19\n_getWalker@resource://devtools/client/fronts/inspector.js:90:30\ninitialize@resource://devtools/client/fronts/inspector.js:79:12\n", "resource://devtools/shared/protocol/Front.js", 106))
JavaScript error: resource://devtools/shared/protocol/Front.js, line 106: Error: Connection closed, pending request to server0.conn0.windowGlobal4294967335/inspectorActor4, type getWalker failed

Request stack:
request@resource://devtools/shared/protocol/Front.js:292:14
generateRequestMethods/</frontProto[name]@resource://devtools/shared/protocol/Front/FrontClassWithSpec.js:46:19
_getWalker@resource://devtools/client/fronts/inspector.js:90:30
initialize@resource://devtools/client/fronts/inspector.js:79:12

JavaScript error: resource://gre/modules/AsyncShutdown.jsm, 1650434272526	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "52248" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileETSFV5"
1650434273073	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileETSFV5\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:52248/devtools/browser/77b8c7c4-b0a2-43b3-a08a-0b268d4f3c35
1650434275559	Marionette	INFO	Listening on port 52253
1650434275762	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
JavaScript error: resource://gre/modules/LoginManagerParent.jsm, line 136: TypeError: gRecipeManager is null
JavaScript warning: https://gen-bizbd.com/web/content/53594-92c9dad/web.assets_backend.js, line 5051: unreachable code after return statement
SourceActor threw an exception: [Exception... "Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]"  nsresult: "0x80470002 (NS_BASE_STREAM_CLOSED)"  location: "JS frame :: resource://devtools/shared/DevToolsUtils.js :: onResponse :: line 567"  data: no]
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:567:34
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 567, column: 0
console.error: ({})
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 567: NS_BASE_STREAM_CLOSED: Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]
SourceActor threw an exception: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:556:16
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 556, column: 16
console.error: (new Error("Failed to fetch https://gen-bizbd.com/web. Code 2152924148.", "resource://devtools/shared/DevToolsUtils.js", 556))
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 556: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
console.error: (new TypeError("container.node.targetFront is null", "resource://devtools/client/inspector/markup/markup.js", 2320))
console.error: (new TypeError("parent is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: parent is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

console.error: "Error while calling actor 'pagestyle's method 'getLayout'" "node is null"
console.error: (new TypeError("node is null", "resource://devtools/server/actors/page-style.js", 1001))
console.error: (new Error("Protocol error (TypeError): node is null from: server0.conn0.windowGlobal4294967299/pagestyle25 (resource://devtools/server/actors/page-style.js:1001:5)", "resource://devtools/shared/protocol/Front.js", 365))
JavaScript error: resource://devtools/server/actors/page-style.js, line 570: TypeError: node is null
console.error: "Error while calling actor 'pagestyle's method 'getApplied'" "node is null"
console.error: (new TypeError("node is null", "resource://devtools/server/actors/page-style.js", 570))
console.error: (new Error("Protocol error (TypeError): node is null from: server0.conn0.windowGlobal4294967299/pagestyle25 (resource://devtools/server/actors/page-style.js:570:5)", "resource://devtools/shared/protocol/Front.js", 365))
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, 1650434766621	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "56023" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileJhfRoe"
1650434767270	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileJhfRoe\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:56023/devtools/browser/5d1ccb8b-f82f-4b1f-8d9b-91a75b363c95
1650434770254	Marionette	INFO	Listening on port 56028
1650434770332	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
JavaScript error: resource://gre/modules/LoginManagerParent.jsm, line 136: TypeError: gRecipeManager is null
JavaScript warning: https://gen-bizbd.com/web/content/53594-92c9dad/web.assets_backend.js, line 5051: unreachable code after return statement
1650435043316	Marionette	INFO	Stopped listening on port 56021650435045806	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "52753" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileAPiXNd"
1650435046440	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileAPiXNd\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:52753/devtools/browser/84ebd182-e422-43d8-9b3c-5c6a4e20a91c
1650435050964	Marionette	INFO	Listening on port 52761
1650435051201	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
1650435051775	Marionette	INFO	Stopped listening on port 52761
console.error: services.settings: 
  main/query-stripping Signature failed  TypeError: NetworkError: Network request failed
console.warn: TopSitesFeed: Failed to fetch data from Contile server: NetworkError when attempting to fetch resource.
JavaScript error: chrome://remote/content/marionette/cert.js, line 55: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsICertOverrideService.setDisableAllSecurityChecksAndLetAttackersInterceptMyData]
1650435065930	geckodriver	INFO	Listening on 127.0.0.1:52792
1650435068998	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "52793" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileHMt9Ae"
1650435069636	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileHMt9Ae\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:52793/devtools/browser/8e2009a9-41c2-49c6-82d8-720070eecbf1
1650435072901	Marionette	INFO	Listening on port 52798
1650435073256	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
JavaScript error: resource://gre/modules/LoginManagerParent.jsm, line 136: TypeError: gRecipeManager is null
JavaScript warning: https://gen-bizbd.com/web/content/53594-92c9dad/web.assets_backend.js, line 5051: unreachable code after return statement
SourceActor threw an exception: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:556:16
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 556, column: 16
console.error: (new Error("Failed to fetch https://gen-bizbd.com/web. Code 2152924148.", "resource://devtools/shared/DevToolsUtils.js", 556))
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 556: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
SourceActor threw an exception: [Exception... "Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]"  nsresult: "0x80470002 (NS_BASE_STREAM_CLOSED)"  location: "JS frame :: resource://devtools/shared/DevToolsUtils.js :: onResponse :: line 567"  data: no]
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:567:34
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 567, column: 0
console.error: ({})
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 567: NS_BASE_STREAM_CLOSED: Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]
console.error: (new TypeError("parent is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: parent is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

JavaScript error: resource://devtools/server/actors/page-style.js, line 570: TypeError: node is null
console.error: "Error while calling actor 'pagestyle's method 'getApplied'" "node is null"
console.error: (new TypeError("node is null", "resource://devtools/server/actors/page-style.js", 570))
console.error: (new Error("Protocol error (TypeError): node is null from: server0.conn0.windowGlobal4294967299/pagestyle24 (resource://devtools/server/actors/page-style.js:570:5)", "resource://devtools/shared/protocol/Front.js", 365))
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, 1650435214047	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "52368" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofilekBSgsc"
1650435214649	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofilekBSgsc\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:52368/devtools/browser/b5e9e1e3-628d-4c1e-b057-2924ad629e75
1650435217257	Marionette	INFO	Listening on port 52373
1650435217751	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
JavaScript error: resource://gre/modules/LoginManagerParent.jsm, line 136: TypeError: gRecipeManager is null
JavaScript warning: https://gen-bizbd.com/web/content/53594-92c9dad/web.assets_backend.js, line 5051: unreachable code after return statement
SourceActor threw an exception: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:556:16
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 556, column: 16
console.error: (new Error("Failed to fetch https://gen-bizbd.com/web. Code 2152924148.", "resource://devtools/shared/DevToolsUtils.js", 556))
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 556: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
SourceActor threw an exception: [Exception... "Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]"  nsresult: "0x80470002 (NS_BASE_STREAM_CLOSED)"  location: "JS frame :: resource://devtools/shared/DevToolsUtils.js :: onResponse :: line 567"  data: no]
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:567:34
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 567, column: 0
console.error: ({})
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 567: NS_BASE_STREAM_CLOSED: Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]
console.error: (new TypeError("parent is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: parent is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

console.error: (new TypeError("container.node.targetFront is null", "resource://devtools/client/inspector/markup/markup.js", 2320))
console.warn: "Failed to add session data entry for frame targets in browsing context" 4294967306
console.warn: (new AbortError("Actor 'DevToolsFrame' destroyed before query 'DevToolsFrameParent:addSessionDataEntry' was resolved", (void 0)))
console.error: "Error when attaching target:" (new Error("Connection closed, pending request to server0.conn0.windowGlobal4294967319/thread1, type isAttached failed\n\nRequest stack:\nrequest@resource://devtools/shared/protocol/Front.js:292:14\ngenerateRequestMethods/</frontProto[name]@resource://devtools/shared/protocol/Front/FrontClassWithSpec.js:46:19\nattachThread@resource://devtools/client/fronts/targets/target-mixin.js:573:49\n", "resource://devtools/shared/protocol/Front.js", 106))
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
console.error: "Error while calling actor 'pagestyle's method 'getLayout'" "node is null"
console.error: (new TypeError("node is null", "resource://devtools/server/actors/page-style.js", 1001))
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
Handler function threw an exception: [Exception... "Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]"  nsresult: "0x80040111 (NS_ERROR_NOT_AVAILABLE)"  location: "JS frame :: resource://devtools/server/actors/targets/window-global.js :: watch :: line 1662"  data: no]
Stack: watch@resource://devtools/server/actors/targets/window-global.js:1662:28
_watchDocshells@resource://devtools/server/actors/targets/window-global.js:773:28
initialize/<@resource://devtools/server/actors/targets/window-global.js:346:42
exports.makeInfallible/<@resource://devtools/shared/ThreadSafeDevToolsUtils.js:103:22
Line: 1662, column: 0
console.error: ({})
console.error: "Error while calling actor 'thread's method 'isAttached'" "JSWindowActorChild.sendAsyncMessage: JSWindowActorChild cannot send at the moment"
console.error: (new InvalidStateError("JSWindowActorChild.sendAsyncMessage: JSWindowActorChild cannot send at the moment", (void 0), 402))
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
console.error: (new Error("Protocol error (TypeError): node is null from: server0.conn0.windowGlobal4294967299/pagestyle26 (resource://devtools/server/actors/page-style.js:1001:5)", "resource://devtools/shared/protocol/Front.js", 365))
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
console.error: "Error when destroying StyleSheet manager for" ({notifyResourceAvailable:function bound notifyResourceAvailable() {
    [native code]
}, notifyResourceDestroyed:function bound notifyResourceDestroyed() {
    [native code]
}, notifyResourceUpdated:function bound notifyResourceUpdated() {
    [native code]
}, conn:{_prefix:"server0.conn0.windowGlobal4294967319/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967319", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {conn:{}, __poolMap:{}}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, actorID:"server0.conn0.windowGlobal4294967319/windowGlobalTarget2", _actorSpec:{typeName:"windowGlobalTarget", methods:[{name:"detach", request:{type:"detach", template:{type:"detach"}, args:[]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"ensureCSSErrorReportingEnabled", request:{type:"ensureCSSErrorReportingEnabled", template:{type:"ensureCSSErrorReportingEnabled"}, args:[]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"focus", request:{type:"focus", template:{type:"focus"}, args:[]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"goForward", request:{type:"goForward", template:{type:"goForward"}, args:[]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"goBack", request:{type:"goBack", template:{type:"goBack"}, args:[]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"reload", request:{type:"reload", template:{type:"reload", options:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["options"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"navigateTo", request:{type:"navigateTo", template:{type:"navigateTo", url:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["url"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"reconfigure", request:{type:"reconfigure", template:{type:"reconfigure", options:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["options"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"switchToFrame", request:{type:"switchToFrame", template:{type:"switchToFrame", windowId:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["windowId"]}]}, response:{template:{_type:"windowGlobalTarget.switchtoframe", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, retVal:{_type:"windowGlobalTarget.switchtoframe", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:[]}, release:(void 0), oneway:(void 0)}, {name:"listFrames", request:{type:"listFrames", template:{type:"listFrames"}, args:[]}, response:{template:{_type:"windowGlobalTarget.listframes", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, retVal:{_type:"windowGlobalTarget.listframes", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:[]}, release:(void 0), oneway:(void 0)}, {name:"listWorkers", request:{type:"listWorkers", template:{type:"listWorkers"}, args:[]}, response:{template:{_type:"windowGlobalTarget.workers", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, retVal:{_type:"windowGlobalTarget.workers", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:[]}, release:(void 0), oneway:(void 0)}, {name:"logInPage", request:{type:"logInPage", template:{type:"logInPage", text:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, category:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, flags:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["text"]}, {placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["category"]}, {placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["flags"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}], events:{}}, docShell:({}), _originalWindow:{get window() {
    [native code]
}, get document() {
    [native code]
}, get location() {
    [native code]
}, set location() {
    [native code]
}, get top() {
    [native code]
}, close:function close() {
    [native code]
}, stop:function stop() {
    [native code]
}, focus:function focus() {
    [native code]
}, blur:function blur() {
    [native code]
}, open:function open() {
    [native code]
}, alert:function alert() {
    [native code]
}, confirm:function confirm() {
    [native code]
}, prompt:function prompt() {
    [native code]
}, print:function print() {
    [native code]
}, printPreview:function printPreview() {
    [native code]
}, postMessage:function postMessage() {
    [native code]
}, captureEvents:function captureEvents() {
    [native code]
}, releaseEvents:function releaseEvents() {
    [native code]
}, getSelection:function getSelection() {
    [native code]
}, getComputedStyle:function getComputedStyle() {
    [native code]
}, matchMedia:function matchMedia() {
    [native code]
}, moveTo:function moveTo() {
    [native code]
}, moveBy:function moveBy() {
    [native code]
}, resizeTo:function resizeTo() {
    [native code]
}, resizeBy:function resizeBy() {
    [native code]
}, scroll:function scroll() {
    [native code]
}, scrollTo:function scrollTo() {
    [native code]
}, scrollBy:function scrollBy() {
    [native code]
}, getDefaultComputedStyle:function getDefaultComputedStyle() {
    [native code]
}, scrollByLines:function scrollByLines() {
    [native code]
}, scrollByPages:function scrollByPages() {
    [native code]
}, sizeToContent:function sizeToContent() {
    [native code]
}, updateCommands:function updateCommands() {
    [native code]
}, find:function find() {
    [native code]
}, dump:function dump() {
    [native code]
}, setResizable:function setResizable() {
    [native code]
}, requestIdleCallback:function requestIdleCallback() {
    [native code]
}, cancelIdleCallback:function cancelIdleCallback() {
    [native code]
}, getRegionalPrefsLocales:function getRegionalPrefsLocales() {
    [native code]
}, getWebExposedLocales:function getWebExposedLocales() {
    [native code]
}, requestAnimationFrame:function requestAnimationFrame() {
    [native code]
}, cancelAnimationFrame:function cancelAnimationFrame() {
    [native code]
}, reportError:function reportError() {
    [native code]
}, btoa:function btoa() {
    [native code]
}, atob:function atob() {
    [native code]
}, setTimeout:function setTimeout() {
    [native code]
}, clearTimeout:function clearTimeout() {
    [native code]
}, setInterval:function setInterval() {
    [native code]
}, clearInterval:function clearInterval() {
    [native code]
}, queueMicrotask:function queueMicrotask() {
    [native code]
}, createImageBitmap:function createImageBitmap() {
    [native code]
}, structuredClone:function structuredClone() {
    [native code]
}, fetch:function fetch() {
    [native code]
}, get self() {
    [native code]
}, set self() {
    [native code]
}, get name() {
    [native code]
}, set name() {
    [native code]
}, get history() {
    [native code]
}, get customElements() {
    [native code]
}, get locationbar() {
    [native code]
}, set locationbar() {
    [native code]
}, get menubar() {
    [native code]
}, set menubar() {
    [native code]
}, get personalbar() {
    [native code]
}, set personalbar() {
    [native code]
}, get scrollbars() {
    [native code]
}, set scrollbars() {
    [native code]
}, get statusbar() {
    [native code]
}, set statusbar() {
    [native code]
}, get toolbar() {
    [native code]
}, set toolbar() {
    [native code]
}, get status() {
    [native code]
}, set status() {
    [native code]
}, get closed() {
    [native code]
}, get event() {
    [native code]
}, set event() {
    [native code]
}, get frames() {
    [native code]
}, set frames() {
    [native code]
}, get length() {
    [native code]
}, set length() {
    [native code]
}, get opener() {
    [native code]
}, set opener() {
    [native code]
}, get parent() {
    [native code]
}, set parent() {
    [native code]
}, get frameElement() {
    [native code]
}, get navigator() {
    [native code]
}, get clientInformation() {
    [native code]
}, get external() {
    [native code]
}, set external() {
    [native code]
}, get screen() {
    [native code]
}, set screen() {
    [native code]
}, get innerWidth() {
    [native code]
}, set innerWidth() {
    [native code]
}, get innerHeight() {
    [native code]
}, set innerHeight() {
    [native code]
}, get scrollX() {
    [native code]
}, set scrollX() {
    [native code]
}, get pageXOffset() {
    [native code]
}, set pageXOffset() {
    [native code]
}, get scrollY() {
    [native code]
}, set scrollY() {
    [native code]
}, get pageYOffset() {
    [native code]
}, set pageYOffset() {
    [native code]
}, get screenLeft() {
    [native code]
}, set screenLeft() {
    [native code]
}, get screenTop() {
    [native code]
}, set screenTop() {
    [native code]
}, get screenX() {
    [native code]
}, set screenX() {
    [native code]
}, get screenY() {
    [native code]
}, set screenY() {
    [native code]
}, get outerWidth() {
    [native code]
}, set outerWidth() {
    [native code]
}, get outerHeight() {
    [native code]
}, set outerHeight() {
    [native code]
}, get performance() {
    [native code]
}, set performance() {
    [native code]
}, get mozInnerScreenX() {
    [native code]
}, get mozInnerScreenY() {
    [native code]
}, get devicePixelRatio() {
    [native code]
}, set devicePixelRatio() {
    [native code]
}, get scrollMaxX() {
    [native code]
}, set scrollMaxX() {
    [native code]
}, get scrollMaxY() {
    [native code]
}, set scrollMaxY() {
    [native code]
}, get fullScreen() {
    [native code]
}, set fullScreen() {
    [native code]
}, get ondevicemotion() {
    [native code]
}, set ondevicemotion() {
    [native code]
}, get ondeviceorientation() {
    [native code]
}, set ondeviceorientation() {
    [native code]
}, get onabsolutedeviceorientation() {
    [native code]
}, set onabsolutedeviceorientation() {
    [native code]
}, get InstallTrigger() {
    [native code]
}, set InstallTrigger() {
    [native code]
}, get intlUtils() {
    [native code]
}, get visualViewport() {
    [native code]
}, set visualViewport() {
    [native code]
}, get crypto() {
    [native code]
}, get onabort() {
    [native code]
}, set onabort() {
    [native code]
}, get onblur() {
    [native code]
}, set onblur() {
    [native code]
}, get onfocus() {
    [native code]
}, set onfocus() {
    [native code]
}, get onauxclick() {
    [native code]
}, set onauxclick() {
    [native code]
}, get onbeforeinput() {
    [native code]
}, set onbeforeinput() {
    [native code]
}, get oncanplay() {
    [native code]
}, set oncanplay() {
    [native code]
}, get oncanplaythrough() {
    [native code]
}, set oncanplaythrough() {
    [native code]
}, get onchange() {
    [native code]
}, set onchange() {
    [native code]
}, get onclick() {
    [native code]
}, set onclick() {
    [native code]
}, get onclose() {
    [native code]
}, set onclose() {
    [native code]
}, get oncontextmenu() {
    [native code]
}, set oncontextmenu() {
    [native code]
}, get oncuechange() {
    [native code]
}, set oncuechange() {
    [native code]
}, get ondblclick() {
    [native code]
}, set ondblclick() {
    [native code]
}, get ondrag() {
    [native code]
}, set ondrag() {
    [native code]
}, get ondragend() {
    [native code]
}, set ondragend() {
    [native code]
}, get ondragenter() {
    [native code]
}, set ondragenter() {
    [native code]
}, get ondragexit() {
    [native code]
}, set ondragexit() {
    [native code]
}, get ondragleave() {
    [native code]
}, set ondragleave() {
    [native code]
}, get ondragover() {
    [native code]
}, set ondragover() {
    [native code]
}, get ondragstart() {
    [native code]
}, set ondragstart() {
    [native code]
}, get ondrop() {
    [native code]
}, set ondrop() {
    [native code]
}, get ondurationchange() {
    [native code]
}, set ondurationchange() {
    [native code]
}, get onemptied() {
    [native code]
}, set onemptied() {
    [native code]
}, get onended() {
    [native code]
}, set onended() {
    [native code]
}, get onformdata() {
    [native code]
}, set onformdata() {
    [native code]
}, get oninput() {
    [native code]
}, set oninput() {
    [native code]
}, get oninvalid() {
    [native code]
}, set oninvalid() {
    [native code]
}, get onkeydown() {
    [native code]
}, set onkeydown() {
    [native code]
}, get onkeypress() {
    [native code]
}, set onkeypress() {
    [native code]
}, get onkeyup() {
    [native code]
}, set onkeyup() {
    [native code]
}, get onload() {
    [native code]
}, set onload() {
    [native code]
}, get onloadeddata() {
    [native code]
}, set onloadeddata() {
    [native code]
}, get onloadedmetadata() {
    [native code]
}, set onloadedmetadata() {
    [native code]
}, get onloadend() {
    [native code]
}, set onloadend() {
    [native code]
}, get onloadstart() {
    [native code]
}, set onloadstart() {
    [native code]
}, get onmousedown() {
    [native code]
}, set onmousedown() {
    [native code]
}, get onmouseenter() {
    [native code]
}, set onmouseenter() {
    [native code]
}, get onmouseleave() {
    [native code]
}, set onmouseleave() {
    [native code]
}, get onmousemove() {
    [native code]
}, set onmousemove() {
    [native code]
}, get onmouseout() {
    [native code]
}, set onmouseout() {
    [native code]
}, get onmouseover() {
    [native code]
}, set onmouseover() {
    [native code]
}, get onmouseup() {
    [native code]
}, set onmouseup() {
    [native code]
}, get onwheel() {
    [native code]
}, set onwheel() {
    [native code]
}, get onpause() {
    [native code]
}, set onpause() {
    [native code]
}, get onplay() {
    [native code]
}, set onplay() {
    [native code]
}, get onplaying() {
    [native code]
}, set onplaying() {
    [native code]
}, get onprogress() {
    [native code]
}, set onprogress() {
    [native code]
}, get onratechange() {
    [native code]
}, set onratechange() {
    [native code]
}, get onreset() {
    [native code]
}, set onreset() {
    [native code]
}, get onresize() {
    [native code]
}, set onresize() {
    [native code]
}, get onscroll() {
    [native code]
}, set onscroll() {
    [native code]
}, get onsecuritypolicyviolation() {
    [native code]
}, set onsecuritypolicyviolation() {
    [native code]
}, get onseeked() {
    [native code]
}, set onseeked() {
    [native code]
}, get onseeking() {
    [native code]
}, set onseeking() {
    [native code]
}, get onselect() {
    [native code]
}, set onselect() {
    [native code]
}, get onslotchange() {
    [native code]
}, set onslotchange() {
    [native code]
}, get onstalled() {
    [native code]
}, set onstalled() {
    [native code]
}, get onsubmit() {
    [native code]
}, set onsubmit() {
    [native code]
}, get onsuspend() {
    [native code]
}, set onsuspend() {
    [native code]
}, get ontimeupdate() {
    [native code]
}, set ontimeupdate() {
    [native code]
}, get onvolumechange() {
    [native code]
}, set onvolumechange() {
    [native code]
}, get onwaiting() {
    [native code]
}, set onwaiting() {
    [native code]
}, get onselectstart() {
    [native code]
}, set onselectstart() {
    [native code]
}, get onselectionchange() {
    [native code]
}, set onselectionchange() {
    [native code]
}, get ontoggle() {
    [native code]
}, set ontoggle() {
    [native code]
}, get onpointercancel() {
    [native code]
}, set onpointercancel() {
    [native code]
}, get onpointerdown() {
    [native code]
}, set onpointerdown() {
    [native code]
}, get onpointerup() {
    [native code]
}, set onpointerup() {
    [native code]
}, get onpointermove() {
    [native code]
}, set onpointermove() {
    [native code]
}, get onpointerout() {
    [native code]
}, set onpointerout() {
    [native code]
}, get onpointerover() {
    [native code]
}, set onpointerover() {
    [native code]
}, get onpointerenter() {
    [native code]
}, set onpointerenter() {
    [native code]
}, get onpointerleave() {
    [native code]
}, set onpointerleave() {
    [native code]
}, get ongotpointercapture() {
    [native code]
}, set ongotpointercapture() {
    [native code]
}, get onlostpointercapture() {
    [native code]
}, set onlostpointercapture() {
    [native code]
}, get onmozfullscreenchange() {
    [native code]
}, set onmozfullscreenchange() {
    [native code]
}, get onmozfullscreenerror() {
    [native code]
}, set onmozfullscreenerror() {
    [native code]
}, get onanimationcancel() {
    [native code]
}, set onanimationcancel() {
    [native code]
}, get onanimationend() {
    [native code]
}, set onanimationend() {
    [native code]
}, get onanimationiteration() {
    [native code]
}, set onanimationiteration() {
    [native code]
}, get onanimationstart() {
    [native code]
}, set onanimationstart() {
    [native code]
}, get ontransitioncancel() {
    [native code]
}, set ontransitioncancel() {
    [native code]
}, get ontransitionend() {
    [native code]
}, set ontransitionend() {
    [native code]
}, get ontransitionrun() {
    [native code]
}, set ontransitionrun() {
    [native code]
}, get ontransitionstart() {
    [native code]
}, set ontransitionstart() {
    [native code]
}, get onwebkitanimationend() {
    [native code]
}, set onwebkitanimationend() {
    [native code]
}, get onwebkitanimationiteration() {
    [native code]
}, set onwebkitanimationiteration() {
    [native code]
}, get onwebkitanimationstart() {
    [native code]
}, set onwebkitanimationstart() {
    [native code]
}, get onwebkittransitionend() {
    [native code]
}, set onwebkittransitionend() {
    [native code]
}, get u2f() {
    [native code]
}, set u2f() {
    [native code]
}, get onerror() {
    [native code]
}, set onerror() {
    [native code]
}, get speechSynthesis() {
    [native code]
}, get onafterprint() {
    [native code]
}, set onafterprint() {
    [native code]
}, get onbeforeprint() {
    [native code]
}, set onbeforeprint() {
    [native code]
}, get onbeforeunload() {
    [native code]
}, set onbeforeunload() {
    [native code]
}, get onhashchange() {
    [native code]
}, set onhashchange() {
    [native code]
}, get onlanguagechange() {
    [native code]
}, set onlanguagechange() {
    [native code]
}, get onmessage() {
    [native code]
}, set onmessage() {
    [native code]
}, get onmessageerror() {
    [native code]
}, set onmessageerror() {
    [native code]
}, get onoffline() {
    [native code]
}, set onoffline() {
    [native code]
}, get ononline() {
    [native code]
}, set ononline() {
    [native code]
}, get onpagehide() {
    [native code]
}, set onpagehide() {
    [native code]
}, get onpageshow() {
    [native code]
}, set onpageshow() {
    [native code]
}, get onpopstate() {
    [native code]
}, set onpopstate() {
    [native code]
}, get onrejectionhandled() {
    [native code]
}, set onrejectionhandled() {
    [native code]
}, get onstorage() {
    [native code]
}, set onstorage() {
    [native code]
}, get onunhandledrejection() {
    [native code]
}, set onunhandledrejection() {
    [native code]
}, get onunload() {
    [native code]
}, set onunload() {
    [native code]
}, get ongamepadconnected() {
    [native code]
}, set ongamepadconnected() {
    [native code]
}, get ongamepaddisconnected() {
    [native code]
}, set ongamepaddisconnected() {
    [native code]
}, get localStorage() {
    [native code]
}, get origin() {
    [native code]
}, set origin() {
    [native code]
}, get crossOriginIsolated() {
    [native code]
}, get isSecureContext() {
    [native code]
}, get indexedDB() {
    [native code]
}, get caches() {
    [native code]
}, get sessionStorage() {
    [native code]
}, mozScrollSnap:function mozScrollSnap() {
    [native code]
}, openDialog:function openDialog() {
    [native code]
}, getInterface:function getInterface() {
    [native code]
}, shouldReportForServiceWorkerScope:function shouldReportForServiceWorkerScope() {
    [native code]
}, setScrollMarks:function setScrollMarks() {
    [native code]
}, get controllers() {
    [native code]
}, set controllers() {
    [native code]
}, get realFrameElement() {
    [native code]
}, get docShell() {
    [native code]
}, get browsingContext() {
    [native code]
}, get desktopToDeviceScale() {
    [native code]
}, get scrollMinX() {
    [native code]
}, get scrollMinY() {
    [native code]
}, get windowRoot() {
    [native code]
}, get windowUtils() {
    [native code]
}, get windowGlobalChild() {
    [native code]
}, get clientPrincipal() {
    [native code]
}, get isChromeWindow() {
    [native code]
}, get Glean() {
    [native code]
}, get GleanPings() {
    [native code]
}}, followWindowGlobalLifeCycle:true, isTopLevelTarget:false, ignoreSubFrames:true, sessionContext:{type:"browser-element", browserId:8, isServerTargetSwitchingEnabled:true, isPopupDebuggingEnabled:false}, _extraActors:{consoleActor:{_options:{id:"devtools/server/actors/webconsole", prefix:"console", constructorName:"WebConsoleActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"consoleActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal4294967319/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967319", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"consoleActor", actorID:"server0.conn0.windowGlobal4294967319/consoleActor3", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967319/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967319", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, inspectorActor:{_options:{id:"devtools/server/actors/inspector/inspector", prefix:"inspector", constructorName:"InspectorActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"inspectorActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal4294967319/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967319", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"inspectorActor", actorID:"server0.conn0.windowGlobal4294967319/inspectorActor4", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967319/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967319", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, styleSheetsActor:{_options:{id:"devtools/server/actors/style-sheets", prefix:"styleSheets", constructorName:"StyleSheetsActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"styleSheetsActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal4294967319/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967319", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"styleSheetsActor", actorID:"server0.conn0.windowGlobal4294967319/styleSheetsActor5", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967319/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967319", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, storageActor:{_options:{id:"devtools/server/actors/storage", prefix:"storage", constructorName:"StorageActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"storageActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal4294967319/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967319", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"storageActor", actorID:"server0.conn0.windowGlobal4294967319/storageActor6", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967319/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967319", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, memoryActor:{_options:{id:"devtools/server/actors/memory", prefix:"memory", constructorName:"MemoryActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"memoryActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal4294967319/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967319", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"memoryActor", actorID:"server0.conn0.windowGlobal4294967319/memoryActor7", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967319/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967319", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, framerateActor:{_options:{id:"devtools/server/actors/framerate", prefix:"framerate", constructorName:"FramerateActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"framerateActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal4294967319/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967319", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"framerateActor", actorID:"server0.conn0.windowGlobal4294967319/framerateActor8", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967319/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967319", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, reflowActor:{_options:{id:"devtools/server/actors/reflow", prefix:"reflow", constructorName:"ReflowActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"reflowActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal4294967319/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967319", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"reflowActor", actorID:"server0.conn0.windowGlobal4294967319/reflowActor9", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967319/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967319", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, cssPropertiesActor:{_options:{id:"devtools/server/actors/css-properties", prefix:"cssProperties", constructorName:"CssPropertiesActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"cssPropertiesActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal4294967319/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967319", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"cssPropertiesActor", actorID:"server0.conn0.windowGlobal4294967319/cssPropertiesActor10", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967319/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967319", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, performanceActor:{_options:{id:"devtools/server/actors/performance", prefix:"performance", constructorName:"PerformanceActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"performanceActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal4294967319/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967319", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"performanceActor", actorID:"server0.conn0.windowGlobal4294967319/performanceActor11", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967319/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967319", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, animationsActor:{_options:{id:"devtools/server/actors/animation", prefix:"animations", constructorName:"AnimationsActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"animationsActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal4294967319/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967319", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"animationsActor", actorID:"server0.conn0.windowGlobal4294967319/animationsActor12", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967319/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967319", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, responsiveActor:{_options:{id:"devtools/server/actors/emulation/responsive", prefix:"responsive", constructorName:"ResponsiveActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"responsiveActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal4294967319/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967319", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"responsiveActor", actorID:"server0.conn0.windowGlobal4294967319/responsiveActor13", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967319/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967319", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, webExtensionInspectedWindowActor:{_options:{id:"devtools/server/actors/addon/webextension-inspected-window", prefix:"webExtensionInspectedWindow", constructorName:"WebExtensionInspectedWindowActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"webExtensionInspectedWindowActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal4294967319/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967319", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"webExtensionInspectedWindowActor", actorID:"server0.conn0.windowGlobal4294967319/webExtensionInspectedWindowActor14", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967319/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967319", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, accessibilityActor:{_options:{id:"devtools/server/actors/accessibility/accessibility", prefix:"accessibility", constructorName:"AccessibilityActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"accessibilityActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal4294967319/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967319", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"accessibilityActor", actorID:"server0.conn0.windowGlobal4294967319/accessibilityActor15", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967319/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967319", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, changesActor:{_options:{id:"devtools/server/actors/changes", prefix:"changes", constructorName:"ChangesActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"changesActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal4294967319/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967319", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"changesActor", actorID:"server0.conn0.windowGlobal4294967319/changesActor16", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967319/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967319", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, webSocketActor:{_options:{id:"devtools/server/actors/network-monitor/websocket-actor", prefix:"webSocket", constructorName:"WebSocketActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"webSocketActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal4294967319/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967319", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"webSocketActor", actorID:"server0.conn0.windowGlobal4294967319/webSocketActor17", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967319/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967319", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, eventSourceActor:{_options:{id:"devtools/server/actors/network-monitor/eventsource-actor", prefix:"eventSource", constructorName:"EventSourceActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"eventSourceActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal4294967319/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967319", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"eventSourceActor", actorID:"server0.conn0.windowGlobal4294967319/eventSourceActor18", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967319/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967319", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, manifestActor:{_options:{id:"devtools/server/actors/manifest", prefix:"manifest", constructorName:"ManifestActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"manifestActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal4294967319/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967319", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"manifestActor", actorID:"server0.conn0.windowGlobal4294967319/manifestActor19", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967319/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967319", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, networkContentActor:{_options:{id:"devtools/server/actors/network-monitor/network-content", prefix:"networkContent", constructorName:"NetworkContentActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"networkContentActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal4294967319/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967319", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"networkContentActor", actorID:"server0.conn0.windowGlobal4294967319/networkContentActor20", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967319/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967319", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, screenshotContentActor:{_options:{id:"devtools/server/actors/screenshot-content", prefix:"screenshotContent", constructorName:"ScreenshotContentActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"screenshotContentActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal4294967319/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967319", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"screenshotContentActor", actorID:"server0.conn0.windowGlobal4294967319/screenshotContentActor21", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967319/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967319", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}}, _sourcesManager:{_thread:{conn:{_prefix:"server0.conn0.windowGlobal4294967319/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967319", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {conn:{}, __poolMap:{}}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, actorID:"server0.conn0.windowGlobal4294967319/thread1", _actorSpec:{typeName:"thread", methods:[{name:"attach", request:{type:"attach", template:{type:"attach", options:{index:0, type:{toString() {
        return "[protocol type:" + name + "]";
      }, name:"json", primitive:true, read:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}, write:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}}}}, args:[{placeholder:{index:0, type:{toString() {
        return "[protocol type:" + name + "]";
      }, name:"json", primitive:true, read:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}, write:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}}}, path:["options"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"reconfigure", request:{type:"reconfigure", template:{type:"reconfigure", options:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["options"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"resume", request:{type:"resume", template:{type:"resume", resumeLimit:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, frameActorID:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["resumeLimit"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["frameActorID"]}]}, response:{template:{_type:"nullable:json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, retVal:{_type:"nullable:json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:[]}, release:(void 0), oneway:(void 0)}, {name:"frames", request:{type:"frames", template:{type:"frames", start:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, count:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["start"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["count"]}]}, response:{template:{_type:"thread.frames", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, retVal:{_type:"thread.frames", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:[]}, release:(void 0), oneway:(void 0)}, {name:"interrupt", request:{type:"interrupt", template:{type:"interrupt", when:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["when"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"sources", request:{type:"sources", template:{type:"sources"}, args:[]}, response:{template:{sources:{_type:"array:json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, retVal:{_type:"array:json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["sources"]}, release:(void 0), oneway:(void 0)}, {name:"skipBreakpoints", request:{type:"skipBreakpoints", template:{type:"skipBreakpoints", skip:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["skip"]}]}, response:{template:{skip:{index:0, type:{toString() {
        return "[protocol type:" + name + "]";
      }, name:"json", primitive:true, read:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}, write:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}}}}}, release:(void 0), oneway:(void 0)}, {name:"dumpThread", request:{type:"dumpThread", template:{type:"dumpThread"}, args:[]}, response:{template:{_type:"json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, retVal:{_type:"json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:[]}, release:(void 0), oneway:(void 0)}, {name:"dumpPools", request:{type:"dumpPools", template:{type:"dumpPools"}, args:[]}, response:{template:{_type:"json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, retVal:{_type:"json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:[]}, release:(void 0), oneway:(void 0)}, {name:"setBreakpoint", request:{type:"setBreakpoint", template:{type:"setBreakpoint", location:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, options:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["location"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["options"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"removeBreakpoint", request:{type:"removeBreakpoint", template:{type:"removeBreakpoint", location:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["location"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"setXHRBreakpoint", request:{type:"setXHRBreakpoint", template:{type:"setXHRBreakpoint", path:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, method:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["path"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["method"]}]}, response:{template:{value:{_type:"boolean", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, retVal:{_type:"boolean", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["value"]}, release:(void 0), oneway:(void 0)}, {name:"removeXHRBreakpoint", request:{type:"removeXHRBreakpoint", template:{type:"removeXHRBreakpoint", path:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, method:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["path"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["method"]}]}, response:{template:{value:{_type:"boolean", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, retVal:{_type:"boolean", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["value"]}, release:(void 0), oneway:(void 0)}, {name:"getAvailableEventBreakpoints", request:{type:"getAvailableEventBreakpoints", template:{type:"getAvailableEventBreakpoints"}, args:[]}, response:{template:{value:{_type:"array:available-breakpoint-group", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, retVal:{_type:"array:available-breakpoint-group", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["value"]}, release:(void 0), oneway:(void 0)}, {name:"getActiveEventBreakpoints", request:{type:"getActiveEventBreakpoints", template:{type:"getActiveEventBreakpoints"}, args:[]}, response:{template:{ids:{_type:"array:string", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, retVal:{_type:"array:string", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["ids"]}, release:(void 0), oneway:(void 0)}, {name:"setActiveEventBreakpoints", request:{type:"setActiveEventBreakpoints", template:{type:"setActiveEventBreakpoints", ids:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["ids"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"pauseOnExceptions", request:{type:"pauseOnExceptions", template:{type:"pauseOnExceptions", pauseOnExceptions:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, ignoreCaughtExceptions:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["pauseOnExceptions"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["ignoreCaughtExceptions"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"toggleEventLogging", request:{type:"toggleEventLogging", template:{type:"toggleEventLogging", logEventBreakpoints:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["logEventBreakpoints"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"isAttached", request:{type:"isAttached", template:{type:"isAttached"}, args:[]}, response:{template:{value:{_type:"boolean", type:{toString() {
        return "[protocol type:" + name + "]";
      }, name:"boolean", primitive:true, read:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}, write:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}}}}, retVal:{_type:"boolean", type:{toString() {
        return "[protocol type:" + name + "]";
      }, name:"boolean", primitive:true, read:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}, write:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}}}, path:["value"]}, release:(void 0), oneway:(void 0)}], events:{}}, _state:"running", _parent:{}, global:{get window() {
    [native code]
}, get document() {
    [native code]
}, get location() {
    [native code]
}, set location() {
    [native code]
}, get top() {
    [native code]
}, close:function close() {
    [native code]
}, stop:function stop() {
    [native code]
}, focus:function focus() {
    [native code]
}, blur:function blur() {
    [native code]
}, open:function open() {
    [native code]
}, alert:function alert() {
    [native code]
}, confirm:function confirm() {
    [native code]
}, prompt:function prompt() {
    [native code]
}, print:function print() {
    [native code]
}, printPreview:function printPreview() {
    [native code]
}, postMessage:function postMessage() {
    [native code]
}, captureEvents:function captureEvents() {
    [native code]
}, releaseEvents:function releaseEvents() {
    [native code]
}, getSelection:function getSelection() {
    [native code]
}, getComputedStyle:function getComputedStyle() {
    [native code]
}, matchMedia:function matchMedia() {
    [native code]
}, moveTo:function moveTo() {
    [native code]
}, moveBy:function moveBy() {
    [native code]
}, resizeTo:function resizeTo() {
    [native code]
}, resizeBy:function resizeBy() {
    [native code]
}, scroll:function scroll() {
    [native code]
}, scrollTo:function scrollTo() {
    [native code]
}, scrollBy:function scrollBy() {
    [native code]
}, getDefaultComputedStyle:function getDefaultComputedStyle() {
    [native code]
}, scrollByLines:function scrollByLines() {
    [native code]
}, scrollByPages:function scrollByPages() {
    [native code]
}, sizeToContent:function sizeToContent() {
    [native code]
}, updateCommands:function updateCommands() {
    [native code]
}, find:function find() {
    [native code]
}, dump:function dump() {
    [native code]
}, setResizable:function setResizable() {
    [native code]
}, requestIdleCallback:function requestIdleCallback() {
    [native code]
}, cancelIdleCallback:function cancelIdleCallback() {
    [native code]
}, getRegionalPrefsLocales:function getRegionalPrefsLocales() {
    [native code]
}, getWebExposedLocales:function getWebExposedLocales() {
    [native code]
}, requestAnimationFrame:function requestAnimationFrame() {
    [native code]
}, cancelAnimationFrame:function cancelAnimationFrame() {
    [native code]
}, reportError:function reportError() {
    [native code]
}, btoa:function btoa() {
    [native code]
}, atob:function atob() {
    [native code]
}, setTimeout:function setTimeout() {
    [native code]
}, clearTimeout:function clearTimeout() {
    [native code]
}, setInterval:function setInterval() {
    [native code]
}, clearInterval:function clearInterval() {
    [native code]
}, queueMicrotask:function queueMicrotask() {
    [native code]
}, createImageBitmap:function createImageBitmap() {
    [native code]
}, structuredClone:function structuredClone() {
    [native code]
}, fetch:function fetch() {
    [native code]
}, get self() {
    [native code]
}, set self() {
    [native code]
}, get name() {
    [native code]
}, set name() {
    [native code]
}, get history() {
    [native code]
}, get customElements() {
    [native code]
}, get locationbar() {
    [native code]
}, set locationbar() {
    [native code]
}, get menubar() {
    [native code]
}, set menubar() {
    [native code]
}, get personalbar() {
    [native code]
}, set personalbar() {
    [native code]
}, get scrollbars() {
    [native code]
}, set scrollbars() {
    [native code]
}, get statusbar() {
    [native code]
}, set statusbar() {
    [native code]
}, get toolbar() {
    [native code]
}, set toolbar() {
    [native code]
}, get status() {
    [native code]
}, set status() {
    [native code]
}, get closed() {
    [native code]
}, get event() {
    [native code]
}, set event() {
    [native code]
}, get frames() {
    [native code]
}, set frames() {
    [native code]
}, get length() {
    [native code]
}, set length() {
    [native code]
}, get opener() {
    [native code]
}, set opener() {
    [native code]
}, get parent() {
    [native code]
}, set parent() {
    [native code]
}, get frameElement() {
    [native code]
}, get navigator() {
    [native code]
}, get clientInformation() {
    [native code]
}, get external() {
    [native code]
}, set external() {
    [native code]
}, get screen() {
    [native code]
}, set screen() {
    [native code]
}, get innerWidth() {
    [native code]
}, set innerWidth() {
    [native code]
}, get innerHeight() {
    [native code]
}, set innerHeight() {
    [native code]
}, get scrollX() {
    [native code]
}, set scrollX() {
    [native code]
}, get pageXOffset() {
    [native code]
}, set pageXOffset() {
    [native code]
}, get scrollY() {
    [native code]
}, set scrollY() {
    [native code]
}, get pageYOffset() {
    [native code]
}, set pageYOffset() {
    [native code]
}, get screenLeft() {
    [native code]
}, set screenLeft() {
    [native code]
}, get screenTop() {
    [native code]
}, set screenTop() {
    [native code]
}, get screenX() {
    [native code]
}, set screenX() {
    [native code]
}, get screenY() {
    [native code]
}, set screenY() {
    [native code]
}, get outerWidth() {
    [native code]
}, set outerWidth() {
    [native code]
}, get outerHeight() {
    [native code]
}, set outerHeight() {
    [native code]
}, get performance() {
    [native code]
}, set performance() {
    [native code]
}, get mozInnerScreenX() {
    [native code]
}, get mozInnerScreenY() {
    [native code]
}, get devicePixelRatio() {
    [native code]
}, set devicePixelRatio() {
    [native code]
}, get scrollMaxX() {
    [native code]
}, set scrollMaxX() {
    [native code]
}, get scrollMaxY() {
    [native code]
}, set scrollMaxY() {
    [native code]
}, get fullScreen() {
    [native code]
}, set fullScreen() {
    [native code]
}, get ondevicemotion() {
    [native code]
}, set ondevicemotion() {
    [native code]
}, get ondeviceorientation() {
    [native code]
}, set ondeviceorientation() {
    [native code]
}, get onabsolutedeviceorientation() {
    [native code]
}, set onabsolutedeviceorientation() {
    [native code]
}, get InstallTrigger() {
    [native code]
}, set InstallTrigger() {
    [native code]
}, get intlUtils() {
    [native code]
}, get visualViewport() {
    [native code]
}, set visualViewport() {
    [native code]
}, get crypto() {
    [native code]
}, get onabort() {
    [native code]
}, set onabort() {
    [native code]
}, get onblur() {
    [native code]
}, set onblur() {
    [native code]
}, get onfocus() {
    [native code]
}, set onfocus() {
    [native code]
}, get onauxclick() {
    [native code]
}, set onauxclick() {
    [native code]
}, get onbeforeinput() {
    [native code]
}, set onbeforeinput() {
    [native code]
}, get oncanplay() {
    [native code]
}, set oncanplay() {
    [native code]
}, get oncanplaythrough() {
    [native code]
}, set oncanplaythrough() {
    [native code]
}, get onchange() {
    [native code]
}, set onchange() {
    [native code]
}, get onclick() {
    [native code]
}, set onclick() {
    [native code]
}, get onclose() {
    [native code]
}, set onclose() {
    [native code]
}, get oncontextmenu() {
    [native code]
}, set oncontextmenu() {
    [native code]
}, get oncuechange() {
    [native code]
}, set oncuechange() {
    [native code]
}, get ondblclick() {
    [native code]
}, set ondblclick() {
    [native code]
}, get ondrag() {
    [native code]
}, set ondrag() {
    [native code]
}, get ondragend() {
    [native code]
}, set ondragend() {
    [native code]
}, get ondragenter() {
    [native code]
}, set ondragenter() {
    [native code]
}, get ondragexit() {
    [native code]
}, set ondragexit() {
    [native code]
}, get ondragleave() {
    [native code]
}, set ondragleave() {
    [native code]
}, get ondragover() {
    [native code]
}, set ondragover() {
    [native code]
}, get ondragstart() {
    [native code]
}, set ondragstart() {
    [native code]
}, get ondrop() {
    [native code]
}, set ondrop() {
    [native code]
}, get ondurationchange() {
    [native code]
}, set ondurationchange() {
    [native code]
}, get onemptied() {
    [native code]
}, set onemptied() {
    [native code]
}, get onended() {
    [native code]
}, set onended() {
    [native code]
}, get onformdata() {
    [native code]
}, set onformdata() {
    [native code]
}, get oninput() {
    [native code]
}, set oninput() {
    [native code]
}, get oninvalid() {
    [native code]
}, set oninvalid() {
    [native code]
}, get onkeydown() {
    [native code]
}, set onkeydown() {
    [native code]
}, get onkeypress() {
    [native code]
}, set onkeypress() {
    [native code]
}, get onkeyup() {
    [native code]
}, set onkeyup() {
    [native code]
}, get onload() {
    [native code]
}, set onload() {
    [native code]
}, get onloadeddata() {
    [native code]
}, set onloadeddata() {
    [native code]
}, get onloadedmetadata() {
    [native code]
}, set onloadedmetadata() {
    [native code]
}, get onloadend() {
    [native code]
}, set onloadend() {
    [native code]
}, get onloadstart() {
    [native code]
}, set onloadstart() {
    [native code]
}, get onmousedown() {
    [native code]
}, set onmousedown() {
    [native code]
}, get onmouseenter() {
    [native code]
}, set onmouseenter() {
    [native code]
}, get onmouseleave() {
    [native code]
}, set onmouseleave() {
    [native code]
}, get onmousemove() {
    [native code]
}, set onmousemove() {
    [native code]
}, get onmouseout() {
    [native code]
}, set onmouseout() {
    [native code]
}, get onmouseover() {
    [native code]
}, set onmouseover() {
    [native code]
}, get onmouseup() {
    [native code]
}, set onmouseup() {
    [native code]
}, get onwheel() {
    [native code]
}, set onwheel() {
    [native code]
}, get onpause() {
    [native code]
}, set onpause() {
    [native code]
}, get onplay() {
    [native code]
}, set onplay() {
    [native code]
}, get onplaying() {
    [native code]
}, set onplaying() {
    [native code]
}, get onprogress() {
    [native code]
}, set onprogress() {
    [native code]
}, get onratechange() {
    [native code]
}, set onratechange() {
    [native code]
}, get onreset() {
    [native code]
}, set onreset() {
    [native code]
}, get onresize() {
    [native code]
}, set onresize() {
    [native code]
}, get onscroll() {
    [native code]
}, set onscroll() {
    [native code]
}, get onsecuritypolicyviolation() {
    [native code]
}, set onsecuritypolicyviolation() {
    [native code]
}, get onseeked() {
    [native code]
}, set onseeked() {
    [native code]
}, get onseeking() {
    [native code]
}, set onseeking() {
    [native code]
}, get onselect() {
    [native code]
}, set onselect() {
    [native code]
}, get onslotchange() {
    [native code]
}, set onslotchange() {
    [native code]
}, get onstalled() {
    [native code]
}, set onstalled() {
    [native code]
}, get onsubmit() {
    [native code]
}, set onsubmit() {
    [native code]
}, get onsuspend() {
    [native code]
}, set onsuspend() {
    [native code]
}, get ontimeupdate() {
    [native code]
}, set ontimeupdate() {
    [native code]
}, get onvolumechange() {
    [native code]
}, set onvolumechange() {
    [native code]
}, get onwaiting() {
    [native code]
}, set onwaiting() {
    [native code]
}, get onselectstart() {
    [native code]
}, set onselectstart() {
    [native code]
}, get onselectionchange() {
    [native code]
}, set onselectionchange() {
    [native code]
}, get ontoggle() {
    [native code]
}, set ontoggle() {
    [native code]
}, get onpointercancel() {
    [native code]
}, set onpointercancel() {
    [native code]
}, get onpointerdown() {
    [native code]
}, set onpointerdown() {
    [native code]
}, get onpointerup() {
    [native code]
}, set onpointerup() {
    [native code]
}, get onpointermove() {
    [native code]
}, set onpointermove() {
    [native code]
}, get onpointerout() {
    [native code]
}, set onpointerout() {
    [native code]
}, get onpointerover() {
    [native code]
}, set onpointerover() {
    [native code]
}, get onpointerenter() {
    [native code]
}, set onpointerenter() {
    [native code]
}, get onpointerleave() {
    [native code]
}, set onpointerleave() {
    [native code]
}, get ongotpointercapture() {
    [native code]
}, set ongotpointercapture() {
    [native code]
}, get onlostpointercapture() {
    [native code]
}, set onlostpointercapture() {
    [native code]
}, get onmozfullscreenchange() {
    [native code]
}, set onmozfullscreenchange() {
    [native code]
}, get onmozfullscreenerror() {
    [native code]
}, set onmozfullscreenerror() {
    [native code]
}, get onanimationcancel() {
    [native code]
}, set onanimationcancel() {
    [native code]
}, get onanimationend() {
    [native code]
}, set onanimationend() {
    [native code]
}, get onanimationiteration() {
    [native code]
}, set onanimationiteration() {
    [native code]
}, get onanimationstart() {
    [native code]
}, set onanimationstart() {
    [native code]
}, get ontransitioncancel() {
    [native code]
}, set ontransitioncancel() {
    [native code]
}, get ontransitionend() {
    [native code]
}, set ontransitionend() {
    [native code]
}, get ontransitionrun() {
    [native code]
}, set ontransitionrun() {
    [native code]
}, get ontransitionstart() {
    [native code]
}, set ontransitionstart() {
    [native code]
}, get onwebkitanimationend() {
    [native code]
}, set onwebkitanimationend() {
    [native code]
}, get onwebkitanimationiteration() {
    [native code]
}, set onwebkitanimationiteration() {
    [native code]
}, get onwebkitanimationstart() {
    [native code]
}, set onwebkitanimationstart() {
    [native code]
}, get onwebkittransitionend() {
    [native code]
}, set onwebkittransitionend() {
    [native code]
}, get u2f() {
    [native code]
}, set u2f() {
    [native code]
}, get onerror() {
    [native code]
}, set onerror() {
    [native code]
}, get speechSynthesis() {
    [native code]
}, get onafterprint() {
    [native code]
}, set onafterprint() {
    [native code]
}, get onbeforeprint() {
    [native code]
}, set onbeforeprint() {
    [native code]
}, get onbeforeunload() {
    [native code]
}, set onbeforeunload() {
    [native code]
}, get onhashchange() {
    [native code]
}, set onhashchange() {
    [native code]
}, get onlanguagechange() {
    [native code]
}, set onlanguagechange() {
    [native code]
}, get onmessage() {
    [native code]
}, set onmessage() {
    [native code]
}, get onmessageerror() {
    [native code]
}, set onmessageerror() {
    [native code]
}, get onoffline() {
    [native code]
}, set onoffline() {
    [native code]
}, get ononline() {
    [native code]
}, set ononline() {
    [native code]
}, get onpagehide() {
    [native code]
}, set onpagehide() {
    [native code]
}, get onpageshow() {
    [native code]
}, set onpageshow() {
    [native code]
}, get onpopstate() {
    [native code]
}, set onpopstate() {
    [native code]
}, get onrejectionhandled() {
    [native code]
}, set onrejectionhandled() {
    [native code]
}, get onstorage() {
    [native code]
}, set onstorage() {
    [native code]
}, get onunhandledrejection() {
    [native code]
}, set onunhandledrejection() {
    [native code]
}, get onunload() {
    [native code]
}, set onunload() {
    [native code]
}, get ongamepadconnected() {
    [native code]
}, set ongamepadconnected() {
    [native code]
}, get ongamepaddisconnected() {
    [native code]
}, set ongamepaddisconnected() {
    [native code]
}, get localStorage() {
    [native code]
}, get origin() {
    [native code]
}, set origin() {
    [native code]
}, get crossOriginIsolated() {
    [native code]
}, get isSecureContext() {
    [native code]
}, get indexedDB() {
    [native code]
}, get caches() {
    [native code]
}, get sessionStorage() {
    [native code]
}, mozScrollSnap:function mozScrollSnap() {
    [native code]
}, openDialog:function openDialog() {
    [native code]
}, getInterface:function getInterface() {
    [native code]
}, shouldReportForServiceWorkerScope:function shouldReportForServiceWorkerScope() {
    [native code]
}, setScrollMarks:function setScrollMarks() {
    [native code]
}, get controllers() {
    [native code]
}, set controllers() {
    [native code]
}, get realFrameElement() {
    [native code]
}, get docShell() {
    [native code]
}, get browsingContext() {
    [native code]
}, get desktopToDeviceScale() {
    [native code]
}, get scrollMinX() {
    [native code]
}, get scrollMinY() {
    [native code]
}, get windowRoot() {
    [native code]
}, get windowUtils() {
    [native code]
}, get windowGlobalChild() {
    [native code]
}, get clientPrincipal() {
    [native code]
}, get isChromeWindow() {
    [native code]
}, get Glean() {
    [native code]
}, get GleanPings() {
    [native code]
}}, _options:{skipBreakpoints:false, pauseOnExceptions:false, ignoreCaughtExceptions:true, shouldShowOverlay:true, shouldIncludeSavedFrames:true, shouldIncludeAsyncLiveFrames:false, logEventBreakpoints:false, observeAsmJS:true}, _gripDepth:0, _parentClosed:false, _observingNetwork:false, _frameActors:[], _xhrBreakpoints:[], _dbg:{addDebuggees:(function() {
    for (const global of findDebuggees(this)) {
      safeAddDebuggee(this, global);
    }
  }), disable:(function() {
    dbg.removeAllDebuggees();
    dbg.onNewGlobalObject = undefined;
  }), enable:(function() {
    dbg.addDebuggees();
    dbg.onNewGlobalObject = onNewGlobalObject;
  }), onNewDebuggee:function bound _onNewDebuggee() {
    [native code]
}}, _threadLifetimePool:null, _activeEventPause:null, _pauseOverlay:null, _priorPause:null, _activeEventBreakpoints:{}, _frameActorMap:{}, _debuggerSourcesSeen:{}, _onLoadBreakpointURLs:{}, _handledFrameExceptions:{}, _watchpointsMap:{threadActor:{}, _watchpoints:{}}, breakpointActorMap:{_threadActor:{}, _actors:{}}, _nestedEventLoop:{_thread:{}, _entered:false, _resolved:false}, onNewSourceEvent:function bound onNewSourceEvent() {
    [native code]
}, createCompletionGrip:function bound createCompletionGrip() {
    [native code]
}, onDebuggerStatement:function bound onDebuggerStatement() {
    [native code]
}, onNewScript:function bound onNewScript() {
    [native code]
}, objectGrip:function bound objectGrip() {
    [native code]
}, pauseObjectGrip:function bound pauseObjectGrip() {
    [native code]
}, _onOpeningRequest:function bound _onOpeningRequest() {
    [native code]
}, _onNewDebuggee:function bound _onNewDebuggee() {
    [native code]
}, _onExceptionUnwind:function bound _onExceptionUnwind() {
    [native code]
}, _eventBreakpointListener:function bound _eventBreakpointListener() {
    [native code]
}, _onWindowReady:function bound _onWindowReady() {
    [native code]
}, _onWillNavigate:function bound _onWillNavigate() {
    [native code]
}, _onNavigate:function bound _onNavigate() {
    [native code]
}, _firstStatementBreakpoint:null, _debuggerNotificationObserver:{}, parentPool:{}, alreadyAttached:true, wrappedJSObject:{}, _shouldEmitNewSource:false, _pendingResponse:{}, [Symbol("EventEmitter/listeners")]:{}}, blackBoxedSources:{}, _sourceActors:{}, _urlContents:{}, _urlWaiters:{}, _sourcesByInternalSourceId:null, [Symbol("EventEmitter/listeners")]:{}}, _styleSheetActors:{}, _shouldAddNewGlobalAsDebuggee:function bound _shouldAddNewGlobalAsDebuggee() {
    [native code]
}, makeDebugger:function bound makeDebugger() {
    [native code]
}, watchNewDocShells:false, _isNewPerfPanelEnabled:true, _workerDescriptorActorList:null, _workerDescriptorActorPool:null, _onWorkerDescriptorActorListChanged:function bound _onWorkerDescriptorActorListChanged() {
    [native code]
}, _onConsoleApiProfilerEvent:function bound _onConsoleApiProfilerEvent() {
    [native code]
}, threadActor:{conn:{_prefix:"server0.conn0.windowGlobal4294967319/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967319", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {conn:{}, __poolMap:{}}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, actorID:"server0.conn0.windowGlobal4294967319/thread1", _actorSpec:{typeName:"thread", methods:[{name:"attach", request:{type:"attach", template:{type:"attach", options:{index:0, type:{toString() {
        return "[protocol type:" + name + "]";
      }, name:"json", primitive:true, read:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}, write:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}}}}, args:[{placeholder:{index:0, type:{toString() {
        return "[protocol type:" + name + "]";
      }, name:"json", primitive:true, read:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}, write:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}}}, path:["options"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"reconfigure", request:{type:"reconfigure", template:{type:"reconfigure", options:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["options"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"resume", request:{type:"resume", template:{type:"resume", resumeLimit:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, frameActorID:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["resumeLimit"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["frameActorID"]}]}, response:{template:{_type:"nullable:json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, retVal:{_type:"nullable:json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:[]}, release:(void 0), oneway:(void 0)}, {name:"frames", request:{type:"frames", template:{type:"frames", start:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, count:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["start"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["count"]}]}, response:{template:{_type:"thread.frames", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, retVal:{_type:"thread.frames", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:[]}, release:(void 0), oneway:(void 0)}, {name:"interrupt", request:{type:"interrupt", template:{type:"interrupt", when:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["when"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"sources", request:{type:"sources", template:{type:"sources"}, args:[]}, response:{template:{sources:{_type:"array:json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, retVal:{_type:"array:json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["sources"]}, release:(void 0), oneway:(void 0)}, {name:"skipBreakpoints", request:{type:"skipBreakpoints", template:{type:"skipBreakpoints", skip:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["skip"]}]}, response:{template:{skip:{index:0, type:{toString() {
        return "[protocol type:" + name + "]";
      }, name:"json", primitive:true, read:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}, write:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}}}}}, release:(void 0), oneway:(void 0)}, {name:"dumpThread", request:{type:"dumpThread", template:{type:"dumpThread"}, args:[]}, response:{template:{_type:"json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, retVal:{_type:"json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:[]}, release:(void 0), oneway:(void 0)}, {name:"dumpPools", request:{type:"dumpPools", template:{type:"dumpPools"}, args:[]}, response:{template:{_type:"json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, retVal:{_type:"json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:[]}, release:(void 0), oneway:(void 0)}, {name:"setBreakpoint", request:{type:"setBreakpoint", template:{type:"setBreakpoint", location:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, options:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["location"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["options"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"removeBreakpoint", request:{type:"removeBreakpoint", template:{type:"removeBreakpoint", location:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["location"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"setXHRBreakpoint", request:{type:"setXHRBreakpoint", template:{type:"setXHRBreakpoint", path:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, method:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["path"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["method"]}]}, response:{template:{value:{_type:"boolean", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, retVal:{_type:"boolean", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["value"]}, release:(void 0), oneway:(void 0)}, {name:"removeXHRBreakpoint", request:{type:"removeXHRBreakpoint", template:{type:"removeXHRBreakpoint", path:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, method:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["path"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["method"]}]}, response:{template:{value:{_type:"boolean", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, retVal:{_type:"boolean", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["value"]}, release:(void 0), oneway:(void 0)}, {name:"getAvailableEventBreakpoints", request:{type:"getAvailableEventBreakpoints", template:{type:"getAvailableEventBreakpoints"}, args:[]}, response:{template:{value:{_type:"array:available-breakpoint-group", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, retVal:{_type:"array:available-breakpoint-group", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["value"]}, release:(void 0), oneway:(void 0)}, {name:"getActiveEventBreakpoints", request:{type:"getActiveEventBreakpoints", template:{type:"getActiveEventBreakpoints"}, args:[]}, response:{template:{ids:{_type:"array:string", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, retVal:{_type:"array:string", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["ids"]}, release:(void 0), oneway:(void 0)}, {name:"setActiveEventBreakpoints", request:{type:"setActiveEventBreakpoints", template:{type:"setActiveEventBreakpoints", ids:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["ids"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"pauseOnExceptions", request:{type:"pauseOnExceptions", template:{type:"pauseOnExceptions", pauseOnExceptions:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, ignoreCaughtExceptions:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["pauseOnExceptions"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["ignoreCaughtExceptions"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"toggleEventLogging", request:{type:"toggleEventLogging", template:{type:"toggleEventLogging", logEventBreakpoints:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["logEventBreakpoints"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"isAttached", request:{type:"isAttached", template:{type:"isAttached"}, args:[]}, response:{template:{value:{_type:"boolean", type:{toString() {
        return "[protocol type:" + name + "]";
      }, name:"boolean", primitive:true, read:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}, write:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}}}}, retVal:{_type:"boolean", type:{toString() {
        return "[protocol type:" + name + "]";
      }, name:"boolean", primitive:true, read:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}, write:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}}}, path:["value"]}, release:(void 0), oneway:(void 0)}], events:{}}, _state:"running", _parent:{}, global:{get window() {
    [native code]
}, get document() {
    [native code]
}, get location() {
    [native code]
}, set location() {
    [native code]
}, get top() {
    [native code]
}, close:function close() {
    [native code]
}, stop:function stop() {
    [native code]
}, focus:function focus() {
    [native code]
}, blur:function blur() {
    [native code]
}, open:function open() {
    [native code]
}, alert:function alert() {
    [native code]
}, confirm:function confirm() {
    [native code]
}, prompt:function prompt() {
    [native code]
}, print:function print() {
    [native code]
}, printPreview:function printPreview() {
    [native code]
}, postMessage:function postMessage() {
    [native code]
}, captureEvents:function captureEvents() {
    [native code]
}, releaseEvents:function releaseEvents() {
    [native code]
}, getSelection:function getSelection() {
    [native code]
}, getComputedStyle:function getComputedStyle() {
    [native code]
}, matchMedia:function matchMedia() {
    [native code]
}, moveTo:function moveTo() {
    [native code]
}, moveBy:function moveBy() {
    [native code]
}, resizeTo:function resizeTo() {
    [native code]
}, resizeBy:function resizeBy() {
    [native code]
}, scroll:function scroll() {
    [native code]
}, scrollTo:function scrollTo() {
    [native code]
}, scrollBy:function scrollBy() {
    [native code]
}, getDefaultComputedStyle:function getDefaultComputedStyle() {
    [native code]
}, scrollByLines:function scrollByLines() {
    [native code]
}, scrollByPages:function scrollByPages() {
    [native code]
}, sizeToContent:function sizeToContent() {
    [native code]
}, updateCommands:function updateCommands() {
    [native code]
}, find:function find() {
    [native code]
}, dump:function dump() {
    [native code]
}, setResizable:function setResizable() {
    [native code]
}, requestIdleCallback:function requestIdleCallback() {
    [native code]
}, cancelIdleCallback:function cancelIdleCallback() {
    [native code]
}, getRegionalPrefsLocales:function getRegionalPrefsLocales() {
    [native code]
}, getWebExposedLocales:function getWebExposedLocales() {
    [native code]
}, requestAnimationFrame:function requestAnimationFrame() {
    [native code]
}, cancelAnimationFrame:function cancelAnimationFrame() {
    [native code]
}, reportError:function reportError() {
    [native code]
}, btoa:function btoa() {
    [native code]
}, atob:function atob() {
    [native code]
}, setTimeout:function setTimeout() {
    [native code]
}, clearTimeout:function clearTimeout() {
    [native code]
}, setInterval:function setInterval() {
    [native code]
}, clearInterval:function clearInterval() {
    [native code]
}, queueMicrotask:function queueMicrotask() {
    [native code]
}, createImageBitmap:function createImageBitmap() {
    [native code]
}, structuredClone:function structuredClone() {
    [native code]
}, fetch:function fetch() {
    [native code]
}, get self() {
    [native code]
}, set self() {
    [native code]
}, get name() {
    [native code]
}, set name() {
    [native code]
}, get history() {
    [native code]
}, get customElements() {
    [native code]
}, get locationbar() {
    [native code]
}, set locationbar() {
    [native code]
}, get menubar() {
    [native code]
}, set menubar() {
    [native code]
}, get personalbar() {
    [native code]
}, set personalbar() {
    [native code]
}, get scrollbars() {
    [native code]
}, set scrollbars() {
    [native code]
}, get statusbar() {
    [native code]
}, set statusbar() {
    [native code]
}, get toolbar() {
    [native code]
}, set toolbar() {
    [native code]
}, get status() {
    [native code]
}, set status() {
    [native code]
}, get closed() {
    [native code]
}, get event() {
    [native code]
}, set event() {
    [native code]
}, get frames() {
    [native code]
}, set frames() {
    [native code]
}, get length() {
    [native code]
}, set length() {
    [native code]
}, get opener() {
    [native code]
}, set opener() {
    [native code]
}, get parent() {
    [native code]
}, set parent() {
    [native code]
}, get frameElement() {
    [native code]
}, get navigator() {
    [native code]
}, get clientInformation() {
    [native code]
}, get external() {
    [native code]
}, set external() {
    [native code]
}, get screen() {
    [native code]
}, set screen() {
    [native code]
}, get innerWidth() {
    [native code]
}, set innerWidth() {
    [native code]
}, get innerHeight() {
    [native code]
}, set innerHeight() {
    [native code]
}, get scrollX() {
    [native code]
}, set scrollX() {
    [native code]
}, get pageXOffset() {
    [native code]
}, set pageXOffset() {
    [native code]
}, get scrollY() {
    [native code]
}, set scrollY() {
    [native code]
}, get pageYOffset() {
    [native code]
}, set pageYOffset() {
    [native code]
}, get screenLeft() {
    [native code]
}, set screenLeft() {
    [native code]
}, get screenTop() {
    [native code]
}, set screenTop() {
    [native code]
}, get screenX() {
    [native code]
}, set screenX() {
    [native code]
}, get screenY() {
    [native code]
}, set screenY() {
    [native code]
}, get outerWidth() {
    [native code]
}, set outerWidth() {
    [native code]
}, get outerHeight() {
    [native code]
}, set outerHeight() {
    [native code]
}, get performance() {
    [native code]
}, set performance() {
    [native code]
}, get mozInnerScreenX() {
    [native code]
}, get mozInnerScreenY() {
    [native code]
}, get devicePixelRatio() {
    [native code]
}, set devicePixelRatio() {
    [native code]
}, get scrollMaxX() {
    [native code]
}, set scrollMaxX() {
    [native code]
}, get scrollMaxY() {
    [native code]
}, set scrollMaxY() {
    [native code]
}, get fullScreen() {
    [native code]
}, set fullScreen() {
    [native code]
}, get ondevicemotion() {
    [native code]
}, set ondevicemotion() {
    [native code]
}, get ondeviceorientation() {
    [native code]
}, set ondeviceorientation() {
    [native code]
}, get onabsolutedeviceorientation() {
    [native code]
}, set onabsolutedeviceorientation() {
    [native code]
}, get InstallTrigger() {
    [native code]
}, set InstallTrigger() {
    [native code]
}, get intlUtils() {
    [native code]
}, get visualViewport() {
    [native code]
}, set visualViewport() {
    [native code]
}, get crypto() {
    [native code]
}, get onabort() {
    [native code]
}, set onabort() {
    [native code]
}, get onblur() {
    [native code]
}, set onblur() {
    [native code]
}, get onfocus() {
    [native code]
}, set onfocus() {
    [native code]
}, get onauxclick() {
    [native code]
}, set onauxclick() {
    [native code]
}, get onbeforeinput() {
    [native code]
}, set onbeforeinput() {
    [native code]
}, get oncanplay() {
    [native code]
}, set oncanplay() {
    [native code]
}, get oncanplaythrough() {
    [native code]
}, set oncanplaythrough() {
    [native code]
}, get onchange() {
    [native code]
}, set onchange() {
    [native code]
}, get onclick() {
    [native code]
}, set onclick() {
    [native code]
}, get onclose() {
    [native code]
}, set onclose() {
    [native code]
}, get oncontextmenu() {
    [native code]
}, set oncontextmenu() {
    [native code]
}, get oncuechange() {
    [native code]
}, set oncuechange() {
    [native code]
}, get ondblclick() {
    [native code]
}, set ondblclick() {
    [native code]
}, get ondrag() {
    [native code]
}, set ondrag() {
    [native code]
}, get ondragend() {
    [native code]
}, set ondragend() {
    [native code]
}, get ondragenter() {
    [native code]
}, set ondragenter() {
    [native code]
}, get ondragexit() {
    [native code]
}, set ondragexit() {
    [native code]
}, get ondragleave() {
    [native code]
}, set ondragleave() {
    [native code]
}, get ondragover() {
    [native code]
}, set ondragover() {
    [native code]
}, get ondragstart() {
    [native code]
}, set ondragstart() {
    [native code]
}, get ondrop() {
    [native code]
}, set ondrop() {
    [native code]
}, get ondurationchange() {
    [native code]
}, set ondurationchange() {
    [native code]
}, get onemptied() {
    [native code]
}, set onemptied() {
    [native code]
}, get onended() {
    [native code]
}, set onended() {
    [native code]
}, get onformdata() {
    [native code]
}, set onformdata() {
    [native code]
}, get oninput() {
    [native code]
}, set oninput() {
    [native code]
}, get oninvalid() {
    [native code]
}, set oninvalid() {
    [native code]
}, get onkeydown() {
    [native code]
}, set onkeydown() {
    [native code]
}, get onkeypress() {
    [native code]
}, set onkeypress() {
    [native code]
}, get onkeyup() {
    [native code]
}, set onkeyup() {
    [native code]
}, get onload() {
    [native code]
}, set onload() {
    [native code]
}, get onloadeddata() {
    [native code]
}, set onloadeddata() {
    [native code]
}, get onloadedmetadata() {
    [native code]
}, set onloadedmetadata() {
    [native code]
}, get onloadend() {
    [native code]
}, set onloadend() {
    [native code]
}, get onloadstart() {
    [native code]
}, set onloadstart() {
    [native code]
}, get onmousedown() {
    [native code]
}, set onmousedown() {
    [native code]
}, get onmouseenter() {
    [native code]
}, set onmouseenter() {
    [native code]
}, get onmouseleave() {
    [native code]
}, set onmouseleave() {
    [native code]
}, get onmousemove() {
    [native code]
}, set onmousemove() {
    [native code]
}, get onmouseout() {
    [native code]
}, set onmouseout() {
    [native code]
}, get onmouseover() {
    [native code]
}, set onmouseover() {
    [native code]
}, get onmouseup() {
    [native code]
}, set onmouseup() {
    [native code]
}, get onwheel() {
    [native code]
}, set onwheel() {
    [native code]
}, get onpause() {
    [native code]
}, set onpause() {
    [native code]
}, get onplay() {
    [native code]
}, set onplay() {
    [native code]
}, get onplaying() {
    [native code]
}, set onplaying() {
    [native code]
}, get onprogress() {
    [native code]
}, set onprogress() {
    [native code]
}, get onratechange() {
    [native code]
}, set onratechange() {
    [native code]
}, get onreset() {
    [native code]
}, set onreset() {
    [native code]
}, get onresize() {
    [native code]
}, set onresize() {
    [native code]
}, get onscroll() {
    [native code]
}, set onscroll() {
    [native code]
}, get onsecuritypolicyviolation() {
    [native code]
}, set onsecuritypolicyviolation() {
    [native code]
}, get onseeked() {
    [native code]
}, set onseeked() {
    [native code]
}, get onseeking() {
    [native code]
}, set onseeking() {
    [native code]
}, get onselect() {
    [native code]
}, set onselect() {
    [native code]
}, get onslotchange() {
    [native code]
}, set onslotchange() {
    [native code]
}, get onstalled() {
    [native code]
}, set onstalled() {
    [native code]
}, get onsubmit() {
    [native code]
}, set onsubmit() {
    [native code]
}, get onsuspend() {
    [native code]
}, set onsuspend() {
    [native code]
}, get ontimeupdate() {
    [native code]
}, set ontimeupdate() {
    [native code]
}, get onvolumechange() {
    [native code]
}, set onvolumechange() {
    [native code]
}, get onwaiting() {
    [native code]
}, set onwaiting() {
    [native code]
}, get onselectstart() {
    [native code]
}, set onselectstart() {
    [native code]
}, get onselectionchange() {
    [native code]
}, set onselectionchange() {
    [native code]
}, get ontoggle() {
    [native code]
}, set ontoggle() {
    [native code]
}, get onpointercancel() {
    [native code]
}, set onpointercancel() {
    [native code]
}, get onpointerdown() {
    [native code]
}, set onpointerdown() {
    [native code]
}, get onpointerup() {
    [native code]
}, set onpointerup() {
    [native code]
}, get onpointermove() {
    [native code]
}, set onpointermove() {
    [native code]
}, get onpointerout() {
    [native code]
}, set onpointerout() {
    [native code]
}, get onpointerover() {
    [native code]
}, set onpointerover() {
    [native code]
}, get onpointerenter() {
    [native code]
}, set onpointerenter() {
    [native code]
}, get onpointerleave() {
    [native code]
}, set onpointerleave() {
    [native code]
}, get ongotpointercapture() {
    [native code]
}, set ongotpointercapture() {
    [native code]
}, get onlostpointercapture() {
    [native code]
}, set onlostpointercapture() {
    [native code]
}, get onmozfullscreenchange() {
    [native code]
}, set onmozfullscreenchange() {
    [native code]
}, get onmozfullscreenerror() {
    [native code]
}, set onmozfullscreenerror() {
    [native code]
}, get onanimationcancel() {
    [native code]
}, set onanimationcancel() {
    [native code]
}, get onanimationend() {
    [native code]
}, set onanimationend() {
    [native code]
}, get onanimationiteration() {
    [native code]
}, set onanimationiteration() {
    [native code]
}, get onanimationstart() {
    [native code]
}, set onanimationstart() {
    [native code]
}, get ontransitioncancel() {
    [native code]
}, set ontransitioncancel() {
    [native code]
}, get ontransitionend() {
    [native code]
}, set ontransitionend() {
    [native code]
}, get ontransitionrun() {
    [native code]
}, set ontransitionrun() {
    [native code]
}, get ontransitionstart() {
    [native code]
}, set ontransitionstart() {
    [native code]
}, get onwebkitanimationend() {
    [native code]
}, set onwebkitanimationend() {
    [native code]
}, get onwebkitanimationiteration() {
    [native code]
}, set onwebkitanimationiteration() {
    [native code]
}, get onwebkitanimationstart() {
    [native code]
}, set onwebkitanimationstart() {
    [native code]
}, get onwebkittransitionend() {
    [native code]
}, set onwebkittransitionend() {
    [native code]
}, get u2f() {
    [native code]
}, set u2f() {
    [native code]
}, get onerror() {
    [native code]
}, set onerror() {
    [native code]
}, get speechSynthesis() {
    [native code]
}, get onafterprint() {
    [native code]
}, set onafterprint() {
    [native code]
}, get onbeforeprint() {
    [native code]
}, set onbeforeprint() {
    [native code]
}, get onbeforeunload() {
    [native code]
}, set onbeforeunload() {
    [native code]
}, get onhashchange() {
    [native code]
}, set onhashchange() {
    [native code]
}, get onlanguagechange() {
    [native code]
}, set onlanguagechange() {
    [native code]
}, get onmessage() {
    [native code]
}, set onmessage() {
    [native code]
}, get onmessageerror() {
    [native code]
}, set onmessageerror() {
    [native code]
}, get onoffline() {
    [native code]
}, set onoffline() {
    [native code]
}, get ononline() {
    [native code]
}, set ononline() {
    [native code]
}, get onpagehide() {
    [native code]
}, set onpagehide() {
    [native code]
}, get onpageshow() {
    [native code]
}, set onpageshow() {
    [native code]
}, get onpopstate() {
    [native code]
}, set onpopstate() {
    [native code]
}, get onrejectionhandled() {
    [native code]
}, set onrejectionhandled() {
    [native code]
}, get onstorage() {
    [native code]
}, set onstorage() {
    [native code]
}, get onunhandledrejection() {
    [native code]
}, set onunhandledrejection() {
    [native code]
}, get onunload() {
    [native code]
}, set onunload() {
    [native code]
}, get ongamepadconnected() {
    [native code]
}, set ongamepadconnected() {
    [native code]
}, get ongamepaddisconnected() {
    [native code]
}, set ongamepaddisconnected() {
    [native code]
}, get localStorage() {
    [native code]
}, get origin() {
    [native code]
}, set origin() {
    [native code]
}, get crossOriginIsolated() {
    [native code]
}, get isSecureContext() {
    [native code]
}, get indexedDB() {
    [native code]
}, get caches() {
    [native code]
}, get sessionStorage() {
    [native code]
}, mozScrollSnap:function mozScrollSnap() {
    [native code]
}, openDialog:function openDialog() {
    [native code]
}, getInterface:function getInterface() {
    [native code]
}, shouldReportForServiceWorkerScope:function shouldReportForServiceWorkerScope() {
    [native code]
}, setScrollMarks:function setScrollMarks() {
    [native code]
}, get controllers() {
    [native code]
}, set controllers() {
    [native code]
}, get realFrameElement() {
    [native code]
}, get docShell() {
    [native code]
}, get browsingContext() {
    [native code]
}, get desktopToDeviceScale() {
    [native code]
}, get scrollMinX() {
    [native code]
}, get scrollMinY() {
    [native code]
}, get windowRoot() {
    [native code]
}, get windowUtils() {
    [native code]
}, get windowGlobalChild() {
    [native code]
}, get clientPrincipal() {
    [native code]
}, get isChromeWindow() {
    [native code]
}, get Glean() {
    [native code]
}, get GleanPings() {
    [native code]
}}, _options:{skipBreakpoints:false, pauseOnExceptions:false, ignoreCaughtExceptions:true, shouldShowOverlay:true, shouldIncludeSavedFrames:true, shouldIncludeAsyncLiveFrames:false, logEventBreakpoints:false, observeAsmJS:true}, _gripDepth:0, _parentClosed:false, _observingNetwork:false, _frameActors:[], _xhrBreakpoints:[], _dbg:{addDebuggees:(function() {
    for (const global of findDebuggees(this)) {
      safeAddDebuggee(this, global);
    }
  }), disable:(function() {
    dbg.removeAllDebuggees();
    dbg.onNewGlobalObject = undefined;
  }), enable:(function() {
    dbg.addDebuggees();
    dbg.onNewGlobalObject = onNewGlobalObject;
  }), onNewDebuggee:function bound _onNewDebuggee() {
    [native code]
}}, _threadLifetimePool:null, _activeEventPause:null, _pauseOverlay:null, _priorPause:null, _activeEventBreakpoints:{}, _frameActorMap:{}, _debuggerSourcesSeen:{}, _onLoadBreakpointURLs:{}, _handledFrameExceptions:{}, _watchpointsMap:{threadActor:{}, _watchpoints:{}}, breakpointActorMap:{_threadActor:{}, _actors:{}}, _nestedEventLoop:{_thread:{}, _entered:false, _resolved:false}, onNewSourceEvent:function bound onNewSourceEvent() {
    [native code]
}, createCompletionGrip:function bound createCompletionGrip() {
    [native code]
}, onDebuggerStatement:function bound onDebuggerStatement() {
    [native code]
}, onNewScript:function bound onNewScript() {
    [native code]
}, objectGrip:function bound objectGrip() {
    [native code]
}, pauseObjectGrip:function bound pauseObjectGrip() {
    [native code]
}, _onOpeningRequest:function bound _onOpeningRequest() {
    [native code]
}, _onNewDebuggee:function bound _onNewDebuggee() {
    [native code]
}, _onExceptionUnwind:function bound _onExceptionUnwind() {
    [native code]
}, _eventBreakpointListener:function bound _eventBreakpointListener() {
    [native code]
}, _onWindowReady:function bound _onWindowReady() {
    [native code]
}, _onWillNavigate:function bound _onWillNavigate() {
    [native code]
}, _onNavigate:function bound _onNavigate() {
    [native code]
}, _firstStatementBreakpoint:null, _debuggerNotificationObserver:{}, parentPool:{}, alreadyAttached:true, wrappedJSObject:{}, _shouldEmitNewSource:false, _pendingResponse:{}, [Symbol("EventEmitter/listeners")]:{}}, __poolMap:{}, _progressListener:{_targetActor:{}, _onWindowCreated:function bound () {
    [native code]
}, _onWindowHidden:function bound () {
    [native code]
}, _knownWindowIDs:{}, _watchedDocShells:{}}, _docShellsObserved:true, parentPool:{}, createdFromJsWindowActor:true, _targetScopedActorPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967319/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967319", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, _dbg:{addDebuggees:(function() {
    for (const global of findDebuggees(this)) {
      safeAddDebuggee(this, global);
    }
  }), disable:(function() {
    dbg.removeAllDebuggees();
    dbg.onNewGlobalObject = undefined;
  }), enable:(function() {
    dbg.addDebuggees();
    dbg.onNewGlobalObject = onNewGlobalObject;
  }), onNewDebuggee:function bound _onNewDebuggee() {
    [native code]
}}, _styleSheetManager:{_styleSheetCount:0, _styleSheetMap:{}, _mqlList:[], _targetActor:{}, _onApplicableStateChanged:function bound _onApplicableStateChanged() {
    [native code]
}, _onTargetActorWindowReady:function bound _onTargetActorWindowReady() {
    [native code]
}, [Symbol("EventEmitter/listeners")]:{}}, [Symbol("EventEmitter/listeners")]:{}}) ": " (new TypeError("this._targetActor.chromeEventHandler is null", "resource://devtools/server/actors/utils/stylesheets-manager.js", 868))
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 1710: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/connectors/js-window-actor/DevToolsFrameChild.jsm, line 402: InvalidStateError: JSWindowActorChild.sendAsyncMessage: JSWindowActorChild cannot send at the moment
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, 1650435517960	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "60038" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileDYKco4"
1650435518537	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileDYKco4\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:60038/devtools/browser/bff3352e-a6c6-417f-81e1-d590dfb478cb
1650435521212	Marionette	INFO	Listening on port 60043
1650435521685	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
JavaScript error: resource://gre/modules/LoginManagerParent.jsm, line 136: TypeError: gRecipeManager is null
JavaScript warning: https://gen-bizbd.com/web/content/53594-92c9dad/web.assets_backend.js, line 5051: unreachable code after return statement
SourceActor threw an exception: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:556:16
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 556, column: 16
console.error: (new Error("Failed to fetch https://gen-bizbd.com/web. Code 2152924148.", "resource://devtools/shared/DevToolsUtils.js", 556))
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 556: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
SourceActor threw an exception: [Exception... "Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]"  nsresult: "0x80470002 (NS_BASE_STREAM_CLOSED)"  location: "JS frame :: resource://devtools/shared/DevToolsUtils.js :: onResponse :: line 567"  data: no]
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:567:34
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 567, column: 0
console.error: ({})
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 567: NS_BASE_STREAM_CLOSED: Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]
console.error: (new TypeError("parent is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: parent is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

console.error: (new TypeError("parent is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: parent is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

console.error: "Error while calling actor 'pagestyle's method 'getLayout'" "node is null"
console.error: (new TypeError("node is null", "resource://devtools/server/actors/page-style.js", 1001))
console.error: (new TypeError("parent is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: parent is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

console.error: (new TypeError("container.node.targetFront is null", "resource://devtools/client/inspector/markup/markup.js", 2320))
console.error: (new TypeError("container.node.targetFront is null", "resource://devtools/client/inspector/markup/markup.js", 2320))
console.error: (new Error("Protocol error (TypeError): node is null from: server0.conn0.windowGlobal4294967299/pagestyle26 (resource://devtools/server/actors/page-style.js:1001:5)", "resource://devtools/shared/protocol/Front.js", 365))
console.error: (new TypeError("parent is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: parent is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

console.error: "Error while calling actor 'pagestyle's method 'getApplied'" "node is null"
console.error: (new TypeError("node is null", "resource://devtools/server/actors/page-style.js", 570))
console.error: "Error while calling actor 'pagestyle's method 'getLayout'" "node is null"
console.error: (new TypeError("node is null", "resource://devtools/server/actors/page-style.js", 1001))
console.error: (new Error("Protocol error (TypeError): node is null from: server0.conn0.windowGlobal4294967299/pagestyle26 (resource://devtools/server/actors/page-style.js:570:5)", "resource://devtools/shared/protocol/Front.js", 365))
console.error: (new Error("Protocol error (TypeError): node is null from: server0.conn0.windowGlobal4294967299/pagestyle26 (resource://devtools/server/actors/page-style.js:1001:5)", "resource://devtools/shared/protocol/Front.js", 365))
console.error: "Error while calling actor 'pagestyle's method 'getApplied'" "node is null"
console.error: (new TypeError("node is null", "resource://devtools/server/actors/page-style.js", 570))
console.error: (new TypeError("parent is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: parent is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

console.error: (new Error("Protocol error (TypeError): node is null from: server0.conn0.windowGlobal4294967299/pagestyle26 (resource://devtools/server/actors/page-style.js:570:5)", "resource://devtools/shared/protocol/Front.js", 365))
console.error: "Error when attaching target:" (new Error("Connection closed, pending request to server0.conn0.windowGlobal4294967331/thread1, type isAttached failed\n\nRequest stack:\nrequest@resource://devtools/shared/protocol/Front.js:292:14\ngenerateRequestMethods/</frontProto[name]@resource://devtools/shared/protocol/Front/FrontClassWithSpec.js:46:19\nattachThread@resource://devtools/client/fronts/targets/target-mixin.js:573:49\n", "resource://devtools/shared/protocol/Front.js", 106))
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
Handler function threw an exception: [Exception... "Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]"  nsresult: "0x80040111 (NS_ERROR_NOT_AVAILABLE)"  location: "JS frame :: resource://devtools/server/actors/targets/window-global.js :: watch :: line 1662"  data: no]
Stack: watch@resource://devtools/server/actors/targets/window-global.js:1662:28
_watchDocshells@resource://devtools/server/actors/targets/window-global.js:773:28
initialize/<@resource://devtools/server/actors/targets/window-global.js:346:42
exports.makeInfallible/<@resource://devtools/shared/ThreadSafeDevToolsUtils.js:103:22
Line: 1662, column: 0
console.error: ({})
console.error: "Error while calling actor 'thread's method 'isAttached'" "JSWindowActorChild.sendAsyncMessage: JSWindowActorChild cannot send at the moment"
console.error: (new InvalidStateError("JSWindowActorChild.sendAsyncMessage: JSWindowActorChild cannot send at the moment", (void 0), 402))
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
console.error: "Error when destroying StyleSheet manager for" ({notifyResourceAvailable:function bound notifyResourceAvailable() {
    [native code]
}, notifyResourceDestroyed:function bound notifyResourceDestroyed() {
    [native code]
}, notifyResourceUpdated:function bound notifyResourceUpdated() {
    [native code]
}, conn:{_prefix:"server0.conn0.windowGlobal4294967331/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967331", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {conn:{}, __poolMap:{}}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, actorID:"server0.conn0.windowGlobal4294967331/windowGlobalTarget2", _actorSpec:{typeName:"windowGlobalTarget", methods:[{name:"detach", request:{type:"detach", template:{type:"detach"}, args:[]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"ensureCSSErrorReportingEnabled", request:{type:"ensureCSSErrorReportingEnabled", template:{type:"ensureCSSErrorReportingEnabled"}, args:[]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"focus", request:{type:"focus", template:{type:"focus"}, args:[]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"goForward", request:{type:"goForward", template:{type:"goForward"}, args:[]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"goBack", request:{type:"goBack", template:{type:"goBack"}, args:[]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"reload", request:{type:"reload", template:{type:"reload", options:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["options"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"navigateTo", request:{type:"navigateTo", template:{type:"navigateTo", url:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["url"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"reconfigure", request:{type:"reconfigure", template:{type:"reconfigure", options:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["options"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"switchToFrame", request:{type:"switchToFrame", template:{type:"switchToFrame", windowId:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["windowId"]}]}, response:{template:{_type:"windowGlobalTarget.switchtoframe", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, retVal:{_type:"windowGlobalTarget.switchtoframe", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:[]}, release:(void 0), oneway:(void 0)}, {name:"listFrames", request:{type:"listFrames", template:{type:"listFrames"}, args:[]}, response:{template:{_type:"windowGlobalTarget.listframes", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, retVal:{_type:"windowGlobalTarget.listframes", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:[]}, release:(void 0), oneway:(void 0)}, {name:"listWorkers", request:{type:"listWorkers", template:{type:"listWorkers"}, args:[]}, response:{template:{_type:"windowGlobalTarget.workers", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, retVal:{_type:"windowGlobalTarget.workers", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:[]}, release:(void 0), oneway:(void 0)}, {name:"logInPage", request:{type:"logInPage", template:{type:"logInPage", text:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, category:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, flags:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["text"]}, {placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["category"]}, {placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["flags"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}], events:{}}, docShell:({}), _originalWindow:{get window() {
    [native code]
}, get document() {
    [native code]
}, get location() {
    [native code]
}, set location() {
    [native code]
}, get top() {
    [native code]
}, close:function close() {
    [native code]
}, stop:function stop() {
    [native code]
}, focus:function focus() {
    [native code]
}, blur:function blur() {
    [native code]
}, open:function open() {
    [native code]
}, alert:function alert() {
    [native code]
}, confirm:function confirm() {
    [native code]
}, prompt:function prompt() {
    [native code]
}, print:function print() {
    [native code]
}, printPreview:function printPreview() {
    [native code]
}, postMessage:function postMessage() {
    [native code]
}, captureEvents:function captureEvents() {
    [native code]
}, releaseEvents:function releaseEvents() {
    [native code]
}, getSelection:function getSelection() {
    [native code]
}, getComputedStyle:function getComputedStyle() {
    [native code]
}, matchMedia:function matchMedia() {
    [native code]
}, moveTo:function moveTo() {
    [native code]
}, moveBy:function moveBy() {
    [native code]
}, resizeTo:function resizeTo() {
    [native code]
}, resizeBy:function resizeBy() {
    [native code]
}, scroll:function scroll() {
    [native code]
}, scrollTo:function scrollTo() {
    [native code]
}, scrollBy:function scrollBy() {
    [native code]
}, getDefaultComputedStyle:function getDefaultComputedStyle() {
    [native code]
}, scrollByLines:function scrollByLines() {
    [native code]
}, scrollByPages:function scrollByPages() {
    [native code]
}, sizeToContent:function sizeToContent() {
    [native code]
}, updateCommands:function updateCommands() {
    [native code]
}, find:function find() {
    [native code]
}, dump:function dump() {
    [native code]
}, setResizable:function setResizable() {
    [native code]
}, requestIdleCallback:function requestIdleCallback() {
    [native code]
}, cancelIdleCallback:function cancelIdleCallback() {
    [native code]
}, getRegionalPrefsLocales:function getRegionalPrefsLocales() {
    [native code]
}, getWebExposedLocales:function getWebExposedLocales() {
    [native code]
}, requestAnimationFrame:function requestAnimationFrame() {
    [native code]
}, cancelAnimationFrame:function cancelAnimationFrame() {
    [native code]
}, reportError:function reportError() {
    [native code]
}, btoa:function btoa() {
    [native code]
}, atob:function atob() {
    [native code]
}, setTimeout:function setTimeout() {
    [native code]
}, clearTimeout:function clearTimeout() {
    [native code]
}, setInterval:function setInterval() {
    [native code]
}, clearInterval:function clearInterval() {
    [native code]
}, queueMicrotask:function queueMicrotask() {
    [native code]
}, createImageBitmap:function createImageBitmap() {
    [native code]
}, structuredClone:function structuredClone() {
    [native code]
}, fetch:function fetch() {
    [native code]
}, get self() {
    [native code]
}, set self() {
    [native code]
}, get name() {
    [native code]
}, set name() {
    [native code]
}, get history() {
    [native code]
}, get customElements() {
    [native code]
}, get locationbar() {
    [native code]
}, set locationbar() {
    [native code]
}, get menubar() {
    [native code]
}, set menubar() {
    [native code]
}, get personalbar() {
    [native code]
}, set personalbar() {
    [native code]
}, get scrollbars() {
    [native code]
}, set scrollbars() {
    [native code]
}, get statusbar() {
    [native code]
}, set statusbar() {
    [native code]
}, get toolbar() {
    [native code]
}, set toolbar() {
    [native code]
}, get status() {
    [native code]
}, set status() {
    [native code]
}, get closed() {
    [native code]
}, get event() {
    [native code]
}, set event() {
    [native code]
}, get frames() {
    [native code]
}, set frames() {
    [native code]
}, get length() {
    [native code]
}, set length() {
    [native code]
}, get opener() {
    [native code]
}, set opener() {
    [native code]
}, get parent() {
    [native code]
}, set parent() {
    [native code]
}, get frameElement() {
    [native code]
}, get navigator() {
    [native code]
}, get clientInformation() {
    [native code]
}, get external() {
    [native code]
}, set external() {
    [native code]
}, get screen() {
    [native code]
}, set screen() {
    [native code]
}, get innerWidth() {
    [native code]
}, set innerWidth() {
    [native code]
}, get innerHeight() {
    [native code]
}, set innerHeight() {
    [native code]
}, get scrollX() {
    [native code]
}, set scrollX() {
    [native code]
}, get pageXOffset() {
    [native code]
}, set pageXOffset() {
    [native code]
}, get scrollY() {
    [native code]
}, set scrollY() {
    [native code]
}, get pageYOffset() {
    [native code]
}, set pageYOffset() {
    [native code]
}, get screenLeft() {
    [native code]
}, set screenLeft() {
    [native code]
}, get screenTop() {
    [native code]
}, set screenTop() {
    [native code]
}, get screenX() {
    [native code]
}, set screenX() {
    [native code]
}, get screenY() {
    [native code]
}, set screenY() {
    [native code]
}, get outerWidth() {
    [native code]
}, set outerWidth() {
    [native code]
}, get outerHeight() {
    [native code]
}, set outerHeight() {
    [native code]
}, get performance() {
    [native code]
}, set performance() {
    [native code]
}, get mozInnerScreenX() {
    [native code]
}, get mozInnerScreenY() {
    [native code]
}, get devicePixelRatio() {
    [native code]
}, set devicePixelRatio() {
    [native code]
}, get scrollMaxX() {
    [native code]
}, set scrollMaxX() {
    [native code]
}, get scrollMaxY() {
    [native code]
}, set scrollMaxY() {
    [native code]
}, get fullScreen() {
    [native code]
}, set fullScreen() {
    [native code]
}, get ondevicemotion() {
    [native code]
}, set ondevicemotion() {
    [native code]
}, get ondeviceorientation() {
    [native code]
}, set ondeviceorientation() {
    [native code]
}, get onabsolutedeviceorientation() {
    [native code]
}, set onabsolutedeviceorientation() {
    [native code]
}, get InstallTrigger() {
    [native code]
}, set InstallTrigger() {
    [native code]
}, get intlUtils() {
    [native code]
}, get visualViewport() {
    [native code]
}, set visualViewport() {
    [native code]
}, get crypto() {
    [native code]
}, get onabort() {
    [native code]
}, set onabort() {
    [native code]
}, get onblur() {
    [native code]
}, set onblur() {
    [native code]
}, get onfocus() {
    [native code]
}, set onfocus() {
    [native code]
}, get onauxclick() {
    [native code]
}, set onauxclick() {
    [native code]
}, get onbeforeinput() {
    [native code]
}, set onbeforeinput() {
    [native code]
}, get oncanplay() {
    [native code]
}, set oncanplay() {
    [native code]
}, get oncanplaythrough() {
    [native code]
}, set oncanplaythrough() {
    [native code]
}, get onchange() {
    [native code]
}, set onchange() {
    [native code]
}, get onclick() {
    [native code]
}, set onclick() {
    [native code]
}, get onclose() {
    [native code]
}, set onclose() {
    [native code]
}, get oncontextmenu() {
    [native code]
}, set oncontextmenu() {
    [native code]
}, get oncuechange() {
    [native code]
}, set oncuechange() {
    [native code]
}, get ondblclick() {
    [native code]
}, set ondblclick() {
    [native code]
}, get ondrag() {
    [native code]
}, set ondrag() {
    [native code]
}, get ondragend() {
    [native code]
}, set ondragend() {
    [native code]
}, get ondragenter() {
    [native code]
}, set ondragenter() {
    [native code]
}, get ondragexit() {
    [native code]
}, set ondragexit() {
    [native code]
}, get ondragleave() {
    [native code]
}, set ondragleave() {
    [native code]
}, get ondragover() {
    [native code]
}, set ondragover() {
    [native code]
}, get ondragstart() {
    [native code]
}, set ondragstart() {
    [native code]
}, get ondrop() {
    [native code]
}, set ondrop() {
    [native code]
}, get ondurationchange() {
    [native code]
}, set ondurationchange() {
    [native code]
}, get onemptied() {
    [native code]
}, set onemptied() {
    [native code]
}, get onended() {
    [native code]
}, set onended() {
    [native code]
}, get onformdata() {
    [native code]
}, set onformdata() {
    [native code]
}, get oninput() {
    [native code]
}, set oninput() {
    [native code]
}, get oninvalid() {
    [native code]
}, set oninvalid() {
    [native code]
}, get onkeydown() {
    [native code]
}, set onkeydown() {
    [native code]
}, get onkeypress() {
    [native code]
}, set onkeypress() {
    [native code]
}, get onkeyup() {
    [native code]
}, set onkeyup() {
    [native code]
}, get onload() {
    [native code]
}, set onload() {
    [native code]
}, get onloadeddata() {
    [native code]
}, set onloadeddata() {
    [native code]
}, get onloadedmetadata() {
    [native code]
}, set onloadedmetadata() {
    [native code]
}, get onloadend() {
    [native code]
}, set onloadend() {
    [native code]
}, get onloadstart() {
    [native code]
}, set onloadstart() {
    [native code]
}, get onmousedown() {
    [native code]
}, set onmousedown() {
    [native code]
}, get onmouseenter() {
    [native code]
}, set onmouseenter() {
    [native code]
}, get onmouseleave() {
    [native code]
}, set onmouseleave() {
    [native code]
}, get onmousemove() {
    [native code]
}, set onmousemove() {
    [native code]
}, get onmouseout() {
    [native code]
}, set onmouseout() {
    [native code]
}, get onmouseover() {
    [native code]
}, set onmouseover() {
    [native code]
}, get onmouseup() {
    [native code]
}, set onmouseup() {
    [native code]
}, get onwheel() {
    [native code]
}, set onwheel() {
    [native code]
}, get onpause() {
    [native code]
}, set onpause() {
    [native code]
}, get onplay() {
    [native code]
}, set onplay() {
    [native code]
}, get onplaying() {
    [native code]
}, set onplaying() {
    [native code]
}, get onprogress() {
    [native code]
}, set onprogress() {
    [native code]
}, get onratechange() {
    [native code]
}, set onratechange() {
    [native code]
}, get onreset() {
    [native code]
}, set onreset() {
    [native code]
}, get onresize() {
    [native code]
}, set onresize() {
    [native code]
}, get onscroll() {
    [native code]
}, set onscroll() {
    [native code]
}, get onsecuritypolicyviolation() {
    [native code]
}, set onsecuritypolicyviolation() {
    [native code]
}, get onseeked() {
    [native code]
}, set onseeked() {
    [native code]
}, get onseeking() {
    [native code]
}, set onseeking() {
    [native code]
}, get onselect() {
    [native code]
}, set onselect() {
    [native code]
}, get onslotchange() {
    [native code]
}, set onslotchange() {
    [native code]
}, get onstalled() {
    [native code]
}, set onstalled() {
    [native code]
}, get onsubmit() {
    [native code]
}, set onsubmit() {
    [native code]
}, get onsuspend() {
    [native code]
}, set onsuspend() {
    [native code]
}, get ontimeupdate() {
    [native code]
}, set ontimeupdate() {
    [native code]
}, get onvolumechange() {
    [native code]
}, set onvolumechange() {
    [native code]
}, get onwaiting() {
    [native code]
}, set onwaiting() {
    [native code]
}, get onselectstart() {
    [native code]
}, set onselectstart() {
    [native code]
}, get onselectionchange() {
    [native code]
}, set onselectionchange() {
    [native code]
}, get ontoggle() {
    [native code]
}, set ontoggle() {
    [native code]
}, get onpointercancel() {
    [native code]
}, set onpointercancel() {
    [native code]
}, get onpointerdown() {
    [native code]
}, set onpointerdown() {
    [native code]
}, get onpointerup() {
    [native code]
}, set onpointerup() {
    [native code]
}, get onpointermove() {
    [native code]
}, set onpointermove() {
    [native code]
}, get onpointerout() {
    [native code]
}, set onpointerout() {
    [native code]
}, get onpointerover() {
    [native code]
}, set onpointerover() {
    [native code]
}, get onpointerenter() {
    [native code]
}, set onpointerenter() {
    [native code]
}, get onpointerleave() {
    [native code]
}, set onpointerleave() {
    [native code]
}, get ongotpointercapture() {
    [native code]
}, set ongotpointercapture() {
    [native code]
}, get onlostpointercapture() {
    [native code]
}, set onlostpointercapture() {
    [native code]
}, get onmozfullscreenchange() {
    [native code]
}, set onmozfullscreenchange() {
    [native code]
}, get onmozfullscreenerror() {
    [native code]
}, set onmozfullscreenerror() {
    [native code]
}, get onanimationcancel() {
    [native code]
}, set onanimationcancel() {
    [native code]
}, get onanimationend() {
    [native code]
}, set onanimationend() {
    [native code]
}, get onanimationiteration() {
    [native code]
}, set onanimationiteration() {
    [native code]
}, get onanimationstart() {
    [native code]
}, set onanimationstart() {
    [native code]
}, get ontransitioncancel() {
    [native code]
}, set ontransitioncancel() {
    [native code]
}, get ontransitionend() {
    [native code]
}, set ontransitionend() {
    [native code]
}, get ontransitionrun() {
    [native code]
}, set ontransitionrun() {
    [native code]
}, get ontransitionstart() {
    [native code]
}, set ontransitionstart() {
    [native code]
}, get onwebkitanimationend() {
    [native code]
}, set onwebkitanimationend() {
    [native code]
}, get onwebkitanimationiteration() {
    [native code]
}, set onwebkitanimationiteration() {
    [native code]
}, get onwebkitanimationstart() {
    [native code]
}, set onwebkitanimationstart() {
    [native code]
}, get onwebkittransitionend() {
    [native code]
}, set onwebkittransitionend() {
    [native code]
}, get u2f() {
    [native code]
}, set u2f() {
    [native code]
}, get onerror() {
    [native code]
}, set onerror() {
    [native code]
}, get speechSynthesis() {
    [native code]
}, get onafterprint() {
    [native code]
}, set onafterprint() {
    [native code]
}, get onbeforeprint() {
    [native code]
}, set onbeforeprint() {
    [native code]
}, get onbeforeunload() {
    [native code]
}, set onbeforeunload() {
    [native code]
}, get onhashchange() {
    [native code]
}, set onhashchange() {
    [native code]
}, get onlanguagechange() {
    [native code]
}, set onlanguagechange() {
    [native code]
}, get onmessage() {
    [native code]
}, set onmessage() {
    [native code]
}, get onmessageerror() {
    [native code]
}, set onmessageerror() {
    [native code]
}, get onoffline() {
    [native code]
}, set onoffline() {
    [native code]
}, get ononline() {
    [native code]
}, set ononline() {
    [native code]
}, get onpagehide() {
    [native code]
}, set onpagehide() {
    [native code]
}, get onpageshow() {
    [native code]
}, set onpageshow() {
    [native code]
}, get onpopstate() {
    [native code]
}, set onpopstate() {
    [native code]
}, get onrejectionhandled() {
    [native code]
}, set onrejectionhandled() {
    [native code]
}, get onstorage() {
    [native code]
}, set onstorage() {
    [native code]
}, get onunhandledrejection() {
    [native code]
}, set onunhandledrejection() {
    [native code]
}, get onunload() {
    [native code]
}, set onunload() {
    [native code]
}, get ongamepadconnected() {
    [native code]
}, set ongamepadconnected() {
    [native code]
}, get ongamepaddisconnected() {
    [native code]
}, set ongamepaddisconnected() {
    [native code]
}, get localStorage() {
    [native code]
}, get origin() {
    [native code]
}, set origin() {
    [native code]
}, get crossOriginIsolated() {
    [native code]
}, get isSecureContext() {
    [native code]
}, get indexedDB() {
    [native code]
}, get caches() {
    [native code]
}, get sessionStorage() {
    [native code]
}, mozScrollSnap:function mozScrollSnap() {
    [native code]
}, openDialog:function openDialog() {
    [native code]
}, getInterface:function getInterface() {
    [native code]
}, shouldReportForServiceWorkerScope:function shouldReportForServiceWorkerScope() {
    [native code]
}, setScrollMarks:function setScrollMarks() {
    [native code]
}, get controllers() {
    [native code]
}, set controllers() {
    [native code]
}, get realFrameElement() {
    [native code]
}, get docShell() {
    [native code]
}, get browsingContext() {
    [native code]
}, get desktopToDeviceScale() {
    [native code]
}, get scrollMinX() {
    [native code]
}, get scrollMinY() {
    [native code]
}, get windowRoot() {
    [native code]
}, get windowUtils() {
    [native code]
}, get windowGlobalChild() {
    [native code]
}, get clientPrincipal() {
    [native code]
}, get isChromeWindow() {
    [native code]
}, get Glean() {
    [native code]
}, get GleanPings() {
    [native code]
}}, followWindowGlobalLifeCycle:true, isTopLevelTarget:false, ignoreSubFrames:true, sessionContext:{type:"browser-element", browserId:8, isServerTargetSwitchingEnabled:true, isPopupDebuggingEnabled:false}, _extraActors:{consoleActor:{_options:{id:"devtools/server/actors/webconsole", prefix:"console", constructorName:"WebConsoleActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"consoleActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal4294967331/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967331", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"consoleActor", actorID:"server0.conn0.windowGlobal4294967331/consoleActor3", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967331/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967331", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, inspectorActor:{_options:{id:"devtools/server/actors/inspector/inspector", prefix:"inspector", constructorName:"InspectorActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"inspectorActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal4294967331/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967331", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"inspectorActor", actorID:"server0.conn0.windowGlobal4294967331/inspectorActor4", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967331/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967331", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, styleSheetsActor:{_options:{id:"devtools/server/actors/style-sheets", prefix:"styleSheets", constructorName:"StyleSheetsActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"styleSheetsActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal4294967331/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967331", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"styleSheetsActor", actorID:"server0.conn0.windowGlobal4294967331/styleSheetsActor5", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967331/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967331", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, storageActor:{_options:{id:"devtools/server/actors/storage", prefix:"storage", constructorName:"StorageActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"storageActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal4294967331/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967331", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"storageActor", actorID:"server0.conn0.windowGlobal4294967331/storageActor6", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967331/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967331", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, memoryActor:{_options:{id:"devtools/server/actors/memory", prefix:"memory", constructorName:"MemoryActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"memoryActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal4294967331/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967331", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"memoryActor", actorID:"server0.conn0.windowGlobal4294967331/memoryActor7", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967331/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967331", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, framerateActor:{_options:{id:"devtools/server/actors/framerate", prefix:"framerate", constructorName:"FramerateActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"framerateActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal4294967331/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967331", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"framerateActor", actorID:"server0.conn0.windowGlobal4294967331/framerateActor8", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967331/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967331", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, reflowActor:{_options:{id:"devtools/server/actors/reflow", prefix:"reflow", constructorName:"ReflowActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"reflowActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal4294967331/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967331", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"reflowActor", actorID:"server0.conn0.windowGlobal4294967331/reflowActor9", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967331/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967331", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, cssPropertiesActor:{_options:{id:"devtools/server/actors/css-properties", prefix:"cssProperties", constructorName:"CssPropertiesActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"cssPropertiesActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal4294967331/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967331", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"cssPropertiesActor", actorID:"server0.conn0.windowGlobal4294967331/cssPropertiesActor10", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967331/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967331", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, performanceActor:{_options:{id:"devtools/server/actors/performance", prefix:"performance", constructorName:"PerformanceActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"performanceActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal4294967331/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967331", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"performanceActor", actorID:"server0.conn0.windowGlobal4294967331/performanceActor11", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967331/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967331", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, animationsActor:{_options:{id:"devtools/server/actors/animation", prefix:"animations", constructorName:"AnimationsActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"animationsActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal4294967331/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967331", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"animationsActor", actorID:"server0.conn0.windowGlobal4294967331/animationsActor12", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967331/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967331", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, responsiveActor:{_options:{id:"devtools/server/actors/emulation/responsive", prefix:"responsive", constructorName:"ResponsiveActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"responsiveActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal4294967331/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967331", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"responsiveActor", actorID:"server0.conn0.windowGlobal4294967331/responsiveActor13", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967331/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967331", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, webExtensionInspectedWindowActor:{_options:{id:"devtools/server/actors/addon/webextension-inspected-window", prefix:"webExtensionInspectedWindow", constructorName:"WebExtensionInspectedWindowActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"webExtensionInspectedWindowActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal4294967331/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967331", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"webExtensionInspectedWindowActor", actorID:"server0.conn0.windowGlobal4294967331/webExtensionInspectedWindowActor14", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967331/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967331", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, accessibilityActor:{_options:{id:"devtools/server/actors/accessibility/accessibility", prefix:"accessibility", constructorName:"AccessibilityActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"accessibilityActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal4294967331/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967331", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"accessibilityActor", actorID:"server0.conn0.windowGlobal4294967331/accessibilityActor15", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967331/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967331", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, changesActor:{_options:{id:"devtools/server/actors/changes", prefix:"changes", constructorName:"ChangesActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"changesActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal4294967331/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967331", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"changesActor", actorID:"server0.conn0.windowGlobal4294967331/changesActor16", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967331/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967331", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, webSocketActor:{_options:{id:"devtools/server/actors/network-monitor/websocket-actor", prefix:"webSocket", constructorName:"WebSocketActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"webSocketActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal4294967331/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967331", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"webSocketActor", actorID:"server0.conn0.windowGlobal4294967331/webSocketActor17", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967331/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967331", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, eventSourceActor:{_options:{id:"devtools/server/actors/network-monitor/eventsource-actor", prefix:"eventSource", constructorName:"EventSourceActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"eventSourceActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal4294967331/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967331", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"eventSourceActor", actorID:"server0.conn0.windowGlobal4294967331/eventSourceActor18", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967331/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967331", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, manifestActor:{_options:{id:"devtools/server/actors/manifest", prefix:"manifest", constructorName:"ManifestActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"manifestActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal4294967331/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967331", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"manifestActor", actorID:"server0.conn0.windowGlobal4294967331/manifestActor19", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967331/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967331", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, networkContentActor:{_options:{id:"devtools/server/actors/network-monitor/network-content", prefix:"networkContent", constructorName:"NetworkContentActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"networkContentActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal4294967331/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967331", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"networkContentActor", actorID:"server0.conn0.windowGlobal4294967331/networkContentActor20", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967331/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967331", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, screenshotContentActor:{_options:{id:"devtools/server/actors/screenshot-content", prefix:"screenshotContent", constructorName:"ScreenshotContentActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"screenshotContentActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal4294967331/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967331", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"screenshotContentActor", actorID:"server0.conn0.windowGlobal4294967331/screenshotContentActor21", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967331/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967331", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}}, _sourcesManager:{_thread:{conn:{_prefix:"server0.conn0.windowGlobal4294967331/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967331", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {conn:{}, __poolMap:{}}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, actorID:"server0.conn0.windowGlobal4294967331/thread1", _actorSpec:{typeName:"thread", methods:[{name:"attach", request:{type:"attach", template:{type:"attach", options:{index:0, type:{toString() {
        return "[protocol type:" + name + "]";
      }, name:"json", primitive:true, read:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}, write:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}}}}, args:[{placeholder:{index:0, type:{toString() {
        return "[protocol type:" + name + "]";
      }, name:"json", primitive:true, read:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}, write:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}}}, path:["options"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"reconfigure", request:{type:"reconfigure", template:{type:"reconfigure", options:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["options"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"resume", request:{type:"resume", template:{type:"resume", resumeLimit:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, frameActorID:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["resumeLimit"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["frameActorID"]}]}, response:{template:{_type:"nullable:json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, retVal:{_type:"nullable:json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:[]}, release:(void 0), oneway:(void 0)}, {name:"frames", request:{type:"frames", template:{type:"frames", start:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, count:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["start"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["count"]}]}, response:{template:{_type:"thread.frames", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, retVal:{_type:"thread.frames", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:[]}, release:(void 0), oneway:(void 0)}, {name:"interrupt", request:{type:"interrupt", template:{type:"interrupt", when:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["when"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"sources", request:{type:"sources", template:{type:"sources"}, args:[]}, response:{template:{sources:{_type:"array:json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, retVal:{_type:"array:json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["sources"]}, release:(void 0), oneway:(void 0)}, {name:"skipBreakpoints", request:{type:"skipBreakpoints", template:{type:"skipBreakpoints", skip:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["skip"]}]}, response:{template:{skip:{index:0, type:{toString() {
        return "[protocol type:" + name + "]";
      }, name:"json", primitive:true, read:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}, write:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}}}}}, release:(void 0), oneway:(void 0)}, {name:"dumpThread", request:{type:"dumpThread", template:{type:"dumpThread"}, args:[]}, response:{template:{_type:"json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, retVal:{_type:"json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:[]}, release:(void 0), oneway:(void 0)}, {name:"dumpPools", request:{type:"dumpPools", template:{type:"dumpPools"}, args:[]}, response:{template:{_type:"json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, retVal:{_type:"json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:[]}, release:(void 0), oneway:(void 0)}, {name:"setBreakpoint", request:{type:"setBreakpoint", template:{type:"setBreakpoint", location:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, options:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["location"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["options"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"removeBreakpoint", request:{type:"removeBreakpoint", template:{type:"removeBreakpoint", location:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["location"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"setXHRBreakpoint", request:{type:"setXHRBreakpoint", template:{type:"setXHRBreakpoint", path:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, method:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["path"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["method"]}]}, response:{template:{value:{_type:"boolean", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, retVal:{_type:"boolean", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["value"]}, release:(void 0), oneway:(void 0)}, {name:"removeXHRBreakpoint", request:{type:"removeXHRBreakpoint", template:{type:"removeXHRBreakpoint", path:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, method:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["path"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["method"]}]}, response:{template:{value:{_type:"boolean", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, retVal:{_type:"boolean", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["value"]}, release:(void 0), oneway:(void 0)}, {name:"getAvailableEventBreakpoints", request:{type:"getAvailableEventBreakpoints", template:{type:"getAvailableEventBreakpoints"}, args:[]}, response:{template:{value:{_type:"array:available-breakpoint-group", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, retVal:{_type:"array:available-breakpoint-group", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["value"]}, release:(void 0), oneway:(void 0)}, {name:"getActiveEventBreakpoints", request:{type:"getActiveEventBreakpoints", template:{type:"getActiveEventBreakpoints"}, args:[]}, response:{template:{ids:{_type:"array:string", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, retVal:{_type:"array:string", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["ids"]}, release:(void 0), oneway:(void 0)}, {name:"setActiveEventBreakpoints", request:{type:"setActiveEventBreakpoints", template:{type:"setActiveEventBreakpoints", ids:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["ids"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"pauseOnExceptions", request:{type:"pauseOnExceptions", template:{type:"pauseOnExceptions", pauseOnExceptions:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, ignoreCaughtExceptions:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["pauseOnExceptions"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["ignoreCaughtExceptions"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"toggleEventLogging", request:{type:"toggleEventLogging", template:{type:"toggleEventLogging", logEventBreakpoints:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["logEventBreakpoints"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"isAttached", request:{type:"isAttached", template:{type:"isAttached"}, args:[]}, response:{template:{value:{_type:"boolean", type:{toString() {
        return "[protocol type:" + name + "]";
      }, name:"boolean", primitive:true, read:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}, write:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}}}}, retVal:{_type:"boolean", type:{toString() {
        return "[protocol type:" + name + "]";
      }, name:"boolean", primitive:true, read:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}, write:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}}}, path:["value"]}, release:(void 0), oneway:(void 0)}], events:{}}, _state:"running", _parent:{}, global:{get window() {
    [native code]
}, get document() {
    [native code]
}, get location() {
    [native code]
}, set location() {
    [native code]
}, get top() {
    [native code]
}, close:function close() {
    [native code]
}, stop:function stop() {
    [native code]
}, focus:function focus() {
    [native code]
}, blur:function blur() {
    [native code]
}, open:function open() {
    [native code]
}, alert:function alert() {
    [native code]
}, confirm:function confirm() {
    [native code]
}, prompt:function prompt() {
    [native code]
}, print:function print() {
    [native code]
}, printPreview:function printPreview() {
    [native code]
}, postMessage:function postMessage() {
    [native code]
}, captureEvents:function captureEvents() {
    [native code]
}, releaseEvents:function releaseEvents() {
    [native code]
}, getSelection:function getSelection() {
    [native code]
}, getComputedStyle:function getComputedStyle() {
    [native code]
}, matchMedia:function matchMedia() {
    [native code]
}, moveTo:function moveTo() {
    [native code]
}, moveBy:function moveBy() {
    [native code]
}, resizeTo:function resizeTo() {
    [native code]
}, resizeBy:function resizeBy() {
    [native code]
}, scroll:function scroll() {
    [native code]
}, scrollTo:function scrollTo() {
    [native code]
}, scrollBy:function scrollBy() {
    [native code]
}, getDefaultComputedStyle:function getDefaultComputedStyle() {
    [native code]
}, scrollByLines:function scrollByLines() {
    [native code]
}, scrollByPages:function scrollByPages() {
    [native code]
}, sizeToContent:function sizeToContent() {
    [native code]
}, updateCommands:function updateCommands() {
    [native code]
}, find:function find() {
    [native code]
}, dump:function dump() {
    [native code]
}, setResizable:function setResizable() {
    [native code]
}, requestIdleCallback:function requestIdleCallback() {
    [native code]
}, cancelIdleCallback:function cancelIdleCallback() {
    [native code]
}, getRegionalPrefsLocales:function getRegionalPrefsLocales() {
    [native code]
}, getWebExposedLocales:function getWebExposedLocales() {
    [native code]
}, requestAnimationFrame:function requestAnimationFrame() {
    [native code]
}, cancelAnimationFrame:function cancelAnimationFrame() {
    [native code]
}, reportError:function reportError() {
    [native code]
}, btoa:function btoa() {
    [native code]
}, atob:function atob() {
    [native code]
}, setTimeout:function setTimeout() {
    [native code]
}, clearTimeout:function clearTimeout() {
    [native code]
}, setInterval:function setInterval() {
    [native code]
}, clearInterval:function clearInterval() {
    [native code]
}, queueMicrotask:function queueMicrotask() {
    [native code]
}, createImageBitmap:function createImageBitmap() {
    [native code]
}, structuredClone:function structuredClone() {
    [native code]
}, fetch:function fetch() {
    [native code]
}, get self() {
    [native code]
}, set self() {
    [native code]
}, get name() {
    [native code]
}, set name() {
    [native code]
}, get history() {
    [native code]
}, get customElements() {
    [native code]
}, get locationbar() {
    [native code]
}, set locationbar() {
    [native code]
}, get menubar() {
    [native code]
}, set menubar() {
    [native code]
}, get personalbar() {
    [native code]
}, set personalbar() {
    [native code]
}, get scrollbars() {
    [native code]
}, set scrollbars() {
    [native code]
}, get statusbar() {
    [native code]
}, set statusbar() {
    [native code]
}, get toolbar() {
    [native code]
}, set toolbar() {
    [native code]
}, get status() {
    [native code]
}, set status() {
    [native code]
}, get closed() {
    [native code]
}, get event() {
    [native code]
}, set event() {
    [native code]
}, get frames() {
    [native code]
}, set frames() {
    [native code]
}, get length() {
    [native code]
}, set length() {
    [native code]
}, get opener() {
    [native code]
}, set opener() {
    [native code]
}, get parent() {
    [native code]
}, set parent() {
    [native code]
}, get frameElement() {
    [native code]
}, get navigator() {
    [native code]
}, get clientInformation() {
    [native code]
}, get external() {
    [native code]
}, set external() {
    [native code]
}, get screen() {
    [native code]
}, set screen() {
    [native code]
}, get innerWidth() {
    [native code]
}, set innerWidth() {
    [native code]
}, get innerHeight() {
    [native code]
}, set innerHeight() {
    [native code]
}, get scrollX() {
    [native code]
}, set scrollX() {
    [native code]
}, get pageXOffset() {
    [native code]
}, set pageXOffset() {
    [native code]
}, get scrollY() {
    [native code]
}, set scrollY() {
    [native code]
}, get pageYOffset() {
    [native code]
}, set pageYOffset() {
    [native code]
}, get screenLeft() {
    [native code]
}, set screenLeft() {
    [native code]
}, get screenTop() {
    [native code]
}, set screenTop() {
    [native code]
}, get screenX() {
    [native code]
}, set screenX() {
    [native code]
}, get screenY() {
    [native code]
}, set screenY() {
    [native code]
}, get outerWidth() {
    [native code]
}, set outerWidth() {
    [native code]
}, get outerHeight() {
    [native code]
}, set outerHeight() {
    [native code]
}, get performance() {
    [native code]
}, set performance() {
    [native code]
}, get mozInnerScreenX() {
    [native code]
}, get mozInnerScreenY() {
    [native code]
}, get devicePixelRatio() {
    [native code]
}, set devicePixelRatio() {
    [native code]
}, get scrollMaxX() {
    [native code]
}, set scrollMaxX() {
    [native code]
}, get scrollMaxY() {
    [native code]
}, set scrollMaxY() {
    [native code]
}, get fullScreen() {
    [native code]
}, set fullScreen() {
    [native code]
}, get ondevicemotion() {
    [native code]
}, set ondevicemotion() {
    [native code]
}, get ondeviceorientation() {
    [native code]
}, set ondeviceorientation() {
    [native code]
}, get onabsolutedeviceorientation() {
    [native code]
}, set onabsolutedeviceorientation() {
    [native code]
}, get InstallTrigger() {
    [native code]
}, set InstallTrigger() {
    [native code]
}, get intlUtils() {
    [native code]
}, get visualViewport() {
    [native code]
}, set visualViewport() {
    [native code]
}, get crypto() {
    [native code]
}, get onabort() {
    [native code]
}, set onabort() {
    [native code]
}, get onblur() {
    [native code]
}, set onblur() {
    [native code]
}, get onfocus() {
    [native code]
}, set onfocus() {
    [native code]
}, get onauxclick() {
    [native code]
}, set onauxclick() {
    [native code]
}, get onbeforeinput() {
    [native code]
}, set onbeforeinput() {
    [native code]
}, get oncanplay() {
    [native code]
}, set oncanplay() {
    [native code]
}, get oncanplaythrough() {
    [native code]
}, set oncanplaythrough() {
    [native code]
}, get onchange() {
    [native code]
}, set onchange() {
    [native code]
}, get onclick() {
    [native code]
}, set onclick() {
    [native code]
}, get onclose() {
    [native code]
}, set onclose() {
    [native code]
}, get oncontextmenu() {
    [native code]
}, set oncontextmenu() {
    [native code]
}, get oncuechange() {
    [native code]
}, set oncuechange() {
    [native code]
}, get ondblclick() {
    [native code]
}, set ondblclick() {
    [native code]
}, get ondrag() {
    [native code]
}, set ondrag() {
    [native code]
}, get ondragend() {
    [native code]
}, set ondragend() {
    [native code]
}, get ondragenter() {
    [native code]
}, set ondragenter() {
    [native code]
}, get ondragexit() {
    [native code]
}, set ondragexit() {
    [native code]
}, get ondragleave() {
    [native code]
}, set ondragleave() {
    [native code]
}, get ondragover() {
    [native code]
}, set ondragover() {
    [native code]
}, get ondragstart() {
    [native code]
}, set ondragstart() {
    [native code]
}, get ondrop() {
    [native code]
}, set ondrop() {
    [native code]
}, get ondurationchange() {
    [native code]
}, set ondurationchange() {
    [native code]
}, get onemptied() {
    [native code]
}, set onemptied() {
    [native code]
}, get onended() {
    [native code]
}, set onended() {
    [native code]
}, get onformdata() {
    [native code]
}, set onformdata() {
    [native code]
}, get oninput() {
    [native code]
}, set oninput() {
    [native code]
}, get oninvalid() {
    [native code]
}, set oninvalid() {
    [native code]
}, get onkeydown() {
    [native code]
}, set onkeydown() {
    [native code]
}, get onkeypress() {
    [native code]
}, set onkeypress() {
    [native code]
}, get onkeyup() {
    [native code]
}, set onkeyup() {
    [native code]
}, get onload() {
    [native code]
}, set onload() {
    [native code]
}, get onloadeddata() {
    [native code]
}, set onloadeddata() {
    [native code]
}, get onloadedmetadata() {
    [native code]
}, set onloadedmetadata() {
    [native code]
}, get onloadend() {
    [native code]
}, set onloadend() {
    [native code]
}, get onloadstart() {
    [native code]
}, set onloadstart() {
    [native code]
}, get onmousedown() {
    [native code]
}, set onmousedown() {
    [native code]
}, get onmouseenter() {
    [native code]
}, set onmouseenter() {
    [native code]
}, get onmouseleave() {
    [native code]
}, set onmouseleave() {
    [native code]
}, get onmousemove() {
    [native code]
}, set onmousemove() {
    [native code]
}, get onmouseout() {
    [native code]
}, set onmouseout() {
    [native code]
}, get onmouseover() {
    [native code]
}, set onmouseover() {
    [native code]
}, get onmouseup() {
    [native code]
}, set onmouseup() {
    [native code]
}, get onwheel() {
    [native code]
}, set onwheel() {
    [native code]
}, get onpause() {
    [native code]
}, set onpause() {
    [native code]
}, get onplay() {
    [native code]
}, set onplay() {
    [native code]
}, get onplaying() {
    [native code]
}, set onplaying() {
    [native code]
}, get onprogress() {
    [native code]
}, set onprogress() {
    [native code]
}, get onratechange() {
    [native code]
}, set onratechange() {
    [native code]
}, get onreset() {
    [native code]
}, set onreset() {
    [native code]
}, get onresize() {
    [native code]
}, set onresize() {
    [native code]
}, get onscroll() {
    [native code]
}, set onscroll() {
    [native code]
}, get onsecuritypolicyviolation() {
    [native code]
}, set onsecuritypolicyviolation() {
    [native code]
}, get onseeked() {
    [native code]
}, set onseeked() {
    [native code]
}, get onseeking() {
    [native code]
}, set onseeking() {
    [native code]
}, get onselect() {
    [native code]
}, set onselect() {
    [native code]
}, get onslotchange() {
    [native code]
}, set onslotchange() {
    [native code]
}, get onstalled() {
    [native code]
}, set onstalled() {
    [native code]
}, get onsubmit() {
    [native code]
}, set onsubmit() {
    [native code]
}, get onsuspend() {
    [native code]
}, set onsuspend() {
    [native code]
}, get ontimeupdate() {
    [native code]
}, set ontimeupdate() {
    [native code]
}, get onvolumechange() {
    [native code]
}, set onvolumechange() {
    [native code]
}, get onwaiting() {
    [native code]
}, set onwaiting() {
    [native code]
}, get onselectstart() {
    [native code]
}, set onselectstart() {
    [native code]
}, get onselectionchange() {
    [native code]
}, set onselectionchange() {
    [native code]
}, get ontoggle() {
    [native code]
}, set ontoggle() {
    [native code]
}, get onpointercancel() {
    [native code]
}, set onpointercancel() {
    [native code]
}, get onpointerdown() {
    [native code]
}, set onpointerdown() {
    [native code]
}, get onpointerup() {
    [native code]
}, set onpointerup() {
    [native code]
}, get onpointermove() {
    [native code]
}, set onpointermove() {
    [native code]
}, get onpointerout() {
    [native code]
}, set onpointerout() {
    [native code]
}, get onpointerover() {
    [native code]
}, set onpointerover() {
    [native code]
}, get onpointerenter() {
    [native code]
}, set onpointerenter() {
    [native code]
}, get onpointerleave() {
    [native code]
}, set onpointerleave() {
    [native code]
}, get ongotpointercapture() {
    [native code]
}, set ongotpointercapture() {
    [native code]
}, get onlostpointercapture() {
    [native code]
}, set onlostpointercapture() {
    [native code]
}, get onmozfullscreenchange() {
    [native code]
}, set onmozfullscreenchange() {
    [native code]
}, get onmozfullscreenerror() {
    [native code]
}, set onmozfullscreenerror() {
    [native code]
}, get onanimationcancel() {
    [native code]
}, set onanimationcancel() {
    [native code]
}, get onanimationend() {
    [native code]
}, set onanimationend() {
    [native code]
}, get onanimationiteration() {
    [native code]
}, set onanimationiteration() {
    [native code]
}, get onanimationstart() {
    [native code]
}, set onanimationstart() {
    [native code]
}, get ontransitioncancel() {
    [native code]
}, set ontransitioncancel() {
    [native code]
}, get ontransitionend() {
    [native code]
}, set ontransitionend() {
    [native code]
}, get ontransitionrun() {
    [native code]
}, set ontransitionrun() {
    [native code]
}, get ontransitionstart() {
    [native code]
}, set ontransitionstart() {
    [native code]
}, get onwebkitanimationend() {
    [native code]
}, set onwebkitanimationend() {
    [native code]
}, get onwebkitanimationiteration() {
    [native code]
}, set onwebkitanimationiteration() {
    [native code]
}, get onwebkitanimationstart() {
    [native code]
}, set onwebkitanimationstart() {
    [native code]
}, get onwebkittransitionend() {
    [native code]
}, set onwebkittransitionend() {
    [native code]
}, get u2f() {
    [native code]
}, set u2f() {
    [native code]
}, get onerror() {
    [native code]
}, set onerror() {
    [native code]
}, get speechSynthesis() {
    [native code]
}, get onafterprint() {
    [native code]
}, set onafterprint() {
    [native code]
}, get onbeforeprint() {
    [native code]
}, set onbeforeprint() {
    [native code]
}, get onbeforeunload() {
    [native code]
}, set onbeforeunload() {
    [native code]
}, get onhashchange() {
    [native code]
}, set onhashchange() {
    [native code]
}, get onlanguagechange() {
    [native code]
}, set onlanguagechange() {
    [native code]
}, get onmessage() {
    [native code]
}, set onmessage() {
    [native code]
}, get onmessageerror() {
    [native code]
}, set onmessageerror() {
    [native code]
}, get onoffline() {
    [native code]
}, set onoffline() {
    [native code]
}, get ononline() {
    [native code]
}, set ononline() {
    [native code]
}, get onpagehide() {
    [native code]
}, set onpagehide() {
    [native code]
}, get onpageshow() {
    [native code]
}, set onpageshow() {
    [native code]
}, get onpopstate() {
    [native code]
}, set onpopstate() {
    [native code]
}, get onrejectionhandled() {
    [native code]
}, set onrejectionhandled() {
    [native code]
}, get onstorage() {
    [native code]
}, set onstorage() {
    [native code]
}, get onunhandledrejection() {
    [native code]
}, set onunhandledrejection() {
    [native code]
}, get onunload() {
    [native code]
}, set onunload() {
    [native code]
}, get ongamepadconnected() {
    [native code]
}, set ongamepadconnected() {
    [native code]
}, get ongamepaddisconnected() {
    [native code]
}, set ongamepaddisconnected() {
    [native code]
}, get localStorage() {
    [native code]
}, get origin() {
    [native code]
}, set origin() {
    [native code]
}, get crossOriginIsolated() {
    [native code]
}, get isSecureContext() {
    [native code]
}, get indexedDB() {
    [native code]
}, get caches() {
    [native code]
}, get sessionStorage() {
    [native code]
}, mozScrollSnap:function mozScrollSnap() {
    [native code]
}, openDialog:function openDialog() {
    [native code]
}, getInterface:function getInterface() {
    [native code]
}, shouldReportForServiceWorkerScope:function shouldReportForServiceWorkerScope() {
    [native code]
}, setScrollMarks:function setScrollMarks() {
    [native code]
}, get controllers() {
    [native code]
}, set controllers() {
    [native code]
}, get realFrameElement() {
    [native code]
}, get docShell() {
    [native code]
}, get browsingContext() {
    [native code]
}, get desktopToDeviceScale() {
    [native code]
}, get scrollMinX() {
    [native code]
}, get scrollMinY() {
    [native code]
}, get windowRoot() {
    [native code]
}, get windowUtils() {
    [native code]
}, get windowGlobalChild() {
    [native code]
}, get clientPrincipal() {
    [native code]
}, get isChromeWindow() {
    [native code]
}, get Glean() {
    [native code]
}, get GleanPings() {
    [native code]
}}, _options:{skipBreakpoints:false, pauseOnExceptions:false, ignoreCaughtExceptions:true, shouldShowOverlay:true, shouldIncludeSavedFrames:true, shouldIncludeAsyncLiveFrames:false, logEventBreakpoints:false, observeAsmJS:true}, _gripDepth:0, _parentClosed:false, _observingNetwork:false, _frameActors:[], _xhrBreakpoints:[], _dbg:{addDebuggees:(function() {
    for (const global of findDebuggees(this)) {
      safeAddDebuggee(this, global);
    }
  }), disable:(function() {
    dbg.removeAllDebuggees();
    dbg.onNewGlobalObject = undefined;
  }), enable:(function() {
    dbg.addDebuggees();
    dbg.onNewGlobalObject = onNewGlobalObject;
  }), onNewDebuggee:function bound _onNewDebuggee() {
    [native code]
}}, _threadLifetimePool:null, _activeEventPause:null, _pauseOverlay:null, _priorPause:null, _activeEventBreakpoints:{}, _frameActorMap:{}, _debuggerSourcesSeen:{}, _onLoadBreakpointURLs:{}, _handledFrameExceptions:{}, _watchpointsMap:{threadActor:{}, _watchpoints:{}}, breakpointActorMap:{_threadActor:{}, _actors:{}}, _nestedEventLoop:{_thread:{}, _entered:false, _resolved:false}, onNewSourceEvent:function bound onNewSourceEvent() {
    [native code]
}, createCompletionGrip:function bound createCompletionGrip() {
    [native code]
}, onDebuggerStatement:function bound onDebuggerStatement() {
    [native code]
}, onNewScript:function bound onNewScript() {
    [native code]
}, objectGrip:function bound objectGrip() {
    [native code]
}, pauseObjectGrip:function bound pauseObjectGrip() {
    [native code]
}, _onOpeningRequest:function bound _onOpeningRequest() {
    [native code]
}, _onNewDebuggee:function bound _onNewDebuggee() {
    [native code]
}, _onExceptionUnwind:function bound _onExceptionUnwind() {
    [native code]
}, _eventBreakpointListener:function bound _eventBreakpointListener() {
    [native code]
}, _onWindowReady:function bound _onWindowReady() {
    [native code]
}, _onWillNavigate:function bound _onWillNavigate() {
    [native code]
}, _onNavigate:function bound _onNavigate() {
    [native code]
}, _firstStatementBreakpoint:null, _debuggerNotificationObserver:{}, parentPool:{}, alreadyAttached:true, wrappedJSObject:{}, _shouldEmitNewSource:false, _pendingResponse:{}, [Symbol("EventEmitter/listeners")]:{}}, blackBoxedSources:{}, _sourceActors:{}, _urlContents:{}, _urlWaiters:{}, _sourcesByInternalSourceId:null, [Symbol("EventEmitter/listeners")]:{}}, _styleSheetActors:{}, _shouldAddNewGlobalAsDebuggee:function bound _shouldAddNewGlobalAsDebuggee() {
    [native code]
}, makeDebugger:function bound makeDebugger() {
    [native code]
}, watchNewDocShells:false, _isNewPerfPanelEnabled:true, _workerDescriptorActorList:null, _workerDescriptorActorPool:null, _onWorkerDescriptorActorListChanged:function bound _onWorkerDescriptorActorListChanged() {
    [native code]
}, _onConsoleApiProfilerEvent:function bound _onConsoleApiProfilerEvent() {
    [native code]
}, threadActor:{conn:{_prefix:"server0.conn0.windowGlobal4294967331/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967331", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {conn:{}, __poolMap:{}}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, actorID:"server0.conn0.windowGlobal4294967331/thread1", _actorSpec:{typeName:"thread", methods:[{name:"attach", request:{type:"attach", template:{type:"attach", options:{index:0, type:{toString() {
        return "[protocol type:" + name + "]";
      }, name:"json", primitive:true, read:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}, write:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}}}}, args:[{placeholder:{index:0, type:{toString() {
        return "[protocol type:" + name + "]";
      }, name:"json", primitive:true, read:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}, write:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}}}, path:["options"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"reconfigure", request:{type:"reconfigure", template:{type:"reconfigure", options:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["options"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"resume", request:{type:"resume", template:{type:"resume", resumeLimit:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, frameActorID:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["resumeLimit"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["frameActorID"]}]}, response:{template:{_type:"nullable:json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, retVal:{_type:"nullable:json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:[]}, release:(void 0), oneway:(void 0)}, {name:"frames", request:{type:"frames", template:{type:"frames", start:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, count:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["start"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["count"]}]}, response:{template:{_type:"thread.frames", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, retVal:{_type:"thread.frames", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:[]}, release:(void 0), oneway:(void 0)}, {name:"interrupt", request:{type:"interrupt", template:{type:"interrupt", when:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["when"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"sources", request:{type:"sources", template:{type:"sources"}, args:[]}, response:{template:{sources:{_type:"array:json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, retVal:{_type:"array:json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["sources"]}, release:(void 0), oneway:(void 0)}, {name:"skipBreakpoints", request:{type:"skipBreakpoints", template:{type:"skipBreakpoints", skip:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["skip"]}]}, response:{template:{skip:{index:0, type:{toString() {
        return "[protocol type:" + name + "]";
      }, name:"json", primitive:true, read:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}, write:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}}}}}, release:(void 0), oneway:(void 0)}, {name:"dumpThread", request:{type:"dumpThread", template:{type:"dumpThread"}, args:[]}, response:{template:{_type:"json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, retVal:{_type:"json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:[]}, release:(void 0), oneway:(void 0)}, {name:"dumpPools", request:{type:"dumpPools", template:{type:"dumpPools"}, args:[]}, response:{template:{_type:"json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, retVal:{_type:"json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:[]}, release:(void 0), oneway:(void 0)}, {name:"setBreakpoint", request:{type:"setBreakpoint", template:{type:"setBreakpoint", location:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, options:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["location"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["options"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"removeBreakpoint", request:{type:"removeBreakpoint", template:{type:"removeBreakpoint", location:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["location"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"setXHRBreakpoint", request:{type:"setXHRBreakpoint", template:{type:"setXHRBreakpoint", path:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, method:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["path"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["method"]}]}, response:{template:{value:{_type:"boolean", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, retVal:{_type:"boolean", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["value"]}, release:(void 0), oneway:(void 0)}, {name:"removeXHRBreakpoint", request:{type:"removeXHRBreakpoint", template:{type:"removeXHRBreakpoint", path:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, method:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["path"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["method"]}]}, response:{template:{value:{_type:"boolean", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, retVal:{_type:"boolean", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["value"]}, release:(void 0), oneway:(void 0)}, {name:"getAvailableEventBreakpoints", request:{type:"getAvailableEventBreakpoints", template:{type:"getAvailableEventBreakpoints"}, args:[]}, response:{template:{value:{_type:"array:available-breakpoint-group", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, retVal:{_type:"array:available-breakpoint-group", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["value"]}, release:(void 0), oneway:(void 0)}, {name:"getActiveEventBreakpoints", request:{type:"getActiveEventBreakpoints", template:{type:"getActiveEventBreakpoints"}, args:[]}, response:{template:{ids:{_type:"array:string", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, retVal:{_type:"array:string", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["ids"]}, release:(void 0), oneway:(void 0)}, {name:"setActiveEventBreakpoints", request:{type:"setActiveEventBreakpoints", template:{type:"setActiveEventBreakpoints", ids:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["ids"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"pauseOnExceptions", request:{type:"pauseOnExceptions", template:{type:"pauseOnExceptions", pauseOnExceptions:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, ignoreCaughtExceptions:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["pauseOnExceptions"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["ignoreCaughtExceptions"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"toggleEventLogging", request:{type:"toggleEventLogging", template:{type:"toggleEventLogging", logEventBreakpoints:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["logEventBreakpoints"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"isAttached", request:{type:"isAttached", template:{type:"isAttached"}, args:[]}, response:{template:{value:{_type:"boolean", type:{toString() {
        return "[protocol type:" + name + "]";
      }, name:"boolean", primitive:true, read:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}, write:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}}}}, retVal:{_type:"boolean", type:{toString() {
        return "[protocol type:" + name + "]";
      }, name:"boolean", primitive:true, read:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}, write:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}}}, path:["value"]}, release:(void 0), oneway:(void 0)}], events:{}}, _state:"running", _parent:{}, global:{get window() {
    [native code]
}, get document() {
    [native code]
}, get location() {
    [native code]
}, set location() {
    [native code]
}, get top() {
    [native code]
}, close:function close() {
    [native code]
}, stop:function stop() {
    [native code]
}, focus:function focus() {
    [native code]
}, blur:function blur() {
    [native code]
}, open:function open() {
    [native code]
}, alert:function alert() {
    [native code]
}, confirm:function confirm() {
    [native code]
}, prompt:function prompt() {
    [native code]
}, print:function print() {
    [native code]
}, printPreview:function printPreview() {
    [native code]
}, postMessage:function postMessage() {
    [native code]
}, captureEvents:function captureEvents() {
    [native code]
}, releaseEvents:function releaseEvents() {
    [native code]
}, getSelection:function getSelection() {
    [native code]
}, getComputedStyle:function getComputedStyle() {
    [native code]
}, matchMedia:function matchMedia() {
    [native code]
}, moveTo:function moveTo() {
    [native code]
}, moveBy:function moveBy() {
    [native code]
}, resizeTo:function resizeTo() {
    [native code]
}, resizeBy:function resizeBy() {
    [native code]
}, scroll:function scroll() {
    [native code]
}, scrollTo:function scrollTo() {
    [native code]
}, scrollBy:function scrollBy() {
    [native code]
}, getDefaultComputedStyle:function getDefaultComputedStyle() {
    [native code]
}, scrollByLines:function scrollByLines() {
    [native code]
}, scrollByPages:function scrollByPages() {
    [native code]
}, sizeToContent:function sizeToContent() {
    [native code]
}, updateCommands:function updateCommands() {
    [native code]
}, find:function find() {
    [native code]
}, dump:function dump() {
    [native code]
}, setResizable:function setResizable() {
    [native code]
}, requestIdleCallback:function requestIdleCallback() {
    [native code]
}, cancelIdleCallback:function cancelIdleCallback() {
    [native code]
}, getRegionalPrefsLocales:function getRegionalPrefsLocales() {
    [native code]
}, getWebExposedLocales:function getWebExposedLocales() {
    [native code]
}, requestAnimationFrame:function requestAnimationFrame() {
    [native code]
}, cancelAnimationFrame:function cancelAnimationFrame() {
    [native code]
}, reportError:function reportError() {
    [native code]
}, btoa:function btoa() {
    [native code]
}, atob:function atob() {
    [native code]
}, setTimeout:function setTimeout() {
    [native code]
}, clearTimeout:function clearTimeout() {
    [native code]
}, setInterval:function setInterval() {
    [native code]
}, clearInterval:function clearInterval() {
    [native code]
}, queueMicrotask:function queueMicrotask() {
    [native code]
}, createImageBitmap:function createImageBitmap() {
    [native code]
}, structuredClone:function structuredClone() {
    [native code]
}, fetch:function fetch() {
    [native code]
}, get self() {
    [native code]
}, set self() {
    [native code]
}, get name() {
    [native code]
}, set name() {
    [native code]
}, get history() {
    [native code]
}, get customElements() {
    [native code]
}, get locationbar() {
    [native code]
}, set locationbar() {
    [native code]
}, get menubar() {
    [native code]
}, set menubar() {
    [native code]
}, get personalbar() {
    [native code]
}, set personalbar() {
    [native code]
}, get scrollbars() {
    [native code]
}, set scrollbars() {
    [native code]
}, get statusbar() {
    [native code]
}, set statusbar() {
    [native code]
}, get toolbar() {
    [native code]
}, set toolbar() {
    [native code]
}, get status() {
    [native code]
}, set status() {
    [native code]
}, get closed() {
    [native code]
}, get event() {
    [native code]
}, set event() {
    [native code]
}, get frames() {
    [native code]
}, set frames() {
    [native code]
}, get length() {
    [native code]
}, set length() {
    [native code]
}, get opener() {
    [native code]
}, set opener() {
    [native code]
}, get parent() {
    [native code]
}, set parent() {
    [native code]
}, get frameElement() {
    [native code]
}, get navigator() {
    [native code]
}, get clientInformation() {
    [native code]
}, get external() {
    [native code]
}, set external() {
    [native code]
}, get screen() {
    [native code]
}, set screen() {
    [native code]
}, get innerWidth() {
    [native code]
}, set innerWidth() {
    [native code]
}, get innerHeight() {
    [native code]
}, set innerHeight() {
    [native code]
}, get scrollX() {
    [native code]
}, set scrollX() {
    [native code]
}, get pageXOffset() {
    [native code]
}, set pageXOffset() {
    [native code]
}, get scrollY() {
    [native code]
}, set scrollY() {
    [native code]
}, get pageYOffset() {
    [native code]
}, set pageYOffset() {
    [native code]
}, get screenLeft() {
    [native code]
}, set screenLeft() {
    [native code]
}, get screenTop() {
    [native code]
}, set screenTop() {
    [native code]
}, get screenX() {
    [native code]
}, set screenX() {
    [native code]
}, get screenY() {
    [native code]
}, set screenY() {
    [native code]
}, get outerWidth() {
    [native code]
}, set outerWidth() {
    [native code]
}, get outerHeight() {
    [native code]
}, set outerHeight() {
    [native code]
}, get performance() {
    [native code]
}, set performance() {
    [native code]
}, get mozInnerScreenX() {
    [native code]
}, get mozInnerScreenY() {
    [native code]
}, get devicePixelRatio() {
    [native code]
}, set devicePixelRatio() {
    [native code]
}, get scrollMaxX() {
    [native code]
}, set scrollMaxX() {
    [native code]
}, get scrollMaxY() {
    [native code]
}, set scrollMaxY() {
    [native code]
}, get fullScreen() {
    [native code]
}, set fullScreen() {
    [native code]
}, get ondevicemotion() {
    [native code]
}, set ondevicemotion() {
    [native code]
}, get ondeviceorientation() {
    [native code]
}, set ondeviceorientation() {
    [native code]
}, get onabsolutedeviceorientation() {
    [native code]
}, set onabsolutedeviceorientation() {
    [native code]
}, get InstallTrigger() {
    [native code]
}, set InstallTrigger() {
    [native code]
}, get intlUtils() {
    [native code]
}, get visualViewport() {
    [native code]
}, set visualViewport() {
    [native code]
}, get crypto() {
    [native code]
}, get onabort() {
    [native code]
}, set onabort() {
    [native code]
}, get onblur() {
    [native code]
}, set onblur() {
    [native code]
}, get onfocus() {
    [native code]
}, set onfocus() {
    [native code]
}, get onauxclick() {
    [native code]
}, set onauxclick() {
    [native code]
}, get onbeforeinput() {
    [native code]
}, set onbeforeinput() {
    [native code]
}, get oncanplay() {
    [native code]
}, set oncanplay() {
    [native code]
}, get oncanplaythrough() {
    [native code]
}, set oncanplaythrough() {
    [native code]
}, get onchange() {
    [native code]
}, set onchange() {
    [native code]
}, get onclick() {
    [native code]
}, set onclick() {
    [native code]
}, get onclose() {
    [native code]
}, set onclose() {
    [native code]
}, get oncontextmenu() {
    [native code]
}, set oncontextmenu() {
    [native code]
}, get oncuechange() {
    [native code]
}, set oncuechange() {
    [native code]
}, get ondblclick() {
    [native code]
}, set ondblclick() {
    [native code]
}, get ondrag() {
    [native code]
}, set ondrag() {
    [native code]
}, get ondragend() {
    [native code]
}, set ondragend() {
    [native code]
}, get ondragenter() {
    [native code]
}, set ondragenter() {
    [native code]
}, get ondragexit() {
    [native code]
}, set ondragexit() {
    [native code]
}, get ondragleave() {
    [native code]
}, set ondragleave() {
    [native code]
}, get ondragover() {
    [native code]
}, set ondragover() {
    [native code]
}, get ondragstart() {
    [native code]
}, set ondragstart() {
    [native code]
}, get ondrop() {
    [native code]
}, set ondrop() {
    [native code]
}, get ondurationchange() {
    [native code]
}, set ondurationchange() {
    [native code]
}, get onemptied() {
    [native code]
}, set onemptied() {
    [native code]
}, get onended() {
    [native code]
}, set onended() {
    [native code]
}, get onformdata() {
    [native code]
}, set onformdata() {
    [native code]
}, get oninput() {
    [native code]
}, set oninput() {
    [native code]
}, get oninvalid() {
    [native code]
}, set oninvalid() {
    [native code]
}, get onkeydown() {
    [native code]
}, set onkeydown() {
    [native code]
}, get onkeypress() {
    [native code]
}, set onkeypress() {
    [native code]
}, get onkeyup() {
    [native code]
}, set onkeyup() {
    [native code]
}, get onload() {
    [native code]
}, set onload() {
    [native code]
}, get onloadeddata() {
    [native code]
}, set onloadeddata() {
    [native code]
}, get onloadedmetadata() {
    [native code]
}, set onloadedmetadata() {
    [native code]
}, get onloadend() {
    [native code]
}, set onloadend() {
    [native code]
}, get onloadstart() {
    [native code]
}, set onloadstart() {
    [native code]
}, get onmousedown() {
    [native code]
}, set onmousedown() {
    [native code]
}, get onmouseenter() {
    [native code]
}, set onmouseenter() {
    [native code]
}, get onmouseleave() {
    [native code]
}, set onmouseleave() {
    [native code]
}, get onmousemove() {
    [native code]
}, set onmousemove() {
    [native code]
}, get onmouseout() {
    [native code]
}, set onmouseout() {
    [native code]
}, get onmouseover() {
    [native code]
}, set onmouseover() {
    [native code]
}, get onmouseup() {
    [native code]
}, set onmouseup() {
    [native code]
}, get onwheel() {
    [native code]
}, set onwheel() {
    [native code]
}, get onpause() {
    [native code]
}, set onpause() {
    [native code]
}, get onplay() {
    [native code]
}, set onplay() {
    [native code]
}, get onplaying() {
    [native code]
}, set onplaying() {
    [native code]
}, get onprogress() {
    [native code]
}, set onprogress() {
    [native code]
}, get onratechange() {
    [native code]
}, set onratechange() {
    [native code]
}, get onreset() {
    [native code]
}, set onreset() {
    [native code]
}, get onresize() {
    [native code]
}, set onresize() {
    [native code]
}, get onscroll() {
    [native code]
}, set onscroll() {
    [native code]
}, get onsecuritypolicyviolation() {
    [native code]
}, set onsecuritypolicyviolation() {
    [native code]
}, get onseeked() {
    [native code]
}, set onseeked() {
    [native code]
}, get onseeking() {
    [native code]
}, set onseeking() {
    [native code]
}, get onselect() {
    [native code]
}, set onselect() {
    [native code]
}, get onslotchange() {
    [native code]
}, set onslotchange() {
    [native code]
}, get onstalled() {
    [native code]
}, set onstalled() {
    [native code]
}, get onsubmit() {
    [native code]
}, set onsubmit() {
    [native code]
}, get onsuspend() {
    [native code]
}, set onsuspend() {
    [native code]
}, get ontimeupdate() {
    [native code]
}, set ontimeupdate() {
    [native code]
}, get onvolumechange() {
    [native code]
}, set onvolumechange() {
    [native code]
}, get onwaiting() {
    [native code]
}, set onwaiting() {
    [native code]
}, get onselectstart() {
    [native code]
}, set onselectstart() {
    [native code]
}, get onselectionchange() {
    [native code]
}, set onselectionchange() {
    [native code]
}, get ontoggle() {
    [native code]
}, set ontoggle() {
    [native code]
}, get onpointercancel() {
    [native code]
}, set onpointercancel() {
    [native code]
}, get onpointerdown() {
    [native code]
}, set onpointerdown() {
    [native code]
}, get onpointerup() {
    [native code]
}, set onpointerup() {
    [native code]
}, get onpointermove() {
    [native code]
}, set onpointermove() {
    [native code]
}, get onpointerout() {
    [native code]
}, set onpointerout() {
    [native code]
}, get onpointerover() {
    [native code]
}, set onpointerover() {
    [native code]
}, get onpointerenter() {
    [native code]
}, set onpointerenter() {
    [native code]
}, get onpointerleave() {
    [native code]
}, set onpointerleave() {
    [native code]
}, get ongotpointercapture() {
    [native code]
}, set ongotpointercapture() {
    [native code]
}, get onlostpointercapture() {
    [native code]
}, set onlostpointercapture() {
    [native code]
}, get onmozfullscreenchange() {
    [native code]
}, set onmozfullscreenchange() {
    [native code]
}, get onmozfullscreenerror() {
    [native code]
}, set onmozfullscreenerror() {
    [native code]
}, get onanimationcancel() {
    [native code]
}, set onanimationcancel() {
    [native code]
}, get onanimationend() {
    [native code]
}, set onanimationend() {
    [native code]
}, get onanimationiteration() {
    [native code]
}, set onanimationiteration() {
    [native code]
}, get onanimationstart() {
    [native code]
}, set onanimationstart() {
    [native code]
}, get ontransitioncancel() {
    [native code]
}, set ontransitioncancel() {
    [native code]
}, get ontransitionend() {
    [native code]
}, set ontransitionend() {
    [native code]
}, get ontransitionrun() {
    [native code]
}, set ontransitionrun() {
    [native code]
}, get ontransitionstart() {
    [native code]
}, set ontransitionstart() {
    [native code]
}, get onwebkitanimationend() {
    [native code]
}, set onwebkitanimationend() {
    [native code]
}, get onwebkitanimationiteration() {
    [native code]
}, set onwebkitanimationiteration() {
    [native code]
}, get onwebkitanimationstart() {
    [native code]
}, set onwebkitanimationstart() {
    [native code]
}, get onwebkittransitionend() {
    [native code]
}, set onwebkittransitionend() {
    [native code]
}, get u2f() {
    [native code]
}, set u2f() {
    [native code]
}, get onerror() {
    [native code]
}, set onerror() {
    [native code]
}, get speechSynthesis() {
    [native code]
}, get onafterprint() {
    [native code]
}, set onafterprint() {
    [native code]
}, get onbeforeprint() {
    [native code]
}, set onbeforeprint() {
    [native code]
}, get onbeforeunload() {
    [native code]
}, set onbeforeunload() {
    [native code]
}, get onhashchange() {
    [native code]
}, set onhashchange() {
    [native code]
}, get onlanguagechange() {
    [native code]
}, set onlanguagechange() {
    [native code]
}, get onmessage() {
    [native code]
}, set onmessage() {
    [native code]
}, get onmessageerror() {
    [native code]
}, set onmessageerror() {
    [native code]
}, get onoffline() {
    [native code]
}, set onoffline() {
    [native code]
}, get ononline() {
    [native code]
}, set ononline() {
    [native code]
}, get onpagehide() {
    [native code]
}, set onpagehide() {
    [native code]
}, get onpageshow() {
    [native code]
}, set onpageshow() {
    [native code]
}, get onpopstate() {
    [native code]
}, set onpopstate() {
    [native code]
}, get onrejectionhandled() {
    [native code]
}, set onrejectionhandled() {
    [native code]
}, get onstorage() {
    [native code]
}, set onstorage() {
    [native code]
}, get onunhandledrejection() {
    [native code]
}, set onunhandledrejection() {
    [native code]
}, get onunload() {
    [native code]
}, set onunload() {
    [native code]
}, get ongamepadconnected() {
    [native code]
}, set ongamepadconnected() {
    [native code]
}, get ongamepaddisconnected() {
    [native code]
}, set ongamepaddisconnected() {
    [native code]
}, get localStorage() {
    [native code]
}, get origin() {
    [native code]
}, set origin() {
    [native code]
}, get crossOriginIsolated() {
    [native code]
}, get isSecureContext() {
    [native code]
}, get indexedDB() {
    [native code]
}, get caches() {
    [native code]
}, get sessionStorage() {
    [native code]
}, mozScrollSnap:function mozScrollSnap() {
    [native code]
}, openDialog:function openDialog() {
    [native code]
}, getInterface:function getInterface() {
    [native code]
}, shouldReportForServiceWorkerScope:function shouldReportForServiceWorkerScope() {
    [native code]
}, setScrollMarks:function setScrollMarks() {
    [native code]
}, get controllers() {
    [native code]
}, set controllers() {
    [native code]
}, get realFrameElement() {
    [native code]
}, get docShell() {
    [native code]
}, get browsingContext() {
    [native code]
}, get desktopToDeviceScale() {
    [native code]
}, get scrollMinX() {
    [native code]
}, get scrollMinY() {
    [native code]
}, get windowRoot() {
    [native code]
}, get windowUtils() {
    [native code]
}, get windowGlobalChild() {
    [native code]
}, get clientPrincipal() {
    [native code]
}, get isChromeWindow() {
    [native code]
}, get Glean() {
    [native code]
}, get GleanPings() {
    [native code]
}}, _options:{skipBreakpoints:false, pauseOnExceptions:false, ignoreCaughtExceptions:true, shouldShowOverlay:true, shouldIncludeSavedFrames:true, shouldIncludeAsyncLiveFrames:false, logEventBreakpoints:false, observeAsmJS:true}, _gripDepth:0, _parentClosed:false, _observingNetwork:false, _frameActors:[], _xhrBreakpoints:[], _dbg:{addDebuggees:(function() {
    for (const global of findDebuggees(this)) {
      safeAddDebuggee(this, global);
    }
  }), disable:(function() {
    dbg.removeAllDebuggees();
    dbg.onNewGlobalObject = undefined;
  }), enable:(function() {
    dbg.addDebuggees();
    dbg.onNewGlobalObject = onNewGlobalObject;
  }), onNewDebuggee:function bound _onNewDebuggee() {
    [native code]
}}, _threadLifetimePool:null, _activeEventPause:null, _pauseOverlay:null, _priorPause:null, _activeEventBreakpoints:{}, _frameActorMap:{}, _debuggerSourcesSeen:{}, _onLoadBreakpointURLs:{}, _handledFrameExceptions:{}, _watchpointsMap:{threadActor:{}, _watchpoints:{}}, breakpointActorMap:{_threadActor:{}, _actors:{}}, _nestedEventLoop:{_thread:{}, _entered:false, _resolved:false}, onNewSourceEvent:function bound onNewSourceEvent() {
    [native code]
}, createCompletionGrip:function bound createCompletionGrip() {
    [native code]
}, onDebuggerStatement:function bound onDebuggerStatement() {
    [native code]
}, onNewScript:function bound onNewScript() {
    [native code]
}, objectGrip:function bound objectGrip() {
    [native code]
}, pauseObjectGrip:function bound pauseObjectGrip() {
    [native code]
}, _onOpeningRequest:function bound _onOpeningRequest() {
    [native code]
}, _onNewDebuggee:function bound _onNewDebuggee() {
    [native code]
}, _onExceptionUnwind:function bound _onExceptionUnwind() {
    [native code]
}, _eventBreakpointListener:function bound _eventBreakpointListener() {
    [native code]
}, _onWindowReady:function bound _onWindowReady() {
    [native code]
}, _onWillNavigate:function bound _onWillNavigate() {
    [native code]
}, _onNavigate:function bound _onNavigate() {
    [native code]
}, _firstStatementBreakpoint:null, _debuggerNotificationObserver:{}, parentPool:{}, alreadyAttached:true, wrappedJSObject:{}, _shouldEmitNewSource:false, _pendingResponse:{}, [Symbol("EventEmitter/listeners")]:{}}, __poolMap:{}, _progressListener:{_targetActor:{}, _onWindowCreated:function bound () {
    [native code]
}, _onWindowHidden:function bound () {
    [native code]
}, _knownWindowIDs:{}, _watchedDocShells:{}}, _docShellsObserved:true, parentPool:{}, createdFromJsWindowActor:true, _targetScopedActorPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967331/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967331", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, _dbg:{addDebuggees:(function() {
    for (const global of findDebuggees(this)) {
      safeAddDebuggee(this, global);
    }
  }), disable:(function() {
    dbg.removeAllDebuggees();
    dbg.onNewGlobalObject = undefined;
  }), enable:(function() {
    dbg.addDebuggees();
    dbg.onNewGlobalObject = onNewGlobalObject;
  }), onNewDebuggee:function bound _onNewDebuggee() {
    [native code]
}}, _styleSheetManager:{_styleSheetCount:0, _styleSheetMap:{}, _mqlList:[], _targetActor:{}, _onApplicableStateChanged:function bound _onApplicableStateChanged() {
    [native code]
}, _onTargetActorWindowReady:function bound _onTargetActorWindowReady() {
    [native code]
}, [Symbol("EventEmitter/listeners")]:{}}, [Symbol("EventEmitter/listeners")]:{}}) ": " (new TypeError("this._targetActor.chromeEventHandler is null", "resource://devtools/server/actors/utils/stylesheets-manager.js", 868))
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 1710: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/connectors/js-window-actor/DevToolsFrameChild.jsm, line 402: InvalidStateError: JSWindowActorChild.sendAsyncMessage: JSWindowActorChild cannot send at the moment
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 420: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 420: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, 1650436001951	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "54342" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileNjcfER"
1650436002606	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileNjcfER\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:54342/devtools/browser/643f1648-0bb0-4fd7-b642-0f9576224725
1650436005117	Marionette	INFO	Listening on port 54348
1650436005278	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
JavaScript error: resource://gre/modules/LoginManagerParent.jsm, line 136: TypeError: gRecipeManager is null
JavaScript warning: https://gen-bizbd.com/web/content/53594-92c9dad/web.assets_backend.js, line 5051: unreachable code after return statement
SourceActor threw an exception: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:556:16
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 556, column: 16
console.error: (new Error("Failed to fetch https://gen-bizbd.com/web. Code 2152924148.", "resource://devtools/shared/DevToolsUtils.js", 556))
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 556: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
SourceActor threw an exception: [Exception... "Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]"  nsresult: "0x80470002 (NS_BASE_STREAM_CLOSED)"  location: "JS frame :: resource://devtools/shared/DevToolsUtils.js :: onResponse :: line 567"  data: no]
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:567:34
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 567, column: 0
console.error: ({})
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 567: NS_BASE_STREAM_CLOSED: Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]
console.error: "Error when attaching target:" (new Error("Connection closed, pending request to server0.conn0.windowGlobal4294967333/thread1, type isAttached failed\n\nRequest stack:\nrequest@resource://devtools/shared/protocol/Front.js:292:14\ngenerateRequestMethods/</frontProto[name]@resource://devtools/shared/protocol/Front/FrontClassWithSpec.js:46:19\nattachThread@resource://devtools/client/fronts/targets/target-mixin.js:573:49\n", "resource://devtools/shared/protocol/Front.js", 106))
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
Handler function threw an exception: [Exception... "Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]"  nsresult: "0x80040111 (NS_ERROR_NOT_AVAILABLE)"  location: "JS frame :: resource://devtools/server/actors/targets/window-global.js :: watch :: line 1662"  data: no]
Stack: watch@resource://devtools/server/actors/targets/window-global.js:1662:28
_watchDocshells@resource://devtools/server/actors/targets/window-global.js:773:28
initialize/<@resource://devtools/server/actors/targets/window-global.js:346:42
exports.makeInfallible/<@resource://devtools/shared/ThreadSafeDevToolsUtils.js:103:22
Line: 1662, column: 0
console.error: ({})
console.error: "Error while calling actor 'thread's method 'isAttached'" "JSWindowActorChild.sendAsyncMessage: JSWindowActorChild cannot send at the moment"
console.error: (new InvalidStateError("JSWindowActorChild.sendAsyncMessage: JSWindowActorChild cannot send at the moment", (void 0), 402))
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
console.error: "Error when destroying StyleSheet manager for" ({notifyResourceAvailable:function bound notifyResourceAvailable() {
    [native code]
}, notifyResourceDestroyed:function bound notifyResourceDestroyed() {
    [native code]
}, notifyResourceUpdated:function bound notifyResourceUpdated() {
    [native code]
}, conn:{_prefix:"server0.conn0.windowGlobal4294967333/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967333", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {conn:{}, __poolMap:{}}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, actorID:"server0.conn0.windowGlobal4294967333/windowGlobalTarget2", _actorSpec:{typeName:"windowGlobalTarget", methods:[{name:"detach", request:{type:"detach", template:{type:"detach"}, args:[]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"ensureCSSErrorReportingEnabled", request:{type:"ensureCSSErrorReportingEnabled", template:{type:"ensureCSSErrorReportingEnabled"}, args:[]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"focus", request:{type:"focus", template:{type:"focus"}, args:[]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"goForward", request:{type:"goForward", template:{type:"goForward"}, args:[]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"goBack", request:{type:"goBack", template:{type:"goBack"}, args:[]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"reload", request:{type:"reload", template:{type:"reload", options:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["options"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"navigateTo", request:{type:"navigateTo", template:{type:"navigateTo", url:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["url"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"reconfigure", request:{type:"reconfigure", template:{type:"reconfigure", options:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["options"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"switchToFrame", request:{type:"switchToFrame", template:{type:"switchToFrame", windowId:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["windowId"]}]}, response:{template:{_type:"windowGlobalTarget.switchtoframe", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, retVal:{_type:"windowGlobalTarget.switchtoframe", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:[]}, release:(void 0), oneway:(void 0)}, {name:"listFrames", request:{type:"listFrames", template:{type:"listFrames"}, args:[]}, response:{template:{_type:"windowGlobalTarget.listframes", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, retVal:{_type:"windowGlobalTarget.listframes", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:[]}, release:(void 0), oneway:(void 0)}, {name:"listWorkers", request:{type:"listWorkers", template:{type:"listWorkers"}, args:[]}, response:{template:{_type:"windowGlobalTarget.workers", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, retVal:{_type:"windowGlobalTarget.workers", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:[]}, release:(void 0), oneway:(void 0)}, {name:"logInPage", request:{type:"logInPage", template:{type:"logInPage", text:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, category:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, flags:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["text"]}, {placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["category"]}, {placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["flags"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}], events:{}}, docShell:({}), _originalWindow:{get window() {
    [native code]
}, get document() {
    [native code]
}, get location() {
    [native code]
}, set location() {
    [native code]
}, get top() {
    [native code]
}, close:function close() {
    [native code]
}, stop:function stop() {
    [native code]
}, focus:function focus() {
    [native code]
}, blur:function blur() {
    [native code]
}, open:function open() {
    [native code]
}, alert:function alert() {
    [native code]
}, confirm:function confirm() {
    [native code]
}, prompt:function prompt() {
    [native code]
}, print:function print() {
    [native code]
}, printPreview:function printPreview() {
    [native code]
}, postMessage:function postMessage() {
    [native code]
}, captureEvents:function captureEvents() {
    [native code]
}, releaseEvents:function releaseEvents() {
    [native code]
}, getSelection:function getSelection() {
    [native code]
}, getComputedStyle:function getComputedStyle() {
    [native code]
}, matchMedia:function matchMedia() {
    [native code]
}, moveTo:function moveTo() {
    [native code]
}, moveBy:function moveBy() {
    [native code]
}, resizeTo:function resizeTo() {
    [native code]
}, resizeBy:function resizeBy() {
    [native code]
}, scroll:function scroll() {
    [native code]
}, scrollTo:function scrollTo() {
    [native code]
}, scrollBy:function scrollBy() {
    [native code]
}, getDefaultComputedStyle:function getDefaultComputedStyle() {
    [native code]
}, scrollByLines:function scrollByLines() {
    [native code]
}, scrollByPages:function scrollByPages() {
    [native code]
}, sizeToContent:function sizeToContent() {
    [native code]
}, updateCommands:function updateCommands() {
    [native code]
}, find:function find() {
    [native code]
}, dump:function dump() {
    [native code]
}, setResizable:function setResizable() {
    [native code]
}, requestIdleCallback:function requestIdleCallback() {
    [native code]
}, cancelIdleCallback:function cancelIdleCallback() {
    [native code]
}, getRegionalPrefsLocales:function getRegionalPrefsLocales() {
    [native code]
}, getWebExposedLocales:function getWebExposedLocales() {
    [native code]
}, requestAnimationFrame:function requestAnimationFrame() {
    [native code]
}, cancelAnimationFrame:function cancelAnimationFrame() {
    [native code]
}, reportError:function reportError() {
    [native code]
}, btoa:function btoa() {
    [native code]
}, atob:function atob() {
    [native code]
}, setTimeout:function setTimeout() {
    [native code]
}, clearTimeout:function clearTimeout() {
    [native code]
}, setInterval:function setInterval() {
    [native code]
}, clearInterval:function clearInterval() {
    [native code]
}, queueMicrotask:function queueMicrotask() {
    [native code]
}, createImageBitmap:function createImageBitmap() {
    [native code]
}, structuredClone:function structuredClone() {
    [native code]
}, fetch:function fetch() {
    [native code]
}, get self() {
    [native code]
}, set self() {
    [native code]
}, get name() {
    [native code]
}, set name() {
    [native code]
}, get history() {
    [native code]
}, get customElements() {
    [native code]
}, get locationbar() {
    [native code]
}, set locationbar() {
    [native code]
}, get menubar() {
    [native code]
}, set menubar() {
    [native code]
}, get personalbar() {
    [native code]
}, set personalbar() {
    [native code]
}, get scrollbars() {
    [native code]
}, set scrollbars() {
    [native code]
}, get statusbar() {
    [native code]
}, set statusbar() {
    [native code]
}, get toolbar() {
    [native code]
}, set toolbar() {
    [native code]
}, get status() {
    [native code]
}, set status() {
    [native code]
}, get closed() {
    [native code]
}, get event() {
    [native code]
}, set event() {
    [native code]
}, get frames() {
    [native code]
}, set frames() {
    [native code]
}, get length() {
    [native code]
}, set length() {
    [native code]
}, get opener() {
    [native code]
}, set opener() {
    [native code]
}, get parent() {
    [native code]
}, set parent() {
    [native code]
}, get frameElement() {
    [native code]
}, get navigator() {
    [native code]
}, get clientInformation() {
    [native code]
}, get external() {
    [native code]
}, set external() {
    [native code]
}, get screen() {
    [native code]
}, set screen() {
    [native code]
}, get innerWidth() {
    [native code]
}, set innerWidth() {
    [native code]
}, get innerHeight() {
    [native code]
}, set innerHeight() {
    [native code]
}, get scrollX() {
    [native code]
}, set scrollX() {
    [native code]
}, get pageXOffset() {
    [native code]
}, set pageXOffset() {
    [native code]
}, get scrollY() {
    [native code]
}, set scrollY() {
    [native code]
}, get pageYOffset() {
    [native code]
}, set pageYOffset() {
    [native code]
}, get screenLeft() {
    [native code]
}, set screenLeft() {
    [native code]
}, get screenTop() {
    [native code]
}, set screenTop() {
    [native code]
}, get screenX() {
    [native code]
}, set screenX() {
    [native code]
}, get screenY() {
    [native code]
}, set screenY() {
    [native code]
}, get outerWidth() {
    [native code]
}, set outerWidth() {
    [native code]
}, get outerHeight() {
    [native code]
}, set outerHeight() {
    [native code]
}, get performance() {
    [native code]
}, set performance() {
    [native code]
}, get mozInnerScreenX() {
    [native code]
}, get mozInnerScreenY() {
    [native code]
}, get devicePixelRatio() {
    [native code]
}, set devicePixelRatio() {
    [native code]
}, get scrollMaxX() {
    [native code]
}, set scrollMaxX() {
    [native code]
}, get scrollMaxY() {
    [native code]
}, set scrollMaxY() {
    [native code]
}, get fullScreen() {
    [native code]
}, set fullScreen() {
    [native code]
}, get ondevicemotion() {
    [native code]
}, set ondevicemotion() {
    [native code]
}, get ondeviceorientation() {
    [native code]
}, set ondeviceorientation() {
    [native code]
}, get onabsolutedeviceorientation() {
    [native code]
}, set onabsolutedeviceorientation() {
    [native code]
}, get InstallTrigger() {
    [native code]
}, set InstallTrigger() {
    [native code]
}, get intlUtils() {
    [native code]
}, get visualViewport() {
    [native code]
}, set visualViewport() {
    [native code]
}, get crypto() {
    [native code]
}, get onabort() {
    [native code]
}, set onabort() {
    [native code]
}, get onblur() {
    [native code]
}, set onblur() {
    [native code]
}, get onfocus() {
    [native code]
}, set onfocus() {
    [native code]
}, get onauxclick() {
    [native code]
}, set onauxclick() {
    [native code]
}, get onbeforeinput() {
    [native code]
}, set onbeforeinput() {
    [native code]
}, get oncanplay() {
    [native code]
}, set oncanplay() {
    [native code]
}, get oncanplaythrough() {
    [native code]
}, set oncanplaythrough() {
    [native code]
}, get onchange() {
    [native code]
}, set onchange() {
    [native code]
}, get onclick() {
    [native code]
}, set onclick() {
    [native code]
}, get onclose() {
    [native code]
}, set onclose() {
    [native code]
}, get oncontextmenu() {
    [native code]
}, set oncontextmenu() {
    [native code]
}, get oncuechange() {
    [native code]
}, set oncuechange() {
    [native code]
}, get ondblclick() {
    [native code]
}, set ondblclick() {
    [native code]
}, get ondrag() {
    [native code]
}, set ondrag() {
    [native code]
}, get ondragend() {
    [native code]
}, set ondragend() {
    [native code]
}, get ondragenter() {
    [native code]
}, set ondragenter() {
    [native code]
}, get ondragexit() {
    [native code]
}, set ondragexit() {
    [native code]
}, get ondragleave() {
    [native code]
}, set ondragleave() {
    [native code]
}, get ondragover() {
    [native code]
}, set ondragover() {
    [native code]
}, get ondragstart() {
    [native code]
}, set ondragstart() {
    [native code]
}, get ondrop() {
    [native code]
}, set ondrop() {
    [native code]
}, get ondurationchange() {
    [native code]
}, set ondurationchange() {
    [native code]
}, get onemptied() {
    [native code]
}, set onemptied() {
    [native code]
}, get onended() {
    [native code]
}, set onended() {
    [native code]
}, get onformdata() {
    [native code]
}, set onformdata() {
    [native code]
}, get oninput() {
    [native code]
}, set oninput() {
    [native code]
}, get oninvalid() {
    [native code]
}, set oninvalid() {
    [native code]
}, get onkeydown() {
    [native code]
}, set onkeydown() {
    [native code]
}, get onkeypress() {
    [native code]
}, set onkeypress() {
    [native code]
}, get onkeyup() {
    [native code]
}, set onkeyup() {
    [native code]
}, get onload() {
    [native code]
}, set onload() {
    [native code]
}, get onloadeddata() {
    [native code]
}, set onloadeddata() {
    [native code]
}, get onloadedmetadata() {
    [native code]
}, set onloadedmetadata() {
    [native code]
}, get onloadend() {
    [native code]
}, set onloadend() {
    [native code]
}, get onloadstart() {
    [native code]
}, set onloadstart() {
    [native code]
}, get onmousedown() {
    [native code]
}, set onmousedown() {
    [native code]
}, get onmouseenter() {
    [native code]
}, set onmouseenter() {
    [native code]
}, get onmouseleave() {
    [native code]
}, set onmouseleave() {
    [native code]
}, get onmousemove() {
    [native code]
}, set onmousemove() {
    [native code]
}, get onmouseout() {
    [native code]
}, set onmouseout() {
    [native code]
}, get onmouseover() {
    [native code]
}, set onmouseover() {
    [native code]
}, get onmouseup() {
    [native code]
}, set onmouseup() {
    [native code]
}, get onwheel() {
    [native code]
}, set onwheel() {
    [native code]
}, get onpause() {
    [native code]
}, set onpause() {
    [native code]
}, get onplay() {
    [native code]
}, set onplay() {
    [native code]
}, get onplaying() {
    [native code]
}, set onplaying() {
    [native code]
}, get onprogress() {
    [native code]
}, set onprogress() {
    [native code]
}, get onratechange() {
    [native code]
}, set onratechange() {
    [native code]
}, get onreset() {
    [native code]
}, set onreset() {
    [native code]
}, get onresize() {
    [native code]
}, set onresize() {
    [native code]
}, get onscroll() {
    [native code]
}, set onscroll() {
    [native code]
}, get onsecuritypolicyviolation() {
    [native code]
}, set onsecuritypolicyviolation() {
    [native code]
}, get onseeked() {
    [native code]
}, set onseeked() {
    [native code]
}, get onseeking() {
    [native code]
}, set onseeking() {
    [native code]
}, get onselect() {
    [native code]
}, set onselect() {
    [native code]
}, get onslotchange() {
    [native code]
}, set onslotchange() {
    [native code]
}, get onstalled() {
    [native code]
}, set onstalled() {
    [native code]
}, get onsubmit() {
    [native code]
}, set onsubmit() {
    [native code]
}, get onsuspend() {
    [native code]
}, set onsuspend() {
    [native code]
}, get ontimeupdate() {
    [native code]
}, set ontimeupdate() {
    [native code]
}, get onvolumechange() {
    [native code]
}, set onvolumechange() {
    [native code]
}, get onwaiting() {
    [native code]
}, set onwaiting() {
    [native code]
}, get onselectstart() {
    [native code]
}, set onselectstart() {
    [native code]
}, get onselectionchange() {
    [native code]
}, set onselectionchange() {
    [native code]
}, get ontoggle() {
    [native code]
}, set ontoggle() {
    [native code]
}, get onpointercancel() {
    [native code]
}, set onpointercancel() {
    [native code]
}, get onpointerdown() {
    [native code]
}, set onpointerdown() {
    [native code]
}, get onpointerup() {
    [native code]
}, set onpointerup() {
    [native code]
}, get onpointermove() {
    [native code]
}, set onpointermove() {
    [native code]
}, get onpointerout() {
    [native code]
}, set onpointerout() {
    [native code]
}, get onpointerover() {
    [native code]
}, set onpointerover() {
    [native code]
}, get onpointerenter() {
    [native code]
}, set onpointerenter() {
    [native code]
}, get onpointerleave() {
    [native code]
}, set onpointerleave() {
    [native code]
}, get ongotpointercapture() {
    [native code]
}, set ongotpointercapture() {
    [native code]
}, get onlostpointercapture() {
    [native code]
}, set onlostpointercapture() {
    [native code]
}, get onmozfullscreenchange() {
    [native code]
}, set onmozfullscreenchange() {
    [native code]
}, get onmozfullscreenerror() {
    [native code]
}, set onmozfullscreenerror() {
    [native code]
}, get onanimationcancel() {
    [native code]
}, set onanimationcancel() {
    [native code]
}, get onanimationend() {
    [native code]
}, set onanimationend() {
    [native code]
}, get onanimationiteration() {
    [native code]
}, set onanimationiteration() {
    [native code]
}, get onanimationstart() {
    [native code]
}, set onanimationstart() {
    [native code]
}, get ontransitioncancel() {
    [native code]
}, set ontransitioncancel() {
    [native code]
}, get ontransitionend() {
    [native code]
}, set ontransitionend() {
    [native code]
}, get ontransitionrun() {
    [native code]
}, set ontransitionrun() {
    [native code]
}, get ontransitionstart() {
    [native code]
}, set ontransitionstart() {
    [native code]
}, get onwebkitanimationend() {
    [native code]
}, set onwebkitanimationend() {
    [native code]
}, get onwebkitanimationiteration() {
    [native code]
}, set onwebkitanimationiteration() {
    [native code]
}, get onwebkitanimationstart() {
    [native code]
}, set onwebkitanimationstart() {
    [native code]
}, get onwebkittransitionend() {
    [native code]
}, set onwebkittransitionend() {
    [native code]
}, get u2f() {
    [native code]
}, set u2f() {
    [native code]
}, get onerror() {
    [native code]
}, set onerror() {
    [native code]
}, get speechSynthesis() {
    [native code]
}, get onafterprint() {
    [native code]
}, set onafterprint() {
    [native code]
}, get onbeforeprint() {
    [native code]
}, set onbeforeprint() {
    [native code]
}, get onbeforeunload() {
    [native code]
}, set onbeforeunload() {
    [native code]
}, get onhashchange() {
    [native code]
}, set onhashchange() {
    [native code]
}, get onlanguagechange() {
    [native code]
}, set onlanguagechange() {
    [native code]
}, get onmessage() {
    [native code]
}, set onmessage() {
    [native code]
}, get onmessageerror() {
    [native code]
}, set onmessageerror() {
    [native code]
}, get onoffline() {
    [native code]
}, set onoffline() {
    [native code]
}, get ononline() {
    [native code]
}, set ononline() {
    [native code]
}, get onpagehide() {
    [native code]
}, set onpagehide() {
    [native code]
}, get onpageshow() {
    [native code]
}, set onpageshow() {
    [native code]
}, get onpopstate() {
    [native code]
}, set onpopstate() {
    [native code]
}, get onrejectionhandled() {
    [native code]
}, set onrejectionhandled() {
    [native code]
}, get onstorage() {
    [native code]
}, set onstorage() {
    [native code]
}, get onunhandledrejection() {
    [native code]
}, set onunhandledrejection() {
    [native code]
}, get onunload() {
    [native code]
}, set onunload() {
    [native code]
}, get ongamepadconnected() {
    [native code]
}, set ongamepadconnected() {
    [native code]
}, get ongamepaddisconnected() {
    [native code]
}, set ongamepaddisconnected() {
    [native code]
}, get localStorage() {
    [native code]
}, get origin() {
    [native code]
}, set origin() {
    [native code]
}, get crossOriginIsolated() {
    [native code]
}, get isSecureContext() {
    [native code]
}, get indexedDB() {
    [native code]
}, get caches() {
    [native code]
}, get sessionStorage() {
    [native code]
}, mozScrollSnap:function mozScrollSnap() {
    [native code]
}, openDialog:function openDialog() {
    [native code]
}, getInterface:function getInterface() {
    [native code]
}, shouldReportForServiceWorkerScope:function shouldReportForServiceWorkerScope() {
    [native code]
}, setScrollMarks:function setScrollMarks() {
    [native code]
}, get controllers() {
    [native code]
}, set controllers() {
    [native code]
}, get realFrameElement() {
    [native code]
}, get docShell() {
    [native code]
}, get browsingContext() {
    [native code]
}, get desktopToDeviceScale() {
    [native code]
}, get scrollMinX() {
    [native code]
}, get scrollMinY() {
    [native code]
}, get windowRoot() {
    [native code]
}, get windowUtils() {
    [native code]
}, get windowGlobalChild() {
    [native code]
}, get clientPrincipal() {
    [native code]
}, get isChromeWindow() {
    [native code]
}, get Glean() {
    [native code]
}, get GleanPings() {
    [native code]
}}, followWindowGlobalLifeCycle:true, isTopLevelTarget:false, ignoreSubFrames:true, sessionContext:{type:"browser-element", browserId:8, isServerTargetSwitchingEnabled:true, isPopupDebuggingEnabled:false}, _extraActors:{consoleActor:{_options:{id:"devtools/server/actors/webconsole", prefix:"console", constructorName:"WebConsoleActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"consoleActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal4294967333/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967333", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"consoleActor", actorID:"server0.conn0.windowGlobal4294967333/consoleActor3", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967333/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967333", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, inspectorActor:{_options:{id:"devtools/server/actors/inspector/inspector", prefix:"inspector", constructorName:"InspectorActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"inspectorActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal4294967333/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967333", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"inspectorActor", actorID:"server0.conn0.windowGlobal4294967333/inspectorActor4", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967333/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967333", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, styleSheetsActor:{_options:{id:"devtools/server/actors/style-sheets", prefix:"styleSheets", constructorName:"StyleSheetsActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"styleSheetsActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal4294967333/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967333", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"styleSheetsActor", actorID:"server0.conn0.windowGlobal4294967333/styleSheetsActor5", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967333/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967333", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, storageActor:{_options:{id:"devtools/server/actors/storage", prefix:"storage", constructorName:"StorageActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"storageActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal4294967333/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967333", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"storageActor", actorID:"server0.conn0.windowGlobal4294967333/storageActor6", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967333/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967333", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, memoryActor:{_options:{id:"devtools/server/actors/memory", prefix:"memory", constructorName:"MemoryActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"memoryActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal4294967333/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967333", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"memoryActor", actorID:"server0.conn0.windowGlobal4294967333/memoryActor7", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967333/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967333", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, framerateActor:{_options:{id:"devtools/server/actors/framerate", prefix:"framerate", constructorName:"FramerateActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"framerateActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal4294967333/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967333", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"framerateActor", actorID:"server0.conn0.windowGlobal4294967333/framerateActor8", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967333/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967333", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, reflowActor:{_options:{id:"devtools/server/actors/reflow", prefix:"reflow", constructorName:"ReflowActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"reflowActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal4294967333/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967333", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"reflowActor", actorID:"server0.conn0.windowGlobal4294967333/reflowActor9", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967333/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967333", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, cssPropertiesActor:{_options:{id:"devtools/server/actors/css-properties", prefix:"cssProperties", constructorName:"CssPropertiesActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"cssPropertiesActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal4294967333/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967333", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"cssPropertiesActor", actorID:"server0.conn0.windowGlobal4294967333/cssPropertiesActor10", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967333/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967333", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, performanceActor:{_options:{id:"devtools/server/actors/performance", prefix:"performance", constructorName:"PerformanceActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"performanceActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal4294967333/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967333", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"performanceActor", actorID:"server0.conn0.windowGlobal4294967333/performanceActor11", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967333/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967333", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, animationsActor:{_options:{id:"devtools/server/actors/animation", prefix:"animations", constructorName:"AnimationsActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"animationsActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal4294967333/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967333", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"animationsActor", actorID:"server0.conn0.windowGlobal4294967333/animationsActor12", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967333/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967333", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, responsiveActor:{_options:{id:"devtools/server/actors/emulation/responsive", prefix:"responsive", constructorName:"ResponsiveActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"responsiveActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal4294967333/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967333", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"responsiveActor", actorID:"server0.conn0.windowGlobal4294967333/responsiveActor13", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967333/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967333", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, webExtensionInspectedWindowActor:{_options:{id:"devtools/server/actors/addon/webextension-inspected-window", prefix:"webExtensionInspectedWindow", constructorName:"WebExtensionInspectedWindowActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"webExtensionInspectedWindowActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal4294967333/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967333", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"webExtensionInspectedWindowActor", actorID:"server0.conn0.windowGlobal4294967333/webExtensionInspectedWindowActor14", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967333/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967333", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, accessibilityActor:{_options:{id:"devtools/server/actors/accessibility/accessibility", prefix:"accessibility", constructorName:"AccessibilityActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"accessibilityActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal4294967333/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967333", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"accessibilityActor", actorID:"server0.conn0.windowGlobal4294967333/accessibilityActor15", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967333/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967333", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, changesActor:{_options:{id:"devtools/server/actors/changes", prefix:"changes", constructorName:"ChangesActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"changesActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal4294967333/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967333", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"changesActor", actorID:"server0.conn0.windowGlobal4294967333/changesActor16", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967333/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967333", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, webSocketActor:{_options:{id:"devtools/server/actors/network-monitor/websocket-actor", prefix:"webSocket", constructorName:"WebSocketActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"webSocketActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal4294967333/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967333", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"webSocketActor", actorID:"server0.conn0.windowGlobal4294967333/webSocketActor17", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967333/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967333", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, eventSourceActor:{_options:{id:"devtools/server/actors/network-monitor/eventsource-actor", prefix:"eventSource", constructorName:"EventSourceActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"eventSourceActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal4294967333/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967333", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"eventSourceActor", actorID:"server0.conn0.windowGlobal4294967333/eventSourceActor18", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967333/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967333", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, manifestActor:{_options:{id:"devtools/server/actors/manifest", prefix:"manifest", constructorName:"ManifestActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"manifestActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal4294967333/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967333", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"manifestActor", actorID:"server0.conn0.windowGlobal4294967333/manifestActor19", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967333/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967333", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, networkContentActor:{_options:{id:"devtools/server/actors/network-monitor/network-content", prefix:"networkContent", constructorName:"NetworkContentActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"networkContentActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal4294967333/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967333", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"networkContentActor", actorID:"server0.conn0.windowGlobal4294967333/networkContentActor20", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967333/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967333", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, screenshotContentActor:{_options:{id:"devtools/server/actors/screenshot-content", prefix:"screenshotContent", constructorName:"ScreenshotContentActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"screenshotContentActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal4294967333/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967333", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"screenshotContentActor", actorID:"server0.conn0.windowGlobal4294967333/screenshotContentActor21", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967333/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967333", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}}, _sourcesManager:{_thread:{conn:{_prefix:"server0.conn0.windowGlobal4294967333/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967333", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {conn:{}, __poolMap:{}}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, actorID:"server0.conn0.windowGlobal4294967333/thread1", _actorSpec:{typeName:"thread", methods:[{name:"attach", request:{type:"attach", template:{type:"attach", options:{index:0, type:{toString() {
        return "[protocol type:" + name + "]";
      }, name:"json", primitive:true, read:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}, write:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}}}}, args:[{placeholder:{index:0, type:{toString() {
        return "[protocol type:" + name + "]";
      }, name:"json", primitive:true, read:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}, write:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}}}, path:["options"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"reconfigure", request:{type:"reconfigure", template:{type:"reconfigure", options:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["options"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"resume", request:{type:"resume", template:{type:"resume", resumeLimit:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, frameActorID:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["resumeLimit"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["frameActorID"]}]}, response:{template:{_type:"nullable:json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, retVal:{_type:"nullable:json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:[]}, release:(void 0), oneway:(void 0)}, {name:"frames", request:{type:"frames", template:{type:"frames", start:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, count:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["start"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["count"]}]}, response:{template:{_type:"thread.frames", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, retVal:{_type:"thread.frames", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:[]}, release:(void 0), oneway:(void 0)}, {name:"interrupt", request:{type:"interrupt", template:{type:"interrupt", when:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["when"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"sources", request:{type:"sources", template:{type:"sources"}, args:[]}, response:{template:{sources:{_type:"array:json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, retVal:{_type:"array:json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["sources"]}, release:(void 0), oneway:(void 0)}, {name:"skipBreakpoints", request:{type:"skipBreakpoints", template:{type:"skipBreakpoints", skip:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["skip"]}]}, response:{template:{skip:{index:0, type:{toString() {
        return "[protocol type:" + name + "]";
      }, name:"json", primitive:true, read:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}, write:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}}}}}, release:(void 0), oneway:(void 0)}, {name:"dumpThread", request:{type:"dumpThread", template:{type:"dumpThread"}, args:[]}, response:{template:{_type:"json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, retVal:{_type:"json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:[]}, release:(void 0), oneway:(void 0)}, {name:"dumpPools", request:{type:"dumpPools", template:{type:"dumpPools"}, args:[]}, response:{template:{_type:"json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, retVal:{_type:"json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:[]}, release:(void 0), oneway:(void 0)}, {name:"setBreakpoint", request:{type:"setBreakpoint", template:{type:"setBreakpoint", location:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, options:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["location"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["options"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"removeBreakpoint", request:{type:"removeBreakpoint", template:{type:"removeBreakpoint", location:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["location"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"setXHRBreakpoint", request:{type:"setXHRBreakpoint", template:{type:"setXHRBreakpoint", path:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, method:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["path"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["method"]}]}, response:{template:{value:{_type:"boolean", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, retVal:{_type:"boolean", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["value"]}, release:(void 0), oneway:(void 0)}, {name:"removeXHRBreakpoint", request:{type:"removeXHRBreakpoint", template:{type:"removeXHRBreakpoint", path:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, method:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["path"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["method"]}]}, response:{template:{value:{_type:"boolean", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, retVal:{_type:"boolean", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["value"]}, release:(void 0), oneway:(void 0)}, {name:"getAvailableEventBreakpoints", request:{type:"getAvailableEventBreakpoints", template:{type:"getAvailableEventBreakpoints"}, args:[]}, response:{template:{value:{_type:"array:available-breakpoint-group", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, retVal:{_type:"array:available-breakpoint-group", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["value"]}, release:(void 0), oneway:(void 0)}, {name:"getActiveEventBreakpoints", request:{type:"getActiveEventBreakpoints", template:{type:"getActiveEventBreakpoints"}, args:[]}, response:{template:{ids:{_type:"array:string", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, retVal:{_type:"array:string", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["ids"]}, release:(void 0), oneway:(void 0)}, {name:"setActiveEventBreakpoints", request:{type:"setActiveEventBreakpoints", template:{type:"setActiveEventBreakpoints", ids:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["ids"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"pauseOnExceptions", request:{type:"pauseOnExceptions", template:{type:"pauseOnExceptions", pauseOnExceptions:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, ignoreCaughtExceptions:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["pauseOnExceptions"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["ignoreCaughtExceptions"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"toggleEventLogging", request:{type:"toggleEventLogging", template:{type:"toggleEventLogging", logEventBreakpoints:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["logEventBreakpoints"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"isAttached", request:{type:"isAttached", template:{type:"isAttached"}, args:[]}, response:{template:{value:{_type:"boolean", type:{toString() {
        return "[protocol type:" + name + "]";
      }, name:"boolean", primitive:true, read:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}, write:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}}}}, retVal:{_type:"boolean", type:{toString() {
        return "[protocol type:" + name + "]";
      }, name:"boolean", primitive:true, read:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}, write:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}}}, path:["value"]}, release:(void 0), oneway:(void 0)}], events:{}}, _state:"running", _parent:{}, global:{get window() {
    [native code]
}, get document() {
    [native code]
}, get location() {
    [native code]
}, set location() {
    [native code]
}, get top() {
    [native code]
}, close:function close() {
    [native code]
}, stop:function stop() {
    [native code]
}, focus:function focus() {
    [native code]
}, blur:function blur() {
    [native code]
}, open:function open() {
    [native code]
}, alert:function alert() {
    [native code]
}, confirm:function confirm() {
    [native code]
}, prompt:function prompt() {
    [native code]
}, print:function print() {
    [native code]
}, printPreview:function printPreview() {
    [native code]
}, postMessage:function postMessage() {
    [native code]
}, captureEvents:function captureEvents() {
    [native code]
}, releaseEvents:function releaseEvents() {
    [native code]
}, getSelection:function getSelection() {
    [native code]
}, getComputedStyle:function getComputedStyle() {
    [native code]
}, matchMedia:function matchMedia() {
    [native code]
}, moveTo:function moveTo() {
    [native code]
}, moveBy:function moveBy() {
    [native code]
}, resizeTo:function resizeTo() {
    [native code]
}, resizeBy:function resizeBy() {
    [native code]
}, scroll:function scroll() {
    [native code]
}, scrollTo:function scrollTo() {
    [native code]
}, scrollBy:function scrollBy() {
    [native code]
}, getDefaultComputedStyle:function getDefaultComputedStyle() {
    [native code]
}, scrollByLines:function scrollByLines() {
    [native code]
}, scrollByPages:function scrollByPages() {
    [native code]
}, sizeToContent:function sizeToContent() {
    [native code]
}, updateCommands:function updateCommands() {
    [native code]
}, find:function find() {
    [native code]
}, dump:function dump() {
    [native code]
}, setResizable:function setResizable() {
    [native code]
}, requestIdleCallback:function requestIdleCallback() {
    [native code]
}, cancelIdleCallback:function cancelIdleCallback() {
    [native code]
}, getRegionalPrefsLocales:function getRegionalPrefsLocales() {
    [native code]
}, getWebExposedLocales:function getWebExposedLocales() {
    [native code]
}, requestAnimationFrame:function requestAnimationFrame() {
    [native code]
}, cancelAnimationFrame:function cancelAnimationFrame() {
    [native code]
}, reportError:function reportError() {
    [native code]
}, btoa:function btoa() {
    [native code]
}, atob:function atob() {
    [native code]
}, setTimeout:function setTimeout() {
    [native code]
}, clearTimeout:function clearTimeout() {
    [native code]
}, setInterval:function setInterval() {
    [native code]
}, clearInterval:function clearInterval() {
    [native code]
}, queueMicrotask:function queueMicrotask() {
    [native code]
}, createImageBitmap:function createImageBitmap() {
    [native code]
}, structuredClone:function structuredClone() {
    [native code]
}, fetch:function fetch() {
    [native code]
}, get self() {
    [native code]
}, set self() {
    [native code]
}, get name() {
    [native code]
}, set name() {
    [native code]
}, get history() {
    [native code]
}, get customElements() {
    [native code]
}, get locationbar() {
    [native code]
}, set locationbar() {
    [native code]
}, get menubar() {
    [native code]
}, set menubar() {
    [native code]
}, get personalbar() {
    [native code]
}, set personalbar() {
    [native code]
}, get scrollbars() {
    [native code]
}, set scrollbars() {
    [native code]
}, get statusbar() {
    [native code]
}, set statusbar() {
    [native code]
}, get toolbar() {
    [native code]
}, set toolbar() {
    [native code]
}, get status() {
    [native code]
}, set status() {
    [native code]
}, get closed() {
    [native code]
}, get event() {
    [native code]
}, set event() {
    [native code]
}, get frames() {
    [native code]
}, set frames() {
    [native code]
}, get length() {
    [native code]
}, set length() {
    [native code]
}, get opener() {
    [native code]
}, set opener() {
    [native code]
}, get parent() {
    [native code]
}, set parent() {
    [native code]
}, get frameElement() {
    [native code]
}, get navigator() {
    [native code]
}, get clientInformation() {
    [native code]
}, get external() {
    [native code]
}, set external() {
    [native code]
}, get screen() {
    [native code]
}, set screen() {
    [native code]
}, get innerWidth() {
    [native code]
}, set innerWidth() {
    [native code]
}, get innerHeight() {
    [native code]
}, set innerHeight() {
    [native code]
}, get scrollX() {
    [native code]
}, set scrollX() {
    [native code]
}, get pageXOffset() {
    [native code]
}, set pageXOffset() {
    [native code]
}, get scrollY() {
    [native code]
}, set scrollY() {
    [native code]
}, get pageYOffset() {
    [native code]
}, set pageYOffset() {
    [native code]
}, get screenLeft() {
    [native code]
}, set screenLeft() {
    [native code]
}, get screenTop() {
    [native code]
}, set screenTop() {
    [native code]
}, get screenX() {
    [native code]
}, set screenX() {
    [native code]
}, get screenY() {
    [native code]
}, set screenY() {
    [native code]
}, get outerWidth() {
    [native code]
}, set outerWidth() {
    [native code]
}, get outerHeight() {
    [native code]
}, set outerHeight() {
    [native code]
}, get performance() {
    [native code]
}, set performance() {
    [native code]
}, get mozInnerScreenX() {
    [native code]
}, get mozInnerScreenY() {
    [native code]
}, get devicePixelRatio() {
    [native code]
}, set devicePixelRatio() {
    [native code]
}, get scrollMaxX() {
    [native code]
}, set scrollMaxX() {
    [native code]
}, get scrollMaxY() {
    [native code]
}, set scrollMaxY() {
    [native code]
}, get fullScreen() {
    [native code]
}, set fullScreen() {
    [native code]
}, get ondevicemotion() {
    [native code]
}, set ondevicemotion() {
    [native code]
}, get ondeviceorientation() {
    [native code]
}, set ondeviceorientation() {
    [native code]
}, get onabsolutedeviceorientation() {
    [native code]
}, set onabsolutedeviceorientation() {
    [native code]
}, get InstallTrigger() {
    [native code]
}, set InstallTrigger() {
    [native code]
}, get intlUtils() {
    [native code]
}, get visualViewport() {
    [native code]
}, set visualViewport() {
    [native code]
}, get crypto() {
    [native code]
}, get onabort() {
    [native code]
}, set onabort() {
    [native code]
}, get onblur() {
    [native code]
}, set onblur() {
    [native code]
}, get onfocus() {
    [native code]
}, set onfocus() {
    [native code]
}, get onauxclick() {
    [native code]
}, set onauxclick() {
    [native code]
}, get onbeforeinput() {
    [native code]
}, set onbeforeinput() {
    [native code]
}, get oncanplay() {
    [native code]
}, set oncanplay() {
    [native code]
}, get oncanplaythrough() {
    [native code]
}, set oncanplaythrough() {
    [native code]
}, get onchange() {
    [native code]
}, set onchange() {
    [native code]
}, get onclick() {
    [native code]
}, set onclick() {
    [native code]
}, get onclose() {
    [native code]
}, set onclose() {
    [native code]
}, get oncontextmenu() {
    [native code]
}, set oncontextmenu() {
    [native code]
}, get oncuechange() {
    [native code]
}, set oncuechange() {
    [native code]
}, get ondblclick() {
    [native code]
}, set ondblclick() {
    [native code]
}, get ondrag() {
    [native code]
}, set ondrag() {
    [native code]
}, get ondragend() {
    [native code]
}, set ondragend() {
    [native code]
}, get ondragenter() {
    [native code]
}, set ondragenter() {
    [native code]
}, get ondragexit() {
    [native code]
}, set ondragexit() {
    [native code]
}, get ondragleave() {
    [native code]
}, set ondragleave() {
    [native code]
}, get ondragover() {
    [native code]
}, set ondragover() {
    [native code]
}, get ondragstart() {
    [native code]
}, set ondragstart() {
    [native code]
}, get ondrop() {
    [native code]
}, set ondrop() {
    [native code]
}, get ondurationchange() {
    [native code]
}, set ondurationchange() {
    [native code]
}, get onemptied() {
    [native code]
}, set onemptied() {
    [native code]
}, get onended() {
    [native code]
}, set onended() {
    [native code]
}, get onformdata() {
    [native code]
}, set onformdata() {
    [native code]
}, get oninput() {
    [native code]
}, set oninput() {
    [native code]
}, get oninvalid() {
    [native code]
}, set oninvalid() {
    [native code]
}, get onkeydown() {
    [native code]
}, set onkeydown() {
    [native code]
}, get onkeypress() {
    [native code]
}, set onkeypress() {
    [native code]
}, get onkeyup() {
    [native code]
}, set onkeyup() {
    [native code]
}, get onload() {
    [native code]
}, set onload() {
    [native code]
}, get onloadeddata() {
    [native code]
}, set onloadeddata() {
    [native code]
}, get onloadedmetadata() {
    [native code]
}, set onloadedmetadata() {
    [native code]
}, get onloadend() {
    [native code]
}, set onloadend() {
    [native code]
}, get onloadstart() {
    [native code]
}, set onloadstart() {
    [native code]
}, get onmousedown() {
    [native code]
}, set onmousedown() {
    [native code]
}, get onmouseenter() {
    [native code]
}, set onmouseenter() {
    [native code]
}, get onmouseleave() {
    [native code]
}, set onmouseleave() {
    [native code]
}, get onmousemove() {
    [native code]
}, set onmousemove() {
    [native code]
}, get onmouseout() {
    [native code]
}, set onmouseout() {
    [native code]
}, get onmouseover() {
    [native code]
}, set onmouseover() {
    [native code]
}, get onmouseup() {
    [native code]
}, set onmouseup() {
    [native code]
}, get onwheel() {
    [native code]
}, set onwheel() {
    [native code]
}, get onpause() {
    [native code]
}, set onpause() {
    [native code]
}, get onplay() {
    [native code]
}, set onplay() {
    [native code]
}, get onplaying() {
    [native code]
}, set onplaying() {
    [native code]
}, get onprogress() {
    [native code]
}, set onprogress() {
    [native code]
}, get onratechange() {
    [native code]
}, set onratechange() {
    [native code]
}, get onreset() {
    [native code]
}, set onreset() {
    [native code]
}, get onresize() {
    [native code]
}, set onresize() {
    [native code]
}, get onscroll() {
    [native code]
}, set onscroll() {
    [native code]
}, get onsecuritypolicyviolation() {
    [native code]
}, set onsecuritypolicyviolation() {
    [native code]
}, get onseeked() {
    [native code]
}, set onseeked() {
    [native code]
}, get onseeking() {
    [native code]
}, set onseeking() {
    [native code]
}, get onselect() {
    [native code]
}, set onselect() {
    [native code]
}, get onslotchange() {
    [native code]
}, set onslotchange() {
    [native code]
}, get onstalled() {
    [native code]
}, set onstalled() {
    [native code]
}, get onsubmit() {
    [native code]
}, set onsubmit() {
    [native code]
}, get onsuspend() {
    [native code]
}, set onsuspend() {
    [native code]
}, get ontimeupdate() {
    [native code]
}, set ontimeupdate() {
    [native code]
}, get onvolumechange() {
    [native code]
}, set onvolumechange() {
    [native code]
}, get onwaiting() {
    [native code]
}, set onwaiting() {
    [native code]
}, get onselectstart() {
    [native code]
}, set onselectstart() {
    [native code]
}, get onselectionchange() {
    [native code]
}, set onselectionchange() {
    [native code]
}, get ontoggle() {
    [native code]
}, set ontoggle() {
    [native code]
}, get onpointercancel() {
    [native code]
}, set onpointercancel() {
    [native code]
}, get onpointerdown() {
    [native code]
}, set onpointerdown() {
    [native code]
}, get onpointerup() {
    [native code]
}, set onpointerup() {
    [native code]
}, get onpointermove() {
    [native code]
}, set onpointermove() {
    [native code]
}, get onpointerout() {
    [native code]
}, set onpointerout() {
    [native code]
}, get onpointerover() {
    [native code]
}, set onpointerover() {
    [native code]
}, get onpointerenter() {
    [native code]
}, set onpointerenter() {
    [native code]
}, get onpointerleave() {
    [native code]
}, set onpointerleave() {
    [native code]
}, get ongotpointercapture() {
    [native code]
}, set ongotpointercapture() {
    [native code]
}, get onlostpointercapture() {
    [native code]
}, set onlostpointercapture() {
    [native code]
}, get onmozfullscreenchange() {
    [native code]
}, set onmozfullscreenchange() {
    [native code]
}, get onmozfullscreenerror() {
    [native code]
}, set onmozfullscreenerror() {
    [native code]
}, get onanimationcancel() {
    [native code]
}, set onanimationcancel() {
    [native code]
}, get onanimationend() {
    [native code]
}, set onanimationend() {
    [native code]
}, get onanimationiteration() {
    [native code]
}, set onanimationiteration() {
    [native code]
}, get onanimationstart() {
    [native code]
}, set onanimationstart() {
    [native code]
}, get ontransitioncancel() {
    [native code]
}, set ontransitioncancel() {
    [native code]
}, get ontransitionend() {
    [native code]
}, set ontransitionend() {
    [native code]
}, get ontransitionrun() {
    [native code]
}, set ontransitionrun() {
    [native code]
}, get ontransitionstart() {
    [native code]
}, set ontransitionstart() {
    [native code]
}, get onwebkitanimationend() {
    [native code]
}, set onwebkitanimationend() {
    [native code]
}, get onwebkitanimationiteration() {
    [native code]
}, set onwebkitanimationiteration() {
    [native code]
}, get onwebkitanimationstart() {
    [native code]
}, set onwebkitanimationstart() {
    [native code]
}, get onwebkittransitionend() {
    [native code]
}, set onwebkittransitionend() {
    [native code]
}, get u2f() {
    [native code]
}, set u2f() {
    [native code]
}, get onerror() {
    [native code]
}, set onerror() {
    [native code]
}, get speechSynthesis() {
    [native code]
}, get onafterprint() {
    [native code]
}, set onafterprint() {
    [native code]
}, get onbeforeprint() {
    [native code]
}, set onbeforeprint() {
    [native code]
}, get onbeforeunload() {
    [native code]
}, set onbeforeunload() {
    [native code]
}, get onhashchange() {
    [native code]
}, set onhashchange() {
    [native code]
}, get onlanguagechange() {
    [native code]
}, set onlanguagechange() {
    [native code]
}, get onmessage() {
    [native code]
}, set onmessage() {
    [native code]
}, get onmessageerror() {
    [native code]
}, set onmessageerror() {
    [native code]
}, get onoffline() {
    [native code]
}, set onoffline() {
    [native code]
}, get ononline() {
    [native code]
}, set ononline() {
    [native code]
}, get onpagehide() {
    [native code]
}, set onpagehide() {
    [native code]
}, get onpageshow() {
    [native code]
}, set onpageshow() {
    [native code]
}, get onpopstate() {
    [native code]
}, set onpopstate() {
    [native code]
}, get onrejectionhandled() {
    [native code]
}, set onrejectionhandled() {
    [native code]
}, get onstorage() {
    [native code]
}, set onstorage() {
    [native code]
}, get onunhandledrejection() {
    [native code]
}, set onunhandledrejection() {
    [native code]
}, get onunload() {
    [native code]
}, set onunload() {
    [native code]
}, get ongamepadconnected() {
    [native code]
}, set ongamepadconnected() {
    [native code]
}, get ongamepaddisconnected() {
    [native code]
}, set ongamepaddisconnected() {
    [native code]
}, get localStorage() {
    [native code]
}, get origin() {
    [native code]
}, set origin() {
    [native code]
}, get crossOriginIsolated() {
    [native code]
}, get isSecureContext() {
    [native code]
}, get indexedDB() {
    [native code]
}, get caches() {
    [native code]
}, get sessionStorage() {
    [native code]
}, mozScrollSnap:function mozScrollSnap() {
    [native code]
}, openDialog:function openDialog() {
    [native code]
}, getInterface:function getInterface() {
    [native code]
}, shouldReportForServiceWorkerScope:function shouldReportForServiceWorkerScope() {
    [native code]
}, setScrollMarks:function setScrollMarks() {
    [native code]
}, get controllers() {
    [native code]
}, set controllers() {
    [native code]
}, get realFrameElement() {
    [native code]
}, get docShell() {
    [native code]
}, get browsingContext() {
    [native code]
}, get desktopToDeviceScale() {
    [native code]
}, get scrollMinX() {
    [native code]
}, get scrollMinY() {
    [native code]
}, get windowRoot() {
    [native code]
}, get windowUtils() {
    [native code]
}, get windowGlobalChild() {
    [native code]
}, get clientPrincipal() {
    [native code]
}, get isChromeWindow() {
    [native code]
}, get Glean() {
    [native code]
}, get GleanPings() {
    [native code]
}}, _options:{skipBreakpoints:false, pauseOnExceptions:false, ignoreCaughtExceptions:true, shouldShowOverlay:true, shouldIncludeSavedFrames:true, shouldIncludeAsyncLiveFrames:false, logEventBreakpoints:false, observeAsmJS:true}, _gripDepth:0, _parentClosed:false, _observingNetwork:false, _frameActors:[], _xhrBreakpoints:[], _dbg:{addDebuggees:(function() {
    for (const global of findDebuggees(this)) {
      safeAddDebuggee(this, global);
    }
  }), disable:(function() {
    dbg.removeAllDebuggees();
    dbg.onNewGlobalObject = undefined;
  }), enable:(function() {
    dbg.addDebuggees();
    dbg.onNewGlobalObject = onNewGlobalObject;
  }), onNewDebuggee:function bound _onNewDebuggee() {
    [native code]
}}, _threadLifetimePool:null, _activeEventPause:null, _pauseOverlay:null, _priorPause:null, _activeEventBreakpoints:{}, _frameActorMap:{}, _debuggerSourcesSeen:{}, _onLoadBreakpointURLs:{}, _handledFrameExceptions:{}, _watchpointsMap:{threadActor:{}, _watchpoints:{}}, breakpointActorMap:{_threadActor:{}, _actors:{}}, _nestedEventLoop:{_thread:{}, _entered:false, _resolved:false}, onNewSourceEvent:function bound onNewSourceEvent() {
    [native code]
}, createCompletionGrip:function bound createCompletionGrip() {
    [native code]
}, onDebuggerStatement:function bound onDebuggerStatement() {
    [native code]
}, onNewScript:function bound onNewScript() {
    [native code]
}, objectGrip:function bound objectGrip() {
    [native code]
}, pauseObjectGrip:function bound pauseObjectGrip() {
    [native code]
}, _onOpeningRequest:function bound _onOpeningRequest() {
    [native code]
}, _onNewDebuggee:function bound _onNewDebuggee() {
    [native code]
}, _onExceptionUnwind:function bound _onExceptionUnwind() {
    [native code]
}, _eventBreakpointListener:function bound _eventBreakpointListener() {
    [native code]
}, _onWindowReady:function bound _onWindowReady() {
    [native code]
}, _onWillNavigate:function bound _onWillNavigate() {
    [native code]
}, _onNavigate:function bound _onNavigate() {
    [native code]
}, _firstStatementBreakpoint:null, _debuggerNotificationObserver:{}, parentPool:{}, alreadyAttached:true, wrappedJSObject:{}, _shouldEmitNewSource:false, _pendingResponse:{}, [Symbol("EventEmitter/listeners")]:{}}, blackBoxedSources:{}, _sourceActors:{}, _urlContents:{}, _urlWaiters:{}, _sourcesByInternalSourceId:null, [Symbol("EventEmitter/listeners")]:{}}, _styleSheetActors:{}, _shouldAddNewGlobalAsDebuggee:function bound _shouldAddNewGlobalAsDebuggee() {
    [native code]
}, makeDebugger:function bound makeDebugger() {
    [native code]
}, watchNewDocShells:false, _isNewPerfPanelEnabled:true, _workerDescriptorActorList:null, _workerDescriptorActorPool:null, _onWorkerDescriptorActorListChanged:function bound _onWorkerDescriptorActorListChanged() {
    [native code]
}, _onConsoleApiProfilerEvent:function bound _onConsoleApiProfilerEvent() {
    [native code]
}, threadActor:{conn:{_prefix:"server0.conn0.windowGlobal4294967333/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967333", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {conn:{}, __poolMap:{}}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, actorID:"server0.conn0.windowGlobal4294967333/thread1", _actorSpec:{typeName:"thread", methods:[{name:"attach", request:{type:"attach", template:{type:"attach", options:{index:0, type:{toString() {
        return "[protocol type:" + name + "]";
      }, name:"json", primitive:true, read:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}, write:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}}}}, args:[{placeholder:{index:0, type:{toString() {
        return "[protocol type:" + name + "]";
      }, name:"json", primitive:true, read:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}, write:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}}}, path:["options"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"reconfigure", request:{type:"reconfigure", template:{type:"reconfigure", options:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["options"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"resume", request:{type:"resume", template:{type:"resume", resumeLimit:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, frameActorID:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["resumeLimit"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["frameActorID"]}]}, response:{template:{_type:"nullable:json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, retVal:{_type:"nullable:json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:[]}, release:(void 0), oneway:(void 0)}, {name:"frames", request:{type:"frames", template:{type:"frames", start:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, count:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["start"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["count"]}]}, response:{template:{_type:"thread.frames", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, retVal:{_type:"thread.frames", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:[]}, release:(void 0), oneway:(void 0)}, {name:"interrupt", request:{type:"interrupt", template:{type:"interrupt", when:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["when"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"sources", request:{type:"sources", template:{type:"sources"}, args:[]}, response:{template:{sources:{_type:"array:json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, retVal:{_type:"array:json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["sources"]}, release:(void 0), oneway:(void 0)}, {name:"skipBreakpoints", request:{type:"skipBreakpoints", template:{type:"skipBreakpoints", skip:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["skip"]}]}, response:{template:{skip:{index:0, type:{toString() {
        return "[protocol type:" + name + "]";
      }, name:"json", primitive:true, read:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}, write:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}}}}}, release:(void 0), oneway:(void 0)}, {name:"dumpThread", request:{type:"dumpThread", template:{type:"dumpThread"}, args:[]}, response:{template:{_type:"json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, retVal:{_type:"json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:[]}, release:(void 0), oneway:(void 0)}, {name:"dumpPools", request:{type:"dumpPools", template:{type:"dumpPools"}, args:[]}, response:{template:{_type:"json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, retVal:{_type:"json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:[]}, release:(void 0), oneway:(void 0)}, {name:"setBreakpoint", request:{type:"setBreakpoint", template:{type:"setBreakpoint", location:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, options:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["location"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["options"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"removeBreakpoint", request:{type:"removeBreakpoint", template:{type:"removeBreakpoint", location:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["location"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"setXHRBreakpoint", request:{type:"setXHRBreakpoint", template:{type:"setXHRBreakpoint", path:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, method:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["path"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["method"]}]}, response:{template:{value:{_type:"boolean", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, retVal:{_type:"boolean", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["value"]}, release:(void 0), oneway:(void 0)}, {name:"removeXHRBreakpoint", request:{type:"removeXHRBreakpoint", template:{type:"removeXHRBreakpoint", path:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, method:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["path"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["method"]}]}, response:{template:{value:{_type:"boolean", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, retVal:{_type:"boolean", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["value"]}, release:(void 0), oneway:(void 0)}, {name:"getAvailableEventBreakpoints", request:{type:"getAvailableEventBreakpoints", template:{type:"getAvailableEventBreakpoints"}, args:[]}, response:{template:{value:{_type:"array:available-breakpoint-group", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, retVal:{_type:"array:available-breakpoint-group", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["value"]}, release:(void 0), oneway:(void 0)}, {name:"getActiveEventBreakpoints", request:{type:"getActiveEventBreakpoints", template:{type:"getActiveEventBreakpoints"}, args:[]}, response:{template:{ids:{_type:"array:string", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, retVal:{_type:"array:string", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["ids"]}, release:(void 0), oneway:(void 0)}, {name:"setActiveEventBreakpoints", request:{type:"setActiveEventBreakpoints", template:{type:"setActiveEventBreakpoints", ids:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["ids"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"pauseOnExceptions", request:{type:"pauseOnExceptions", template:{type:"pauseOnExceptions", pauseOnExceptions:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, ignoreCaughtExceptions:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["pauseOnExceptions"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["ignoreCaughtExceptions"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"toggleEventLogging", request:{type:"toggleEventLogging", template:{type:"toggleEventLogging", logEventBreakpoints:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["logEventBreakpoints"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"isAttached", request:{type:"isAttached", template:{type:"isAttached"}, args:[]}, response:{template:{value:{_type:"boolean", type:{toString() {
        return "[protocol type:" + name + "]";
      }, name:"boolean", primitive:true, read:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}, write:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}}}}, retVal:{_type:"boolean", type:{toString() {
        return "[protocol type:" + name + "]";
      }, name:"boolean", primitive:true, read:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}, write:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}}}, path:["value"]}, release:(void 0), oneway:(void 0)}], events:{}}, _state:"running", _parent:{}, global:{get window() {
    [native code]
}, get document() {
    [native code]
}, get location() {
    [native code]
}, set location() {
    [native code]
}, get top() {
    [native code]
}, close:function close() {
    [native code]
}, stop:function stop() {
    [native code]
}, focus:function focus() {
    [native code]
}, blur:function blur() {
    [native code]
}, open:function open() {
    [native code]
}, alert:function alert() {
    [native code]
}, confirm:function confirm() {
    [native code]
}, prompt:function prompt() {
    [native code]
}, print:function print() {
    [native code]
}, printPreview:function printPreview() {
    [native code]
}, postMessage:function postMessage() {
    [native code]
}, captureEvents:function captureEvents() {
    [native code]
}, releaseEvents:function releaseEvents() {
    [native code]
}, getSelection:function getSelection() {
    [native code]
}, getComputedStyle:function getComputedStyle() {
    [native code]
}, matchMedia:function matchMedia() {
    [native code]
}, moveTo:function moveTo() {
    [native code]
}, moveBy:function moveBy() {
    [native code]
}, resizeTo:function resizeTo() {
    [native code]
}, resizeBy:function resizeBy() {
    [native code]
}, scroll:function scroll() {
    [native code]
}, scrollTo:function scrollTo() {
    [native code]
}, scrollBy:function scrollBy() {
    [native code]
}, getDefaultComputedStyle:function getDefaultComputedStyle() {
    [native code]
}, scrollByLines:function scrollByLines() {
    [native code]
}, scrollByPages:function scrollByPages() {
    [native code]
}, sizeToContent:function sizeToContent() {
    [native code]
}, updateCommands:function updateCommands() {
    [native code]
}, find:function find() {
    [native code]
}, dump:function dump() {
    [native code]
}, setResizable:function setResizable() {
    [native code]
}, requestIdleCallback:function requestIdleCallback() {
    [native code]
}, cancelIdleCallback:function cancelIdleCallback() {
    [native code]
}, getRegionalPrefsLocales:function getRegionalPrefsLocales() {
    [native code]
}, getWebExposedLocales:function getWebExposedLocales() {
    [native code]
}, requestAnimationFrame:function requestAnimationFrame() {
    [native code]
}, cancelAnimationFrame:function cancelAnimationFrame() {
    [native code]
}, reportError:function reportError() {
    [native code]
}, btoa:function btoa() {
    [native code]
}, atob:function atob() {
    [native code]
}, setTimeout:function setTimeout() {
    [native code]
}, clearTimeout:function clearTimeout() {
    [native code]
}, setInterval:function setInterval() {
    [native code]
}, clearInterval:function clearInterval() {
    [native code]
}, queueMicrotask:function queueMicrotask() {
    [native code]
}, createImageBitmap:function createImageBitmap() {
    [native code]
}, structuredClone:function structuredClone() {
    [native code]
}, fetch:function fetch() {
    [native code]
}, get self() {
    [native code]
}, set self() {
    [native code]
}, get name() {
    [native code]
}, set name() {
    [native code]
}, get history() {
    [native code]
}, get customElements() {
    [native code]
}, get locationbar() {
    [native code]
}, set locationbar() {
    [native code]
}, get menubar() {
    [native code]
}, set menubar() {
    [native code]
}, get personalbar() {
    [native code]
}, set personalbar() {
    [native code]
}, get scrollbars() {
    [native code]
}, set scrollbars() {
    [native code]
}, get statusbar() {
    [native code]
}, set statusbar() {
    [native code]
}, get toolbar() {
    [native code]
}, set toolbar() {
    [native code]
}, get status() {
    [native code]
}, set status() {
    [native code]
}, get closed() {
    [native code]
}, get event() {
    [native code]
}, set event() {
    [native code]
}, get frames() {
    [native code]
}, set frames() {
    [native code]
}, get length() {
    [native code]
}, set length() {
    [native code]
}, get opener() {
    [native code]
}, set opener() {
    [native code]
}, get parent() {
    [native code]
}, set parent() {
    [native code]
}, get frameElement() {
    [native code]
}, get navigator() {
    [native code]
}, get clientInformation() {
    [native code]
}, get external() {
    [native code]
}, set external() {
    [native code]
}, get screen() {
    [native code]
}, set screen() {
    [native code]
}, get innerWidth() {
    [native code]
}, set innerWidth() {
    [native code]
}, get innerHeight() {
    [native code]
}, set innerHeight() {
    [native code]
}, get scrollX() {
    [native code]
}, set scrollX() {
    [native code]
}, get pageXOffset() {
    [native code]
}, set pageXOffset() {
    [native code]
}, get scrollY() {
    [native code]
}, set scrollY() {
    [native code]
}, get pageYOffset() {
    [native code]
}, set pageYOffset() {
    [native code]
}, get screenLeft() {
    [native code]
}, set screenLeft() {
    [native code]
}, get screenTop() {
    [native code]
}, set screenTop() {
    [native code]
}, get screenX() {
    [native code]
}, set screenX() {
    [native code]
}, get screenY() {
    [native code]
}, set screenY() {
    [native code]
}, get outerWidth() {
    [native code]
}, set outerWidth() {
    [native code]
}, get outerHeight() {
    [native code]
}, set outerHeight() {
    [native code]
}, get performance() {
    [native code]
}, set performance() {
    [native code]
}, get mozInnerScreenX() {
    [native code]
}, get mozInnerScreenY() {
    [native code]
}, get devicePixelRatio() {
    [native code]
}, set devicePixelRatio() {
    [native code]
}, get scrollMaxX() {
    [native code]
}, set scrollMaxX() {
    [native code]
}, get scrollMaxY() {
    [native code]
}, set scrollMaxY() {
    [native code]
}, get fullScreen() {
    [native code]
}, set fullScreen() {
    [native code]
}, get ondevicemotion() {
    [native code]
}, set ondevicemotion() {
    [native code]
}, get ondeviceorientation() {
    [native code]
}, set ondeviceorientation() {
    [native code]
}, get onabsolutedeviceorientation() {
    [native code]
}, set onabsolutedeviceorientation() {
    [native code]
}, get InstallTrigger() {
    [native code]
}, set InstallTrigger() {
    [native code]
}, get intlUtils() {
    [native code]
}, get visualViewport() {
    [native code]
}, set visualViewport() {
    [native code]
}, get crypto() {
    [native code]
}, get onabort() {
    [native code]
}, set onabort() {
    [native code]
}, get onblur() {
    [native code]
}, set onblur() {
    [native code]
}, get onfocus() {
    [native code]
}, set onfocus() {
    [native code]
}, get onauxclick() {
    [native code]
}, set onauxclick() {
    [native code]
}, get onbeforeinput() {
    [native code]
}, set onbeforeinput() {
    [native code]
}, get oncanplay() {
    [native code]
}, set oncanplay() {
    [native code]
}, get oncanplaythrough() {
    [native code]
}, set oncanplaythrough() {
    [native code]
}, get onchange() {
    [native code]
}, set onchange() {
    [native code]
}, get onclick() {
    [native code]
}, set onclick() {
    [native code]
}, get onclose() {
    [native code]
}, set onclose() {
    [native code]
}, get oncontextmenu() {
    [native code]
}, set oncontextmenu() {
    [native code]
}, get oncuechange() {
    [native code]
}, set oncuechange() {
    [native code]
}, get ondblclick() {
    [native code]
}, set ondblclick() {
    [native code]
}, get ondrag() {
    [native code]
}, set ondrag() {
    [native code]
}, get ondragend() {
    [native code]
}, set ondragend() {
    [native code]
}, get ondragenter() {
    [native code]
}, set ondragenter() {
    [native code]
}, get ondragexit() {
    [native code]
}, set ondragexit() {
    [native code]
}, get ondragleave() {
    [native code]
}, set ondragleave() {
    [native code]
}, get ondragover() {
    [native code]
}, set ondragover() {
    [native code]
}, get ondragstart() {
    [native code]
}, set ondragstart() {
    [native code]
}, get ondrop() {
    [native code]
}, set ondrop() {
    [native code]
}, get ondurationchange() {
    [native code]
}, set ondurationchange() {
    [native code]
}, get onemptied() {
    [native code]
}, set onemptied() {
    [native code]
}, get onended() {
    [native code]
}, set onended() {
    [native code]
}, get onformdata() {
    [native code]
}, set onformdata() {
    [native code]
}, get oninput() {
    [native code]
}, set oninput() {
    [native code]
}, get oninvalid() {
    [native code]
}, set oninvalid() {
    [native code]
}, get onkeydown() {
    [native code]
}, set onkeydown() {
    [native code]
}, get onkeypress() {
    [native code]
}, set onkeypress() {
    [native code]
}, get onkeyup() {
    [native code]
}, set onkeyup() {
    [native code]
}, get onload() {
    [native code]
}, set onload() {
    [native code]
}, get onloadeddata() {
    [native code]
}, set onloadeddata() {
    [native code]
}, get onloadedmetadata() {
    [native code]
}, set onloadedmetadata() {
    [native code]
}, get onloadend() {
    [native code]
}, set onloadend() {
    [native code]
}, get onloadstart() {
    [native code]
}, set onloadstart() {
    [native code]
}, get onmousedown() {
    [native code]
}, set onmousedown() {
    [native code]
}, get onmouseenter() {
    [native code]
}, set onmouseenter() {
    [native code]
}, get onmouseleave() {
    [native code]
}, set onmouseleave() {
    [native code]
}, get onmousemove() {
    [native code]
}, set onmousemove() {
    [native code]
}, get onmouseout() {
    [native code]
}, set onmouseout() {
    [native code]
}, get onmouseover() {
    [native code]
}, set onmouseover() {
    [native code]
}, get onmouseup() {
    [native code]
}, set onmouseup() {
    [native code]
}, get onwheel() {
    [native code]
}, set onwheel() {
    [native code]
}, get onpause() {
    [native code]
}, set onpause() {
    [native code]
}, get onplay() {
    [native code]
}, set onplay() {
    [native code]
}, get onplaying() {
    [native code]
}, set onplaying() {
    [native code]
}, get onprogress() {
    [native code]
}, set onprogress() {
    [native code]
}, get onratechange() {
    [native code]
}, set onratechange() {
    [native code]
}, get onreset() {
    [native code]
}, set onreset() {
    [native code]
}, get onresize() {
    [native code]
}, set onresize() {
    [native code]
}, get onscroll() {
    [native code]
}, set onscroll() {
    [native code]
}, get onsecuritypolicyviolation() {
    [native code]
}, set onsecuritypolicyviolation() {
    [native code]
}, get onseeked() {
    [native code]
}, set onseeked() {
    [native code]
}, get onseeking() {
    [native code]
}, set onseeking() {
    [native code]
}, get onselect() {
    [native code]
}, set onselect() {
    [native code]
}, get onslotchange() {
    [native code]
}, set onslotchange() {
    [native code]
}, get onstalled() {
    [native code]
}, set onstalled() {
    [native code]
}, get onsubmit() {
    [native code]
}, set onsubmit() {
    [native code]
}, get onsuspend() {
    [native code]
}, set onsuspend() {
    [native code]
}, get ontimeupdate() {
    [native code]
}, set ontimeupdate() {
    [native code]
}, get onvolumechange() {
    [native code]
}, set onvolumechange() {
    [native code]
}, get onwaiting() {
    [native code]
}, set onwaiting() {
    [native code]
}, get onselectstart() {
    [native code]
}, set onselectstart() {
    [native code]
}, get onselectionchange() {
    [native code]
}, set onselectionchange() {
    [native code]
}, get ontoggle() {
    [native code]
}, set ontoggle() {
    [native code]
}, get onpointercancel() {
    [native code]
}, set onpointercancel() {
    [native code]
}, get onpointerdown() {
    [native code]
}, set onpointerdown() {
    [native code]
}, get onpointerup() {
    [native code]
}, set onpointerup() {
    [native code]
}, get onpointermove() {
    [native code]
}, set onpointermove() {
    [native code]
}, get onpointerout() {
    [native code]
}, set onpointerout() {
    [native code]
}, get onpointerover() {
    [native code]
}, set onpointerover() {
    [native code]
}, get onpointerenter() {
    [native code]
}, set onpointerenter() {
    [native code]
}, get onpointerleave() {
    [native code]
}, set onpointerleave() {
    [native code]
}, get ongotpointercapture() {
    [native code]
}, set ongotpointercapture() {
    [native code]
}, get onlostpointercapture() {
    [native code]
}, set onlostpointercapture() {
    [native code]
}, get onmozfullscreenchange() {
    [native code]
}, set onmozfullscreenchange() {
    [native code]
}, get onmozfullscreenerror() {
    [native code]
}, set onmozfullscreenerror() {
    [native code]
}, get onanimationcancel() {
    [native code]
}, set onanimationcancel() {
    [native code]
}, get onanimationend() {
    [native code]
}, set onanimationend() {
    [native code]
}, get onanimationiteration() {
    [native code]
}, set onanimationiteration() {
    [native code]
}, get onanimationstart() {
    [native code]
}, set onanimationstart() {
    [native code]
}, get ontransitioncancel() {
    [native code]
}, set ontransitioncancel() {
    [native code]
}, get ontransitionend() {
    [native code]
}, set ontransitionend() {
    [native code]
}, get ontransitionrun() {
    [native code]
}, set ontransitionrun() {
    [native code]
}, get ontransitionstart() {
    [native code]
}, set ontransitionstart() {
    [native code]
}, get onwebkitanimationend() {
    [native code]
}, set onwebkitanimationend() {
    [native code]
}, get onwebkitanimationiteration() {
    [native code]
}, set onwebkitanimationiteration() {
    [native code]
}, get onwebkitanimationstart() {
    [native code]
}, set onwebkitanimationstart() {
    [native code]
}, get onwebkittransitionend() {
    [native code]
}, set onwebkittransitionend() {
    [native code]
}, get u2f() {
    [native code]
}, set u2f() {
    [native code]
}, get onerror() {
    [native code]
}, set onerror() {
    [native code]
}, get speechSynthesis() {
    [native code]
}, get onafterprint() {
    [native code]
}, set onafterprint() {
    [native code]
}, get onbeforeprint() {
    [native code]
}, set onbeforeprint() {
    [native code]
}, get onbeforeunload() {
    [native code]
}, set onbeforeunload() {
    [native code]
}, get onhashchange() {
    [native code]
}, set onhashchange() {
    [native code]
}, get onlanguagechange() {
    [native code]
}, set onlanguagechange() {
    [native code]
}, get onmessage() {
    [native code]
}, set onmessage() {
    [native code]
}, get onmessageerror() {
    [native code]
}, set onmessageerror() {
    [native code]
}, get onoffline() {
    [native code]
}, set onoffline() {
    [native code]
}, get ononline() {
    [native code]
}, set ononline() {
    [native code]
}, get onpagehide() {
    [native code]
}, set onpagehide() {
    [native code]
}, get onpageshow() {
    [native code]
}, set onpageshow() {
    [native code]
}, get onpopstate() {
    [native code]
}, set onpopstate() {
    [native code]
}, get onrejectionhandled() {
    [native code]
}, set onrejectionhandled() {
    [native code]
}, get onstorage() {
    [native code]
}, set onstorage() {
    [native code]
}, get onunhandledrejection() {
    [native code]
}, set onunhandledrejection() {
    [native code]
}, get onunload() {
    [native code]
}, set onunload() {
    [native code]
}, get ongamepadconnected() {
    [native code]
}, set ongamepadconnected() {
    [native code]
}, get ongamepaddisconnected() {
    [native code]
}, set ongamepaddisconnected() {
    [native code]
}, get localStorage() {
    [native code]
}, get origin() {
    [native code]
}, set origin() {
    [native code]
}, get crossOriginIsolated() {
    [native code]
}, get isSecureContext() {
    [native code]
}, get indexedDB() {
    [native code]
}, get caches() {
    [native code]
}, get sessionStorage() {
    [native code]
}, mozScrollSnap:function mozScrollSnap() {
    [native code]
}, openDialog:function openDialog() {
    [native code]
}, getInterface:function getInterface() {
    [native code]
}, shouldReportForServiceWorkerScope:function shouldReportForServiceWorkerScope() {
    [native code]
}, setScrollMarks:function setScrollMarks() {
    [native code]
}, get controllers() {
    [native code]
}, set controllers() {
    [native code]
}, get realFrameElement() {
    [native code]
}, get docShell() {
    [native code]
}, get browsingContext() {
    [native code]
}, get desktopToDeviceScale() {
    [native code]
}, get scrollMinX() {
    [native code]
}, get scrollMinY() {
    [native code]
}, get windowRoot() {
    [native code]
}, get windowUtils() {
    [native code]
}, get windowGlobalChild() {
    [native code]
}, get clientPrincipal() {
    [native code]
}, get isChromeWindow() {
    [native code]
}, get Glean() {
    [native code]
}, get GleanPings() {
    [native code]
}}, _options:{skipBreakpoints:false, pauseOnExceptions:false, ignoreCaughtExceptions:true, shouldShowOverlay:true, shouldIncludeSavedFrames:true, shouldIncludeAsyncLiveFrames:false, logEventBreakpoints:false, observeAsmJS:true}, _gripDepth:0, _parentClosed:false, _observingNetwork:false, _frameActors:[], _xhrBreakpoints:[], _dbg:{addDebuggees:(function() {
    for (const global of findDebuggees(this)) {
      safeAddDebuggee(this, global);
    }
  }), disable:(function() {
    dbg.removeAllDebuggees();
    dbg.onNewGlobalObject = undefined;
  }), enable:(function() {
    dbg.addDebuggees();
    dbg.onNewGlobalObject = onNewGlobalObject;
  }), onNewDebuggee:function bound _onNewDebuggee() {
    [native code]
}}, _threadLifetimePool:null, _activeEventPause:null, _pauseOverlay:null, _priorPause:null, _activeEventBreakpoints:{}, _frameActorMap:{}, _debuggerSourcesSeen:{}, _onLoadBreakpointURLs:{}, _handledFrameExceptions:{}, _watchpointsMap:{threadActor:{}, _watchpoints:{}}, breakpointActorMap:{_threadActor:{}, _actors:{}}, _nestedEventLoop:{_thread:{}, _entered:false, _resolved:false}, onNewSourceEvent:function bound onNewSourceEvent() {
    [native code]
}, createCompletionGrip:function bound createCompletionGrip() {
    [native code]
}, onDebuggerStatement:function bound onDebuggerStatement() {
    [native code]
}, onNewScript:function bound onNewScript() {
    [native code]
}, objectGrip:function bound objectGrip() {
    [native code]
}, pauseObjectGrip:function bound pauseObjectGrip() {
    [native code]
}, _onOpeningRequest:function bound _onOpeningRequest() {
    [native code]
}, _onNewDebuggee:function bound _onNewDebuggee() {
    [native code]
}, _onExceptionUnwind:function bound _onExceptionUnwind() {
    [native code]
}, _eventBreakpointListener:function bound _eventBreakpointListener() {
    [native code]
}, _onWindowReady:function bound _onWindowReady() {
    [native code]
}, _onWillNavigate:function bound _onWillNavigate() {
    [native code]
}, _onNavigate:function bound _onNavigate() {
    [native code]
}, _firstStatementBreakpoint:null, _debuggerNotificationObserver:{}, parentPool:{}, alreadyAttached:true, wrappedJSObject:{}, _shouldEmitNewSource:false, _pendingResponse:{}, [Symbol("EventEmitter/listeners")]:{}}, __poolMap:{}, _progressListener:{_targetActor:{}, _onWindowCreated:function bound () {
    [native code]
}, _onWindowHidden:function bound () {
    [native code]
}, _knownWindowIDs:{}, _watchedDocShells:{}}, _docShellsObserved:true, parentPool:{}, createdFromJsWindowActor:true, _targetScopedActorPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967333/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967333", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, _dbg:{addDebuggees:(function() {
    for (const global of findDebuggees(this)) {
      safeAddDebuggee(this, global);
    }
  }), disable:(function() {
    dbg.removeAllDebuggees();
    dbg.onNewGlobalObject = undefined;
  }), enable:(function() {
    dbg.addDebuggees();
    dbg.onNewGlobalObject = onNewGlobalObject;
  }), onNewDebuggee:function bound _onNewDebuggee() {
    [native code]
}}, _styleSheetManager:{_styleSheetCount:0, _styleSheetMap:{}, _mqlList:[], _targetActor:{}, _onApplicableStateChanged:function bound _onApplicableStateChanged() {
    [native code]
}, _onTargetActorWindowReady:function bound _onTargetActorWindowReady() {
    [native code]
}, [Symbol("EventEmitter/listeners")]:{}}, [Symbol("EventEmitter/listeners")]:{}}) ": " (new TypeError("this._targetActor.chromeEventHandler is null", "resource://devtools/server/actors/utils/stylesheets-manager.js", 868))
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 1710: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/connectors/js-window-actor/DevToolsFrameChild.jsm, line 402: InvalidStateError: JSWindowActorChild.sendAsyncMessage: JSWindowActorChild cannot send at the moment
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 420: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 420: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, 1650436144498	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "49280" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofilePFvAS8"
1650436145143	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofilePFvAS8\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:49280/devtools/browser/7acf75a6-b27e-42a9-b9ba-5c5a7ee53c06
1650436148098	Marionette	INFO	Listening on port 49286
1650436148254	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
JavaScript error: resource://gre/modules/LoginManagerParent.jsm, line 136: TypeError: gRecipeManager is null
JavaScript warning: https://gen-bizbd.com/web/content/53594-92c9dad/web.assets_backend.js, line 5051: unreachable code after return statement
1650436285671	Marionette	INFO	Stopped listening on port 49281650436287295	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "49352" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileoHinux"
1650436287857	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileoHinux\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:49352/devtools/browser/a4fbd5ae-e326-4377-a12b-e59e0bb1fa17
1650436290378	Marionette	INFO	Listening on port 49358
1650436290535	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
JavaScript error: resource://gre/modules/LoginManagerParent.jsm, line 136: TypeError: gRecipeManager is null
JavaScript warning: https://gen-bizbd.com/web/content/53594-92c9dad/web.assets_backend.js, line 5051: unreachable code after return statement
1650436424229	Marionette	INFO	Stopped listening on port 49351650436425962	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "55773" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileTmLdSn"
1650436426518	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileTmLdSn\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:55773/devtools/browser/b1bbdea8-fafb-44be-83e0-9a2f0e99c357
1650436429245	Marionette	INFO	Listening on port 55778
1650436429708	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
JavaScript error: resource://gre/modules/LoginManagerParent.jsm, line 136: TypeError: gRecipeManager is null
JavaScript warning: https://gen-bizbd.com/web/content/53594-92c9dad/web.assets_backend.js, line 5051: unreachable code after return statement
SourceActor threw an exception: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:556:16
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 556, column: 16
console.error: (new Error("Failed to fetch https://gen-bizbd.com/web. Code 2152924148.", "resource://devtools/shared/DevToolsUtils.js", 556))
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 556: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
SourceActor threw an exception: [Exception... "Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]"  nsresult: "0x80470002 (NS_BASE_STREAM_CLOSED)"  location: "JS frame :: resource://devtools/shared/DevToolsUtils.js :: onResponse :: line 567"  data: no]
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:567:34
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 567, column: 0
console.error: ({})
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 567: NS_BASE_STREAM_CLOSED: Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, 1650436549424	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "55840" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofile5aRIJQ"
1650436549970	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofile5aRIJQ\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:55840/devtools/browser/e091e9ed-f3a7-4544-8675-06610774191f
1650436552592	Marionette	INFO	Listening on port 55845
1650436552643	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
JavaScript error: resource://gre/modules/LoginManagerParent.jsm, line 136: TypeError: gRecipeManager is null
JavaScript warning: https://gen-bizbd.com/web/content/53594-92c9dad/web.assets_backend.js, line 5051: unreachable code after return statement
SourceActor threw an exception: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:556:16
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 556, column: 16
console.error: (new Error("Failed to fetch https://gen-bizbd.com/web. Code 2152924148.", "resource://devtools/shared/DevToolsUtils.js", 556))
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 556: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
SourceActor threw an exception: [Exception... "Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]"  nsresult: "0x80470002 (NS_BASE_STREAM_CLOSED)"  location: "JS frame :: resource://devtools/shared/DevToolsUtils.js :: onResponse :: line 567"  data: no]
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:567:34
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 567, column: 0
console.error: ({})
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 567: NS_BASE_STREAM_CLOSED: Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]
console.error: (new TypeError("parent is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: parent is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

console.error: (new TypeError("parent is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: parent is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

console.error: (new TypeError("parent is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: parent is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

console.error: (new TypeError("container.node.targetFront is null", "resource://devtools/client/inspector/markup/markup.js", 2320))
console.error: (new TypeError("container.node.targetFront is null", "resource://devtools/client/inspector/markup/markup.js", 2320))
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, 1650436873525	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "58605" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileWDm23R"
1650436874206	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileWDm23R\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:58605/devtools/browser/fb29ba1a-3cb2-47e4-a989-06e7e155f671
1650436877672	Marionette	INFO	Listening on port 58612
1650436877808	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
JavaScript error: resource://gre/modules/LoginManagerParent.jsm, line 136: TypeError: gRecipeManager is null
1650436887465	Marionette	WARN	TimedPromise timed out after 500 ms: stacktrace:
TimedPromise/<@chrome://remote/content/marionette/sync.js:235:19
TimedPromise@chrome://remote/content/marionette/sync.js:220:10
interaction.flushEventLoop@chrome://remote/content/marionette/interaction.js:431:10
webdriverClickElement@chrome://remote/content/marionette/interaction.js:179:31
JavaScript warning: https://gen-bizbd.com/web/content/53594-92c9dad/web.assets_backend.js, line 5051: unreachable code after return statement
SourceActor threw an exception: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:556:16
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 556, column: 16
console.error: (new Error("Failed to fetch https://gen-bizbd.com/web. Code 2152924148.", "resource://devtools/shared/DevToolsUtils.js", 556))
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 556: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
SourceActor threw an exception: [Exception... "Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]"  nsresult: "0x80470002 (NS_BASE_STREAM_CLOSED)"  location: "JS frame :: resource://devtools/shared/DevToolsUtils.js :: onResponse :: line 567"  data: no]
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:567:34
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 567, column: 0
console.error: ({})
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 567: NS_BASE_STREAM_CLOSED: Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]
console.error: (new TypeError("parent is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: parent is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

console.error: "Error while calling actor 'pagestyle's method 'getLayout'" "node is null"
console.error: (new TypeError("node is null", "resource://devtools/server/actors/page-style.js", 1001))
console.error: (new Error("Protocol error (TypeError): node is null from: server0.conn0.windowGlobal4294967299/pagestyle26 (resource://devtools/server/actors/page-style.js:1001:5)", "resource://devtools/shared/protocol/Front.js", 365))
JavaScript error: resource://devtools/server/actors/page-style.js, line 570: TypeError: node is null
console.error: "Error while calling actor 'pagestyle's method 'getApplied'" "node is null"
console.error: (new TypeError("node is null", "resource://devtools/server/actors/page-style.js", 570))
console.error: (new Error("Protocol error (TypeError): node is null from: server0.conn0.windowGlobal4294967299/pagestyle26 (resource://devtools/server/actors/page-style.js:570:5)", "resource://devtools/shared/protocol/Front.js", 365))
console.error: (new TypeError("parent is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: parent is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

console.error: (new TypeError("container.node.targetFront is null", "resource://devtools/client/inspector/markup/markup.js", 2320))
console.error: "Error while calling actor 'pagestyle's method 'getLayout'" "node is null"
console.error: (new TypeError("node is null", "resource://devtools/server/actors/page-style.js", 1001))
console.error: (new Error("Protocol error (TypeError): node is null from: server0.conn0.windowGlobal4294967299/pagestyle26 (resource://devtools/server/actors/page-style.js:1001:5)", "resource://devtools/shared/protocol/Front.js", 365))
console.error: (new TypeError("parent is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: parent is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

JavaScript error: resource://gre/modules/AsyncShutdown.jsm, 1650437269143	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "55016" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileCbTYJc"
1650437269700	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileCbTYJc\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:55016/devtools/browser/bded272a-8ca6-400b-9ef8-5e379ea460b4
1650437272206	Marionette	INFO	Listening on port 55021
1650437272351	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
JavaScript error: resource://gre/modules/LoginManagerParent.jsm, line 136: TypeError: gRecipeManager is null
JavaScript warning: https://gen-bizbd.com/web/content/53594-92c9dad/web.assets_backend.js, line 5051: unreachable code after return statement
1650437295072	Marionette	WARN	TimedPromise timed out after 500 ms: stacktrace:
TimedPromise/<@chrome://remote/content/marionette/sync.js:235:19
TimedPromise@chrome://remote/content/marionette/sync.js:220:10
interaction.flushEventLoop@chrome://remote/content/marionette/interaction.js:431:10
webdriverClickElement@chrome://remote/content/marionette/interaction.js:179:31
1650437315752	Marionette	INFO	Stopped listening on port 55021650437317635	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "52569" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileKm0Hf8"
1650437318193	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileKm0Hf8\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:52569/devtools/browser/86cbcece-0f94-44c9-b151-b6070c96cebd
1650437320831	Marionette	INFO	Listening on port 52575
1650437321354	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
JavaScript error: resource://gre/modules/LoginManagerParent.jsm, line 136: TypeError: gRecipeManager is null
JavaScript warning: https://gen-bizbd.com/web/content/53594-92c9dad/web.assets_backend.js, line 5051: unreachable code after return statement
1650437439043	Marionette	WARN	TimedPromise timed out after 500 ms: stacktrace:
TimedPromise/<@chrome://remote/content/marionette/sync.js:235:19
TimedPromise@chrome://remote/content/marionette/sync.js:220:10
interaction.flushEventLoop@chrome://remote/content/marionette/interaction.js:431:10
webdriverClickElement@chrome://remote/content/marionette/interaction.js:179:31
1650437441266	Marionette	INFO	Stopped listening on port 52575

###!!! [Parent][PContentParent] Error: Send(msgname=PContent::Msg_DestroyBrowsingContextGroup) Closed channel: cannot send/recv


###!!! [Child][PContentChild] Error: RunMessage(msgname=PContent::Reply_DiscardBrowsingContext) Channel closing: too late to send/recv, messages will be lost


###!!! [Child][PContentChild] Error: RunMessage(msgname=PHttpChannel::Msg_DeleteSelf) Channel closing: too late to send/recv, messages will be lost

1650437562120	geckodriver	INFO	Listening on 127.0.0.1:51006
1650437565202	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "51007" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofile5Zx2Sy"
1650437565787	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofile5Zx2Sy\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:51007/devtools/browser/f3622752-4e3a-4c0b-8c8b-5e7d0235cc26
1650437568618	Marionette	INFO	Listening on port 51012
1650437568960	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
JavaScript error: resource://gre/modules/LoginManagerParent.jsm, line 136: TypeError: gRecipeManager is null
JavaScript warning: https://gen-bizbd.com/web/content/53594-92c9dad/web.assets_backend.js, line 5051: unreachable code after return statement
SourceActor threw an exception: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:556:16
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 556, column: 16
console.error: (new Error("Failed to fetch https://gen-bizbd.com/web. Code 2152924148.", "resource://devtools/shared/DevToolsUtils.js", 556))
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 556: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
SourceActor threw an exception: [Exception... "Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]"  nsresult: "0x80470002 (NS_BASE_STREAM_CLOSED)"  location: "JS frame :: resource://devtools/shared/DevToolsUtils.js :: onResponse :: line 567"  data: no]
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:567:34
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 567, column: 0
console.error: ({})
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 567: NS_BASE_STREAM_CLOSED: Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]
console.error: (new TypeError("parent is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: parent is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

console.error: (new TypeError("container.node.targetFront is null", "resource://devtools/client/inspector/markup/markup.js", 2320))
JavaScript error: resource://devtools/client/framework/toolbox.js, line 3400: TypeError: data.frameData.id is null
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, 1650437752642	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "51082" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileCYhnVD"
1650437753206	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileCYhnVD\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:51082/devtools/browser/43f2b956-a2a8-499e-a9c8-21cefd8dfd38
1650437755812	Marionette	INFO	Listening on port 51087
1650437755945	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
JavaScript error: resource://gre/modules/LoginManagerParent.jsm, line 136: TypeError: gRecipeManager is null
JavaScript warning: https://gen-bizbd.com/web/content/53594-92c9dad/web.assets_backend.js, line 5051: unreachable code after return statement
1650437829489	Marionette	INFO	Stopped listening on port 51081650437831384	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "57640" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileZc6uTs"
1650437831919	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileZc6uTs\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:57640/devtools/browser/51c81dd1-2655-45ff-918e-426b6b129b7d
1650437834517	Marionette	INFO	Listening on port 57645
1650437834604	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
JavaScript error: resource://gre/modules/LoginManagerParent.jsm, line 136: TypeError: gRecipeManager is null
JavaScript warning: https://gen-bizbd.com/web/content/53594-92c9dad/web.assets_backend.js, line 5051: unreachable code after return statement
SourceActor threw an exception: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:556:16
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 556, column: 16
console.error: (new Error("Failed to fetch https://gen-bizbd.com/web. Code 2152924148.", "resource://devtools/shared/DevToolsUtils.js", 556))
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 556: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
SourceActor threw an exception: [Exception... "Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]"  nsresult: "0x80470002 (NS_BASE_STREAM_CLOSED)"  location: "JS frame :: resource://devtools/shared/DevToolsUtils.js :: onResponse :: line 567"  data: no]
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:567:34
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 567, column: 0
console.error: ({})
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 567: NS_BASE_STREAM_CLOSED: Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]
console.error: (new TypeError("parent is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: parent is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

console.error: (new TypeError("parent is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: parent is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

console.error: (new TypeError("parent is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: parent is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

console.error: (new TypeError("parent is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: parent is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

console.error: "Error while calling actor 'pagestyle's method 'getLayout'" "node is null"
console.error: (new TypeError("node is null", "resource://devtools/server/actors/page-style.js", 1001))
console.error: (new Error("Protocol error (TypeError): node is null from: server0.conn0.windowGlobal4294967299/pagestyle26 (resource://devtools/server/actors/page-style.js:1001:5)", "resource://devtools/shared/protocol/Front.js", 365))
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, 1650438179201	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "60613" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileshvRqG"
1650438179787	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileshvRqG\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:60613/devtools/browser/20bd2d04-9bb5-44c1-89fb-49df07cee55c
1650438182624	Marionette	INFO	Listening on port 60618
1650438182926	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
JavaScript error: resource://gre/modules/LoginManagerParent.jsm, line 136: TypeError: gRecipeManager is null
JavaScript warning: https://gen-bizbd.com/web/content/53594-92c9dad/web.assets_backend.js, line 5051: unreachable code after return statement
1650438263332	Marionette	INFO	Stopped listening on port 60611650438264502	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "54469" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileCQ8RlR"
1650438265014	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileCQ8RlR\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:54469/devtools/browser/ef56dbbe-aea4-43e6-bc08-b5668715df87
1650438267531	Marionette	INFO	Listening on port 54475
1650438267732	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
JavaScript error: resource://gre/modules/LoginManagerParent.jsm, line 136: TypeError: gRecipeManager is null
JavaScript warning: https://gen-bizbd.com/web/content/53594-92c9dad/web.assets_backend.js, line 5051: unreachable code after return statement
SourceActor threw an exception: [Exception... "Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]"  nsresult: "0x80470002 (NS_BASE_STREAM_CLOSED)"  location: "JS frame :: resource://devtools/shared/DevToolsUtils.js :: onResponse :: line 567"  data: no]
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:567:34
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 567, column: 0
console.error: ({})
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 567: NS_BASE_STREAM_CLOSED: Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]
SourceActor threw an exception: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:556:16
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 556, column: 16
console.error: (new Error("Failed to fetch https://gen-bizbd.com/web. Code 2152924148.", "resource://devtools/shared/DevToolsUtils.js", 556))
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 556: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
console.error: "Error while calling actor 'pagestyle's method 'getLayout'" "node is null"
console.error: (new TypeError("node is null", "resource://devtools/server/actors/page-style.js", 1001))
console.error: (new TypeError("parent is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: parent is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

console.error: (new TypeError("container.node.targetFront is null", "resource://devtools/client/inspector/markup/markup.js", 2320))
console.error: (new Error("Protocol error (TypeError): node is null from: server0.conn0.windowGlobal4294967299/pagestyle26 (resource://devtools/server/actors/page-style.js:1001:5)", "resource://devtools/shared/protocol/Front.js", 365))
console.error: (new TypeError("parent is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: parent is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

JavaScript error: , line 0: NS_ERROR_NOT_AVAILABLE
JavaScript error: , line 0: NotFoundError: No such JSWindowActor 'DevToolsFrame'
console.error: "Error while calling actor 'pagestyle's method 'getApplied'" "node is null"
console.error: (new TypeError("node is null", "resource://devtools/server/actors/page-style.js", 570))
console.error: (new TypeError("parent is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: parent is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

console.error: (new Error("Protocol error (TypeError): node is null from: server0.conn1.windowGlobal4294967299/pagestyle26 (resource://devtools/server/actors/page-style.js:570:5)", "resource://devtools/shared/protocol/Front.js", 365))
console.error: "Error while calling actor 'pagestyle's method 'getLayout'" "node is null"
console.error: (new TypeError("node is null", "resource://devtools/server/actors/page-style.js", 1001))
console.error: (new TypeError("parent is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: parent is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

console.error: (new Error("Protocol error (TypeError): node is null from: server0.conn1.windowGlobal4294967299/pagestyle26 (resource://devtools/server/actors/page-style.js:1001:5)", "resource://devtools/shared/protocol/Front.js", 365))
JavaScript error: , line 0: NotFoundError: No such JSWindowActor 'DevToolsFrame'
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, 1650447539065	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "62342" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileIEWMkk"
1650447539735	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileIEWMkk\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:62342/devtools/browser/5799a40b-5cba-4b90-ade2-472496a31cae
1650447542568	Marionette	INFO	Listening on port 62348
1650447542842	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
JavaScript error: resource://gre/modules/LoginManagerParent.jsm, line 136: TypeError: gRecipeManager is null
JavaScript warning: https://gen-bizbd.com/web/content/53594-92c9dad/web.assets_backend.js, line 5051: unreachable code after return statement
SourceActor threw an exception: [Exception... "Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]"  nsresult: "0x80470002 (NS_BASE_STREAM_CLOSED)"  location: "JS frame :: resource://devtools/shared/DevToolsUtils.js :: onResponse :: line 567"  data: no]
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:567:34
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 567, column: 0
console.error: ({})
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 567: NS_BASE_STREAM_CLOSED: Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]
SourceActor threw an exception: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:556:16
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 556, column: 16
console.error: (new Error("Failed to fetch https://gen-bizbd.com/web. Code 2152924148.", "resource://devtools/shared/DevToolsUtils.js", 556))
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 556: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
console.error: (new TypeError("parent is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: parent is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

console.error: (new TypeError("parent is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: parent is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

console.error: "Error while calling actor 'pagestyle's method 'getApplied'" "node is null"
console.error: (new TypeError("node is null", "resource://devtools/server/actors/page-style.js", 570))
console.error: (new Error("Protocol error (TypeError): node is null from: server0.conn0.windowGlobal4294967299/pagestyle26 (resource://devtools/server/actors/page-style.js:570:5)", "resource://devtools/shared/protocol/Front.js", 365))
console.error: (new TypeError("parent is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: parent is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

console.error: (new TypeError("container.node.targetFront is null", "resource://devtools/client/inspector/markup/markup.js", 2320))
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, 1650447937302	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "58008" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileDwrC2l"
1650447937915	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileDwrC2l\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:58008/devtools/browser/1a32eb4c-0d11-47b5-bb92-c04a1fc3890e
1650447940390	Marionette	INFO	Listening on port 58029
1650447940542	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
JavaScript error: resource://gre/modules/LoginManagerParent.jsm, line 136: TypeError: gRecipeManager is null
JavaScript warning: https://gen-bizbd.com/web/content/53594-92c9dad/web.assets_backend.js, line 5051: unreachable code after return statement
1650448073928	Marionette	INFO	Stopped listening on port 58021650448075562	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "56579" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileywARj1"
1650448076184	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileywARj1\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:56579/devtools/browser/048ae492-e924-49fd-8ceb-34ebced6c8cd
1650448078652	Marionette	INFO	Listening on port 56584
1650448078807	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
JavaScript error: resource://gre/modules/LoginManagerParent.jsm, line 136: TypeError: gRecipeManager is null
JavaScript warning: https://gen-bizbd.com/web/content/53594-92c9dad/web.assets_backend.js, line 5051: unreachable code after return statement
1650448213014	Marionette	WARN	TimedPromise timed out after 500 ms: stacktrace:
TimedPromise/<@chrome://remote/content/marionette/sync.js:235:19
TimedPromise@chrome://remote/content/marionette/sync.js:220:10
interaction.flushEventLoop@chrome://remote/content/marionette/interaction.js:431:10
webdriverClickElement@chrome://remote/content/marionette/interaction.js:179:31
1650448215236	Marionette	INFO	Stopped listening on port 56584

###!!! [Child][PContentChild] Error: RunMessage(msgname=PHttpChannel::Msg_DeleteSelf) Channel closing: too late to send/recv, messages will be lost

1650448801891	geckodriver	INFO	Listening on 127.0.0.1:51229
1650448804993	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "51230" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileHHlK5X"
1650448805626	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileHHlK5X\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:51230/devtools/browser/efaa05f5-be37-458c-ab29-f3122a1e6ff8
1650448808801	Marionette	INFO	Listening on port 51235
1650448809242	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
JavaScript error: resource://gre/modules/LoginManagerParent.jsm, line 136: TypeError: gRecipeManager is null
JavaScript warning: https://gen-bizbd.com/web/content/53594-92c9dad/web.assets_backend.js, line 5051: unreachable code after return statement
1650448901968	Marionette	INFO	Stopped listening on port 51231650448903600	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "51295" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileSnO2dx"
1650448904141	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileSnO2dx\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:51295/devtools/browser/b3db327c-d745-4220-a26a-499f8883b0e1
1650448906863	Marionette	INFO	Listening on port 51302
1650448907333	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
JavaScript error: resource://gre/modules/LoginManagerParent.jsm, line 136: TypeError: gRecipeManager is null
JavaScript warning: https://gen-bizbd.com/web/content/53594-92c9dad/web.assets_backend.js, line 5051: unreachable code after return statement
1650449503616	Marionette	INFO	Stopped listening on port 51301650449505077	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "55192" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofile5EDlrc"
1650449505682	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofile5EDlrc\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:55192/devtools/browser/09e15d01-7d93-4143-bdac-6fe6a6a27ef3
1650449508208	Marionette	INFO	Listening on port 55199
1650449508301	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
JavaScript error: resource://gre/modules/LoginManagerParent.jsm, line 136: TypeError: gRecipeManager is null
1650450060210	Marionette	INFO	Stopped listening on port 5519165console.warn: TopSitesFeed: Failed to fetch data from Contile server: NetworkError when attempting to fetch resource.
e" "--remote-debugging-port" "55503" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofilezs0bef"
1650450061344	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofilezs0bef\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:55503/devtools/browser/473322d4-5580-4c39-9412-0de429afb083
1650450064851	Marionette	INFO	Listening on port 55508
1650450064925	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
JavaScript error: resource://gre/modules/LoginManagerParent.jsm, line 136: TypeError: gRecipeManager is null
JavaScript warning: https://gen-bizbd.com/web/content/53594-92c9dad/web.assets_backend.js, line 5051: unreachable code after return statement
JavaScript error: , line 0: NS_ERROR_NOT_AVAILABLE
1650455426307	Marionette	INFO	Stopped listening on port 55508
console.warn: TopSitesFeed: Failed to fetch data from Contile server: NetworkError when attempting to fetch resource.

###!!! [Child][PContentChild] Error: RunMessage(msgname=PHttpChannel::Msg_DeleteSelf) Channel closing: too late to send/recv, messages will be lost

1650455428979	geckodriver	INFO	Listening on 127.0.0.1:53618
1650455432035	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "53619" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileigI6GC"
1650455432653	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileigI6GC\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:53619/devtools/browser/d4ecba45-f658-453a-8ef8-0b5ecf2913cd
1650455435280	Marionette	INFO	Listening on port 53624
1650455435371	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
JavaScript error: resource://gre/modules/LoginManagerParent.jsm, line 136: TypeError: gRecipeManager is null
JavaScript warning: https://gen-bizbd.com/web/content/53594-92c9dad/web.assets_backend.js, line 5051: unreachable code after return statement
SourceActor threw an exception: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:556:16
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 556, column: 16
console.error: (new Error("Failed to fetch https://gen-bizbd.com/web. Code 2152924148.", "resource://devtools/shared/DevToolsUtils.js", 556))
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 556: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
SourceActor threw an exception: [Exception... "Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]"  nsresult: "0x80470002 (NS_BASE_STREAM_CLOSED)"  location: "JS frame :: resource://devtools/shared/DevToolsUtils.js :: onResponse :: line 567"  data: no]
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:567:34
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 567, column: 0
console.error: ({})
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 567: NS_BASE_STREAM_CLOSED: Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]
console.error: "Error while calling actor 'pagestyle's method 'getLayout'" "node is null"
console.error: (new TypeError("node is null", "resource://devtools/server/actors/page-style.js", 1001))
console.error: (new TypeError("parent is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: parent is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

console.error: (new Error("Protocol error (TypeError): node is null from: server0.conn0.windowGlobal4294967299/pagestyle24 (resource://devtools/server/actors/page-style.js:1001:5)", "resource://devtools/shared/protocol/Front.js", 365))
console.error: (new TypeError("parent is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: parent is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

console.error: "Error while calling actor 'pagestyle's method 'getLayout'" "node is null"
console.error: (new TypeError("node is null", "resource://devtools/server/actors/page-style.js", 1001))
console.error: (new Error("Protocol error (TypeError): node is null from: server0.conn0.windowGlobal4294967299/pagestyle24 (resource://devtools/server/actors/page-style.js:1001:5)", "resource://devtools/shared/protocol/Front.js", 365))
console.error: (new TypeError("parent is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: parent is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

console.error: (new TypeError("container.node.targetFront is null", "resource://devtools/client/inspector/markup/markup.js", 2320))
console.error: (new TypeError("container.node.targetFront is null", "resource://devtools/client/inspector/markup/markup.js", 2320))
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, 1650455708959	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "58770" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileKx49Be"
1650455709558	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileKx49Be\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:58770/devtools/browser/0729ae21-3256-480d-8402-1a1be553cb95
1650455712448	Marionette	INFO	Listening on port 58776
1650455712696	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
JavaScript error: resource://gre/modules/LoginManagerParent.jsm, line 136: TypeError: gRecipeManager is null
JavaScript warning: https://gen-bizbd.com/web/content/53594-92c9dad/web.assets_backend.js, line 5051: unreachable code after return statement
SourceActor threw an exception: [Exception... "Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]"  nsresult: "0x80470002 (NS_BASE_STREAM_CLOSED)"  location: "JS frame :: resource://devtools/shared/DevToolsUtils.js :: onResponse :: line 567"  data: no]
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:567:34
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 567, column: 0
console.error: ({})
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 567: NS_BASE_STREAM_CLOSED: Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]
SourceActor threw an exception: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:556:16
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 556, column: 16
console.error: (new Error("Failed to fetch https://gen-bizbd.com/web. Code 2152924148.", "resource://devtools/shared/DevToolsUtils.js", 556))
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 556: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
console.error: (new TypeError("parent is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: parent is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

console.error: (new TypeError("parent is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: parent is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

console.error: (new TypeError("container.node.targetFront is null", "resource://devtools/client/inspector/markup/markup.js", 2320))
console.error: "Error while calling actor 'pagestyle's method 'getApplied'" "node is null"
console.error: (new TypeError("node is null", "resource://devtools/server/actors/page-style.js", 570))
console.error: (new TypeError("parent is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: parent is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

console.error: (new TypeError("container.node.targetFront is null", "resource://devtools/client/inspector/markup/markup.js", 2320))
console.error: (new Error("Protocol error (TypeError): node is null from: server0.conn0.windowGlobal4294967299/pagestyle26 (resource://devtools/server/actors/page-style.js:570:5)", "resource://devtools/shared/protocol/Front.js", 365))
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, 1650456139195	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "57309" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofilegws5LU"
1650456139747	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofilegws5LU\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:57309/devtools/browser/2d922d38-fd55-4a72-a420-5a472375506d
1650456142265	Marionette	INFO	Listening on port 57316
1650456142430	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
JavaScript error: resource://gre/modules/LoginManagerParent.jsm, line 136: TypeError: gRecipeManager is null
JavaScript warning: https://gen-bizbd.com/web/content/53594-92c9dad/web.assets_backend.js, line 5051: unreachable code after return statement
SourceActor threw an exception: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:556:16
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 556, column: 16
console.error: (new Error("Failed to fetch https://gen-bizbd.com/web. Code 2152924148.", "resource://devtools/shared/DevToolsUtils.js", 556))
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 556: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
SourceActor threw an exception: [Exception... "Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]"  nsresult: "0x80470002 (NS_BASE_STREAM_CLOSED)"  location: "JS frame :: resource://devtools/shared/DevToolsUtils.js :: onResponse :: line 567"  data: no]
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:567:34
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 567, column: 0
console.error: ({})
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 567: NS_BASE_STREAM_CLOSED: Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, 1650456322554	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "50831" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofilep6pBz1"
1650456323113	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofilep6pBz1\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:50831/devtools/browser/c922a9b9-cfb1-4775-81cd-81a9d2282a65
1650456326168	Marionette	INFO	Listening on port 50836
1650456326313	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
JavaScript error: resource://gre/modules/LoginManagerParent.jsm, line 136: TypeError: gRecipeManager is null
JavaScript warning: https://gen-bizbd.com/web/content/53594-92c9dad/web.assets_backend.js, line 5051: unreachable code after return statement
1650456416048	Marionette	WARN	TimedPromise timed out after 500 ms: stacktrace:
TimedPromise/<@chrome://remote/content/marionette/sync.js:235:19
TimedPromise@chrome://remote/content/marionette/sync.js:220:10
interaction.flushEventLoop@chrome://remote/content/marionette/interaction.js:431:10
webdriverClickElement@chrome://remote/content/marionette/interaction.js:179:31
1650456418268	Marionette	INFO	Stopped listening on port 50836

###!!! [Parent][PContentParent] Error: Send(msgname=PContent::Msg_DestroyBrowsingContextGroup) Closed channel: cannot send/recv


###!!! [Child][PContentChild] Error: Send(msgname=PHttpChannel::Msg_DeletingChannel) Channel closing: too late to send/recv, messages will be lost


###!!! [Child][PContentChild] Error: RunMessage(msgname=PContent::Reply_DiscardBrowsingContext) Channel closing: too late to send/recv, messages will be lost

1650522953912	geckodriver	INFO	Listening on 127.0.0.1:53476
1650522956932	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "53477" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileBfZ8GP"
1650522958303	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileBfZ8GP\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:53477/devtools/browser/adbb886f-103c-4be8-ac1e-ec39ada2cdc7
1650522961944	Marionette	INFO	Listening on port 53482
1650522962361	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
1650522963618	Marionette	INFO	Stopped listening on port 53482
console.warn: TopSitesFeed: Failed to fetch data from Contile server: NetworkError when attempting to fetch resource.
JavaScript error: chrome://remote/content/marionette/cert.js, line 55: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsICertOverrideService.setDisableAllSecurityChecksAndLetAttackersInterceptMyData]

###!!! [Child][PContentChild] Error: RunMessage(msgname=PHttpChannel::Msg_DeleteSelf) Channel closing: too late to send/recv, messages will be lost


###!!! [Child][PContentChild] Error: RunMessage(msgname=PHttpChannel::Msg_DeleteSelf) Channel closing: too late to send/recv, messages will be lost


###!!! [Child][PContentChild] Error: RunMessage(msgname=PHttpChannel::Msg_DeleteSelf) Channel closing: too late to send/recv, messages will be lost


###!!! [Child][PContentChild] Error: RunMessage(msgname=PHttpChannel::Msg_DeleteSelf) Channel closing: too late to send/recv, messages will be lost


###!!! [Child][PContentChild] Error: Send(msgname=PBrowser::Msg___delete__) Channel closing: too late to send/recv, messages will be lost


###!!! [Parent][PContentParent] Error: Send(msgname=PContent::Msg_DestroyBrowsingContextGroup) Closed channel: cannot send/recv

JavaScript error: resource://gre/modules/Sqlite.jsm, line 1105: Error: Sqlite.jsm has been shutdown. Cannot open connection to: C:\Users\ALAM~1.RAS\AppData\Local\Temp\rust_mozprofileBfZ8GP\protections.sqlite

###!!! [Parent][PGPUParent] Error: RunMessage(msgname=PGPU::Msg_ShutdownVR) Channel closing: too late to send/recv, messages will be lost

1650522978522	geckodriver	INFO	Listening on 127.0.0.1:53517
1650522981599	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "53518" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileBaSwxA"
1650522982131	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileBaSwxA\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:53518/devtools/browser/16ee2e7f-e9bb-4a8c-8ef1-4597b699f4f4
1650522985041	Marionette	INFO	Listening on port 53523
1650522985328	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
JavaScript error: resource://gre/modules/LoginManagerParent.jsm, line 136: TypeError: gRecipeManager is null
JavaScript warning: https://gen-bizbd.com/web/content/53594-92c9dad/web.assets_backend.js, line 5051: unreachable code after return statement
1650523075370	Marionette	WARN	TimedPromise timed out after 500 ms: stacktrace:
TimedPromise/<@chrome://remote/content/marionette/sync.js:235:19
TimedPromise@chrome://remote/content/marionette/sync.js:220:10
interaction.flushEventLoop@chrome://remote/content/marionette/interaction.js:431:10
webdriverClickElement@chrome://remote/content/marionette/interaction.js:179:31
1650523077586	Marionette	INFO	Stopped listening on port 53523

###!!! [Parent][PContentParent] Error: Send(msgname=PContent::Msg_DestroyBrowsingContextGroup) Closed channel: cannot send/recv


###!!! [Child][PContentChild] Error: RunMessage(msgname=PContent::Reply_DiscardBrowsingContext) Channel closing: too late to send/recv, messages will be lost


###!!! [Child][PContentChild] Error: RunMessage(msgname=PHttpChannel::Msg_DeleteSelf) Channel closing: too late to send/recv, messages will be lost

1650523183637	geckodriver	INFO	Listening on 127.0.0.1:60007
1650523186717	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "60008" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofilej6HRTo"
1650523187290	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofilej6HRTo\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:60008/devtools/browser/39910aca-9b44-4519-9039-d9693dedf860
1650523190088	Marionette	INFO	Listening on port 60013
1650523190440	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.error: Region.jsm: "Error fetching region" (new Error("TIMEOUT", "resource://gre/modules/Region.jsm", 772))
console.error: Region.jsm: "Failed to fetch region" (new Error("TIMEOUT", "resource://gre/modules/Region.jsm", 419))
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
JavaScript error: resource://gre/modules/LoginManagerParent.jsm, line 136: TypeError: gRecipeManager is null
1650523566095	Marionette	INFO	Stopped listening on port 60013
console.warn: TopSitesFeed: Failed to fetch data from Contile server: NetworkError when attempting to fetch resource.
e" "--remote-debugging-port" "52334" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileEcJOBW"
1650523471143	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileEcJOBW\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:52334/devtools/browser/d9282eca-5e6e-4341-b1f5-b4f36ad4e25e
1650523474227	Marionette	INFO	Listening on port 52340
1650523474289	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
JavaScript error: resource://gre/modules/LoginManagerParent.jsm, line 136: TypeError: gRecipeManager is null
JavaScript warning: https://gen-bizbd.com/web/content/53594-92c9dad/web.assets_backend.js, line 5051: unreachable code after return statement
SourceActor threw an exception: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:556:16
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 556, column: 16
console.error: (new Error("Failed to fetch https://gen-bizbd.com/web. Code 2152924148.", "resource://devtools/shared/DevToolsUtils.js", 556))
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 556: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
SourceActor threw an exception: [Exception... "Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]"  nsresult: "0x80470002 (NS_BASE_STREAM_CLOSED)"  location: "JS frame :: resource://devtools/shared/DevToolsUtils.js :: onResponse :: line 567"  data: no]
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:567:34
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 567, column: 0
console.error: ({})
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 567: NS_BASE_STREAM_CLOSED: Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]
console.error: (new TypeError("parent is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: parent is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

JavaScript error: resource://devtools/server/actors/page-style.js, line 570: TypeError: node is null
console.error: "Error while calling actor 'pagestyle's method 'getApplied'" "node is null"
console.error: (new TypeError("node is null", "resource://devtools/server/actors/page-style.js", 570))
console.error: (new Error("Protocol error (TypeError): node is null from: server0.conn0.windowGlobal4294967299/pagestyle24 (resource://devtools/server/actors/page-style.js:570:5)", "resource://devtools/shared/protocol/Front.js", 365))
console.error: (new TypeError("parent is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: parent is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 575: NotFoundError: No such JSWindowActor 'DevToolsFrame'
1650523772214	Marionette	INFO	Stopped listening on port 52340
1650523775056	geckodriver	INFO	Listening on 127.0.0.1:54255
1650523778126	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "54256" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofiledRjuQf"
1650523778839	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofiledRjuQf\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:54256/devtools/browser/686d4ec0-5384-4248-bfa2-e2d162f929a1
1650523782122	Marionette	INFO	Listening on port 54261
1650523782426	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
JavaScript error: resource://gre/modules/LoginManagerParent.jsm, line 136: TypeError: gRecipeManager is null
JavaScript warning: https://gen-bizbd.com/web/content/53594-92c9dad/web.assets_backend.js, line 5051: unreachable code after return statement
SourceActor threw an exception: [Exception... "Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]"  nsresult: "0x80470002 (NS_BASE_STREAM_CLOSED)"  location: "JS frame :: resource://devtools/shared/DevToolsUtils.js :: onResponse :: line 567"  data: no]
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:567:34
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 567, column: 0
console.error: ({})
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 567: NS_BASE_STREAM_CLOSED: Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]
SourceActor threw an exception: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:556:16
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 556, column: 16
console.error: (new Error("Failed to fetch https://gen-bizbd.com/web. Code 2152924148.", "resource://devtools/shared/DevToolsUtils.js", 556))
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 556: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, 1650523858623	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "63552" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofilehWk1NO"
1650523859393	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofilehWk1NO\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:63552/devtools/browser/23d1e937-0aae-4ba8-b43c-9e7bb9d7a3f8
1650523862411	Marionette	INFO	Listening on port 63557
1650523862911	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
JavaScript error: resource://gre/modules/LoginManagerParent.jsm, line 136: TypeError: gRecipeManager is null
JavaScript warning: https://gen-bizbd.com/web/content/53594-92c9dad/web.assets_backend.js, line 5051: unreachable code after return statement
SourceActor threw an exception: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:556:16
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 556, column: 16
console.error: (new Error("Failed to fetch https://gen-bizbd.com/web. Code 2152924148.", "resource://devtools/shared/DevToolsUtils.js", 556))
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 556: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
SourceActor threw an exception: [Exception... "Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]"  nsresult: "0x80470002 (NS_BASE_STREAM_CLOSED)"  location: "JS frame :: resource://devtools/shared/DevToolsUtils.js :: onResponse :: line 567"  data: no]
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:567:34
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 567, column: 0
console.error: ({})
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 567: NS_BASE_STREAM_CLOSED: Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]
console.error: (new TypeError("parent is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: parent is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

JavaScript error: , line 0: NotFoundError: No such JSWindowActor 'DevToolsFrame'
SourceActor threw an exception: [Exception... "Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]"  nsresult: "0x80470002 (NS_BASE_STREAM_CLOSED)"  location: "JS frame :: resource://devtools/shared/DevToolsUtils.js :: onResponse :: line 567"  data: no]
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:567:34
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 567, column: 0
console.error: ({})
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 567: NS_BASE_STREAM_CLOSED: Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]
SourceActor threw an exception: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:556:16
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 556, column: 16
console.error: (new Error("Failed to fetch https://gen-bizbd.com/web. Code 2152924148.", "resource://devtools/shared/DevToolsUtils.js", 556))
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 556: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, 1650524154457	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "49836" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofilehcxbZI"
1650524155077	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofilehcxbZI\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:49836/devtools/browser/e2b72af0-1caa-4cbc-bf1c-704174afa461
1650524157835	Marionette	INFO	Listening on port 49841
1650524158211	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
JavaScript error: resource://gre/modules/LoginManagerParent.jsm, line 136: TypeError: gRecipeManager is null
JavaScript warning: https://gen-bizbd.com/web/content/53594-92c9dad/web.assets_backend.js, line 5051: unreachable code after return statement
SourceActor threw an exception: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:556:16
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 556, column: 16
console.error: (new Error("Failed to fetch https://gen-bizbd.com/web. Code 2152924148.", "resource://devtools/shared/DevToolsUtils.js", 556))
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 556: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
SourceActor threw an exception: [Exception... "Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]"  nsresult: "0x80470002 (NS_BASE_STREAM_CLOSED)"  location: "JS frame :: resource://devtools/shared/DevToolsUtils.js :: onResponse :: line 567"  data: no]
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:567:34
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 567, column: 0
console.error: ({})
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 567: NS_BASE_STREAM_CLOSED: Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]
console.error: (new TypeError("parent is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: parent is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

console.error: (new TypeError("parent is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: parent is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

console.error: "Error while calling actor 'pagestyle's method 'getLayout'" "node is null"
console.error: (new TypeError("node is null", "resource://devtools/server/actors/page-style.js", 1001))
console.error: (new Error("Protocol error (TypeError): node is null from: server0.conn0.windowGlobal4294967299/pagestyle26 (resource://devtools/server/actors/page-style.js:1001:5)", "resource://devtools/shared/protocol/Front.js", 365))
console.error: (new TypeError("parent is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: parent is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

console.error: "Error when attaching target:" (new Error("Connection closed, pending request to server0.conn0.windowGlobal4294967325/thread1, type isAttached failed\n\nRequest stack:\nrequest@resource://devtools/shared/protocol/Front.js:292:14\ngenerateRequestMethods/</frontProto[name]@resource://devtools/shared/protocol/Front/FrontClassWithSpec.js:46:19\nattachThread@resource://devtools/client/fronts/targets/target-mixin.js:573:49\n", "resource://devtools/shared/protocol/Front.js", 106))
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
console.error: (new TypeError("parent is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: parent is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

console.error: (new TypeError("container.node.targetFront is null", "resource://devtools/client/inspector/markup/markup.js", 2320))
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
Handler function threw an exception: [Exception... "Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]"  nsresult: "0x80040111 (NS_ERROR_NOT_AVAILABLE)"  location: "JS frame :: resource://devtools/server/actors/targets/window-global.js :: watch :: line 1662"  data: no]
Stack: watch@resource://devtools/server/actors/targets/window-global.js:1662:28
_watchDocshells@resource://devtools/server/actors/targets/window-global.js:773:28
initialize/<@resource://devtools/server/actors/targets/window-global.js:346:42
exports.makeInfallible/<@resource://devtools/shared/ThreadSafeDevToolsUtils.js:103:22
Line: 1662, column: 0
console.error: ({})
console.error: "Error while calling actor 'thread's method 'isAttached'" "JSWindowActorChild.sendAsyncMessage: JSWindowActorChild cannot send at the moment"
console.error: (new InvalidStateError("JSWindowActorChild.sendAsyncMessage: JSWindowActorChild cannot send at the moment", (void 0), 402))
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
console.error: "Error when destroying StyleSheet manager for" ({notifyResourceAvailable:function bound notifyResourceAvailable() {
    [native code]
}, notifyResourceDestroyed:function bound notifyResourceDestroyed() {
    [native code]
}, notifyResourceUpdated:function bound notifyResourceUpdated() {
    [native code]
}, conn:{_prefix:"server0.conn0.windowGlobal4294967325/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967325", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {conn:{}, __poolMap:{}}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, actorID:"server0.conn0.windowGlobal4294967325/windowGlobalTarget2", _actorSpec:{typeName:"windowGlobalTarget", methods:[{name:"detach", request:{type:"detach", template:{type:"detach"}, args:[]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"ensureCSSErrorReportingEnabled", request:{type:"ensureCSSErrorReportingEnabled", template:{type:"ensureCSSErrorReportingEnabled"}, args:[]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"focus", request:{type:"focus", template:{type:"focus"}, args:[]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"goForward", request:{type:"goForward", template:{type:"goForward"}, args:[]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"goBack", request:{type:"goBack", template:{type:"goBack"}, args:[]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"reload", request:{type:"reload", template:{type:"reload", options:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["options"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"navigateTo", request:{type:"navigateTo", template:{type:"navigateTo", url:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["url"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"reconfigure", request:{type:"reconfigure", template:{type:"reconfigure", options:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["options"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"switchToFrame", request:{type:"switchToFrame", template:{type:"switchToFrame", windowId:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["windowId"]}]}, response:{template:{_type:"windowGlobalTarget.switchtoframe", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, retVal:{_type:"windowGlobalTarget.switchtoframe", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:[]}, release:(void 0), oneway:(void 0)}, {name:"listFrames", request:{type:"listFrames", template:{type:"listFrames"}, args:[]}, response:{template:{_type:"windowGlobalTarget.listframes", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, retVal:{_type:"windowGlobalTarget.listframes", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:[]}, release:(void 0), oneway:(void 0)}, {name:"listWorkers", request:{type:"listWorkers", template:{type:"listWorkers"}, args:[]}, response:{template:{_type:"windowGlobalTarget.workers", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, retVal:{_type:"windowGlobalTarget.workers", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:[]}, release:(void 0), oneway:(void 0)}, {name:"logInPage", request:{type:"logInPage", template:{type:"logInPage", text:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, category:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, flags:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["text"]}, {placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["category"]}, {placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["flags"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}], events:{}}, docShell:({}), _originalWindow:{get window() {
    [native code]
}, get document() {
    [native code]
}, get location() {
    [native code]
}, set location() {
    [native code]
}, get top() {
    [native code]
}, close:function close() {
    [native code]
}, stop:function stop() {
    [native code]
}, focus:function focus() {
    [native code]
}, blur:function blur() {
    [native code]
}, open:function open() {
    [native code]
}, alert:function alert() {
    [native code]
}, confirm:function confirm() {
    [native code]
}, prompt:function prompt() {
    [native code]
}, print:function print() {
    [native code]
}, printPreview:function printPreview() {
    [native code]
}, postMessage:function postMessage() {
    [native code]
}, captureEvents:function captureEvents() {
    [native code]
}, releaseEvents:function releaseEvents() {
    [native code]
}, getSelection:function getSelection() {
    [native code]
}, getComputedStyle:function getComputedStyle() {
    [native code]
}, matchMedia:function matchMedia() {
    [native code]
}, moveTo:function moveTo() {
    [native code]
}, moveBy:function moveBy() {
    [native code]
}, resizeTo:function resizeTo() {
    [native code]
}, resizeBy:function resizeBy() {
    [native code]
}, scroll:function scroll() {
    [native code]
}, scrollTo:function scrollTo() {
    [native code]
}, scrollBy:function scrollBy() {
    [native code]
}, getDefaultComputedStyle:function getDefaultComputedStyle() {
    [native code]
}, scrollByLines:function scrollByLines() {
    [native code]
}, scrollByPages:function scrollByPages() {
    [native code]
}, sizeToContent:function sizeToContent() {
    [native code]
}, updateCommands:function updateCommands() {
    [native code]
}, find:function find() {
    [native code]
}, dump:function dump() {
    [native code]
}, setResizable:function setResizable() {
    [native code]
}, requestIdleCallback:function requestIdleCallback() {
    [native code]
}, cancelIdleCallback:function cancelIdleCallback() {
    [native code]
}, getRegionalPrefsLocales:function getRegionalPrefsLocales() {
    [native code]
}, getWebExposedLocales:function getWebExposedLocales() {
    [native code]
}, requestAnimationFrame:function requestAnimationFrame() {
    [native code]
}, cancelAnimationFrame:function cancelAnimationFrame() {
    [native code]
}, reportError:function reportError() {
    [native code]
}, btoa:function btoa() {
    [native code]
}, atob:function atob() {
    [native code]
}, setTimeout:function setTimeout() {
    [native code]
}, clearTimeout:function clearTimeout() {
    [native code]
}, setInterval:function setInterval() {
    [native code]
}, clearInterval:function clearInterval() {
    [native code]
}, queueMicrotask:function queueMicrotask() {
    [native code]
}, createImageBitmap:function createImageBitmap() {
    [native code]
}, structuredClone:function structuredClone() {
    [native code]
}, fetch:function fetch() {
    [native code]
}, get self() {
    [native code]
}, set self() {
    [native code]
}, get name() {
    [native code]
}, set name() {
    [native code]
}, get history() {
    [native code]
}, get customElements() {
    [native code]
}, get locationbar() {
    [native code]
}, set locationbar() {
    [native code]
}, get menubar() {
    [native code]
}, set menubar() {
    [native code]
}, get personalbar() {
    [native code]
}, set personalbar() {
    [native code]
}, get scrollbars() {
    [native code]
}, set scrollbars() {
    [native code]
}, get statusbar() {
    [native code]
}, set statusbar() {
    [native code]
}, get toolbar() {
    [native code]
}, set toolbar() {
    [native code]
}, get status() {
    [native code]
}, set status() {
    [native code]
}, get closed() {
    [native code]
}, get event() {
    [native code]
}, set event() {
    [native code]
}, get frames() {
    [native code]
}, set frames() {
    [native code]
}, get length() {
    [native code]
}, set length() {
    [native code]
}, get opener() {
    [native code]
}, set opener() {
    [native code]
}, get parent() {
    [native code]
}, set parent() {
    [native code]
}, get frameElement() {
    [native code]
}, get navigator() {
    [native code]
}, get clientInformation() {
    [native code]
}, get external() {
    [native code]
}, set external() {
    [native code]
}, get screen() {
    [native code]
}, set screen() {
    [native code]
}, get innerWidth() {
    [native code]
}, set innerWidth() {
    [native code]
}, get innerHeight() {
    [native code]
}, set innerHeight() {
    [native code]
}, get scrollX() {
    [native code]
}, set scrollX() {
    [native code]
}, get pageXOffset() {
    [native code]
}, set pageXOffset() {
    [native code]
}, get scrollY() {
    [native code]
}, set scrollY() {
    [native code]
}, get pageYOffset() {
    [native code]
}, set pageYOffset() {
    [native code]
}, get screenLeft() {
    [native code]
}, set screenLeft() {
    [native code]
}, get screenTop() {
    [native code]
}, set screenTop() {
    [native code]
}, get screenX() {
    [native code]
}, set screenX() {
    [native code]
}, get screenY() {
    [native code]
}, set screenY() {
    [native code]
}, get outerWidth() {
    [native code]
}, set outerWidth() {
    [native code]
}, get outerHeight() {
    [native code]
}, set outerHeight() {
    [native code]
}, get performance() {
    [native code]
}, set performance() {
    [native code]
}, get mozInnerScreenX() {
    [native code]
}, get mozInnerScreenY() {
    [native code]
}, get devicePixelRatio() {
    [native code]
}, set devicePixelRatio() {
    [native code]
}, get scrollMaxX() {
    [native code]
}, set scrollMaxX() {
    [native code]
}, get scrollMaxY() {
    [native code]
}, set scrollMaxY() {
    [native code]
}, get fullScreen() {
    [native code]
}, set fullScreen() {
    [native code]
}, get ondevicemotion() {
    [native code]
}, set ondevicemotion() {
    [native code]
}, get ondeviceorientation() {
    [native code]
}, set ondeviceorientation() {
    [native code]
}, get onabsolutedeviceorientation() {
    [native code]
}, set onabsolutedeviceorientation() {
    [native code]
}, get InstallTrigger() {
    [native code]
}, set InstallTrigger() {
    [native code]
}, get intlUtils() {
    [native code]
}, get visualViewport() {
    [native code]
}, set visualViewport() {
    [native code]
}, get crypto() {
    [native code]
}, get onabort() {
    [native code]
}, set onabort() {
    [native code]
}, get onblur() {
    [native code]
}, set onblur() {
    [native code]
}, get onfocus() {
    [native code]
}, set onfocus() {
    [native code]
}, get onauxclick() {
    [native code]
}, set onauxclick() {
    [native code]
}, get onbeforeinput() {
    [native code]
}, set onbeforeinput() {
    [native code]
}, get oncanplay() {
    [native code]
}, set oncanplay() {
    [native code]
}, get oncanplaythrough() {
    [native code]
}, set oncanplaythrough() {
    [native code]
}, get onchange() {
    [native code]
}, set onchange() {
    [native code]
}, get onclick() {
    [native code]
}, set onclick() {
    [native code]
}, get onclose() {
    [native code]
}, set onclose() {
    [native code]
}, get oncontextmenu() {
    [native code]
}, set oncontextmenu() {
    [native code]
}, get oncuechange() {
    [native code]
}, set oncuechange() {
    [native code]
}, get ondblclick() {
    [native code]
}, set ondblclick() {
    [native code]
}, get ondrag() {
    [native code]
}, set ondrag() {
    [native code]
}, get ondragend() {
    [native code]
}, set ondragend() {
    [native code]
}, get ondragenter() {
    [native code]
}, set ondragenter() {
    [native code]
}, get ondragexit() {
    [native code]
}, set ondragexit() {
    [native code]
}, get ondragleave() {
    [native code]
}, set ondragleave() {
    [native code]
}, get ondragover() {
    [native code]
}, set ondragover() {
    [native code]
}, get ondragstart() {
    [native code]
}, set ondragstart() {
    [native code]
}, get ondrop() {
    [native code]
}, set ondrop() {
    [native code]
}, get ondurationchange() {
    [native code]
}, set ondurationchange() {
    [native code]
}, get onemptied() {
    [native code]
}, set onemptied() {
    [native code]
}, get onended() {
    [native code]
}, set onended() {
    [native code]
}, get onformdata() {
    [native code]
}, set onformdata() {
    [native code]
}, get oninput() {
    [native code]
}, set oninput() {
    [native code]
}, get oninvalid() {
    [native code]
}, set oninvalid() {
    [native code]
}, get onkeydown() {
    [native code]
}, set onkeydown() {
    [native code]
}, get onkeypress() {
    [native code]
}, set onkeypress() {
    [native code]
}, get onkeyup() {
    [native code]
}, set onkeyup() {
    [native code]
}, get onload() {
    [native code]
}, set onload() {
    [native code]
}, get onloadeddata() {
    [native code]
}, set onloadeddata() {
    [native code]
}, get onloadedmetadata() {
    [native code]
}, set onloadedmetadata() {
    [native code]
}, get onloadend() {
    [native code]
}, set onloadend() {
    [native code]
}, get onloadstart() {
    [native code]
}, set onloadstart() {
    [native code]
}, get onmousedown() {
    [native code]
}, set onmousedown() {
    [native code]
}, get onmouseenter() {
    [native code]
}, set onmouseenter() {
    [native code]
}, get onmouseleave() {
    [native code]
}, set onmouseleave() {
    [native code]
}, get onmousemove() {
    [native code]
}, set onmousemove() {
    [native code]
}, get onmouseout() {
    [native code]
}, set onmouseout() {
    [native code]
}, get onmouseover() {
    [native code]
}, set onmouseover() {
    [native code]
}, get onmouseup() {
    [native code]
}, set onmouseup() {
    [native code]
}, get onwheel() {
    [native code]
}, set onwheel() {
    [native code]
}, get onpause() {
    [native code]
}, set onpause() {
    [native code]
}, get onplay() {
    [native code]
}, set onplay() {
    [native code]
}, get onplaying() {
    [native code]
}, set onplaying() {
    [native code]
}, get onprogress() {
    [native code]
}, set onprogress() {
    [native code]
}, get onratechange() {
    [native code]
}, set onratechange() {
    [native code]
}, get onreset() {
    [native code]
}, set onreset() {
    [native code]
}, get onresize() {
    [native code]
}, set onresize() {
    [native code]
}, get onscroll() {
    [native code]
}, set onscroll() {
    [native code]
}, get onsecuritypolicyviolation() {
    [native code]
}, set onsecuritypolicyviolation() {
    [native code]
}, get onseeked() {
    [native code]
}, set onseeked() {
    [native code]
}, get onseeking() {
    [native code]
}, set onseeking() {
    [native code]
}, get onselect() {
    [native code]
}, set onselect() {
    [native code]
}, get onslotchange() {
    [native code]
}, set onslotchange() {
    [native code]
}, get onstalled() {
    [native code]
}, set onstalled() {
    [native code]
}, get onsubmit() {
    [native code]
}, set onsubmit() {
    [native code]
}, get onsuspend() {
    [native code]
}, set onsuspend() {
    [native code]
}, get ontimeupdate() {
    [native code]
}, set ontimeupdate() {
    [native code]
}, get onvolumechange() {
    [native code]
}, set onvolumechange() {
    [native code]
}, get onwaiting() {
    [native code]
}, set onwaiting() {
    [native code]
}, get onselectstart() {
    [native code]
}, set onselectstart() {
    [native code]
}, get onselectionchange() {
    [native code]
}, set onselectionchange() {
    [native code]
}, get ontoggle() {
    [native code]
}, set ontoggle() {
    [native code]
}, get onpointercancel() {
    [native code]
}, set onpointercancel() {
    [native code]
}, get onpointerdown() {
    [native code]
}, set onpointerdown() {
    [native code]
}, get onpointerup() {
    [native code]
}, set onpointerup() {
    [native code]
}, get onpointermove() {
    [native code]
}, set onpointermove() {
    [native code]
}, get onpointerout() {
    [native code]
}, set onpointerout() {
    [native code]
}, get onpointerover() {
    [native code]
}, set onpointerover() {
    [native code]
}, get onpointerenter() {
    [native code]
}, set onpointerenter() {
    [native code]
}, get onpointerleave() {
    [native code]
}, set onpointerleave() {
    [native code]
}, get ongotpointercapture() {
    [native code]
}, set ongotpointercapture() {
    [native code]
}, get onlostpointercapture() {
    [native code]
}, set onlostpointercapture() {
    [native code]
}, get onmozfullscreenchange() {
    [native code]
}, set onmozfullscreenchange() {
    [native code]
}, get onmozfullscreenerror() {
    [native code]
}, set onmozfullscreenerror() {
    [native code]
}, get onanimationcancel() {
    [native code]
}, set onanimationcancel() {
    [native code]
}, get onanimationend() {
    [native code]
}, set onanimationend() {
    [native code]
}, get onanimationiteration() {
    [native code]
}, set onanimationiteration() {
    [native code]
}, get onanimationstart() {
    [native code]
}, set onanimationstart() {
    [native code]
}, get ontransitioncancel() {
    [native code]
}, set ontransitioncancel() {
    [native code]
}, get ontransitionend() {
    [native code]
}, set ontransitionend() {
    [native code]
}, get ontransitionrun() {
    [native code]
}, set ontransitionrun() {
    [native code]
}, get ontransitionstart() {
    [native code]
}, set ontransitionstart() {
    [native code]
}, get onwebkitanimationend() {
    [native code]
}, set onwebkitanimationend() {
    [native code]
}, get onwebkitanimationiteration() {
    [native code]
}, set onwebkitanimationiteration() {
    [native code]
}, get onwebkitanimationstart() {
    [native code]
}, set onwebkitanimationstart() {
    [native code]
}, get onwebkittransitionend() {
    [native code]
}, set onwebkittransitionend() {
    [native code]
}, get u2f() {
    [native code]
}, set u2f() {
    [native code]
}, get onerror() {
    [native code]
}, set onerror() {
    [native code]
}, get speechSynthesis() {
    [native code]
}, get onafterprint() {
    [native code]
}, set onafterprint() {
    [native code]
}, get onbeforeprint() {
    [native code]
}, set onbeforeprint() {
    [native code]
}, get onbeforeunload() {
    [native code]
}, set onbeforeunload() {
    [native code]
}, get onhashchange() {
    [native code]
}, set onhashchange() {
    [native code]
}, get onlanguagechange() {
    [native code]
}, set onlanguagechange() {
    [native code]
}, get onmessage() {
    [native code]
}, set onmessage() {
    [native code]
}, get onmessageerror() {
    [native code]
}, set onmessageerror() {
    [native code]
}, get onoffline() {
    [native code]
}, set onoffline() {
    [native code]
}, get ononline() {
    [native code]
}, set ononline() {
    [native code]
}, get onpagehide() {
    [native code]
}, set onpagehide() {
    [native code]
}, get onpageshow() {
    [native code]
}, set onpageshow() {
    [native code]
}, get onpopstate() {
    [native code]
}, set onpopstate() {
    [native code]
}, get onrejectionhandled() {
    [native code]
}, set onrejectionhandled() {
    [native code]
}, get onstorage() {
    [native code]
}, set onstorage() {
    [native code]
}, get onunhandledrejection() {
    [native code]
}, set onunhandledrejection() {
    [native code]
}, get onunload() {
    [native code]
}, set onunload() {
    [native code]
}, get ongamepadconnected() {
    [native code]
}, set ongamepadconnected() {
    [native code]
}, get ongamepaddisconnected() {
    [native code]
}, set ongamepaddisconnected() {
    [native code]
}, get localStorage() {
    [native code]
}, get origin() {
    [native code]
}, set origin() {
    [native code]
}, get crossOriginIsolated() {
    [native code]
}, get isSecureContext() {
    [native code]
}, get indexedDB() {
    [native code]
}, get caches() {
    [native code]
}, get sessionStorage() {
    [native code]
}, mozScrollSnap:function mozScrollSnap() {
    [native code]
}, openDialog:function openDialog() {
    [native code]
}, getInterface:function getInterface() {
    [native code]
}, shouldReportForServiceWorkerScope:function shouldReportForServiceWorkerScope() {
    [native code]
}, setScrollMarks:function setScrollMarks() {
    [native code]
}, get controllers() {
    [native code]
}, set controllers() {
    [native code]
}, get realFrameElement() {
    [native code]
}, get docShell() {
    [native code]
}, get browsingContext() {
    [native code]
}, get desktopToDeviceScale() {
    [native code]
}, get scrollMinX() {
    [native code]
}, get scrollMinY() {
    [native code]
}, get windowRoot() {
    [native code]
}, get windowUtils() {
    [native code]
}, get windowGlobalChild() {
    [native code]
}, get clientPrincipal() {
    [native code]
}, get isChromeWindow() {
    [native code]
}, get Glean() {
    [native code]
}, get GleanPings() {
    [native code]
}}, followWindowGlobalLifeCycle:true, isTopLevelTarget:false, ignoreSubFrames:true, sessionContext:{type:"browser-element", browserId:8, isServerTargetSwitchingEnabled:true, isPopupDebuggingEnabled:false}, _extraActors:{consoleActor:{_options:{id:"devtools/server/actors/webconsole", prefix:"console", constructorName:"WebConsoleActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"consoleActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal4294967325/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967325", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"consoleActor", actorID:"server0.conn0.windowGlobal4294967325/consoleActor3", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967325/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967325", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, inspectorActor:{_options:{id:"devtools/server/actors/inspector/inspector", prefix:"inspector", constructorName:"InspectorActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"inspectorActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal4294967325/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967325", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"inspectorActor", actorID:"server0.conn0.windowGlobal4294967325/inspectorActor4", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967325/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967325", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, styleSheetsActor:{_options:{id:"devtools/server/actors/style-sheets", prefix:"styleSheets", constructorName:"StyleSheetsActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"styleSheetsActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal4294967325/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967325", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"styleSheetsActor", actorID:"server0.conn0.windowGlobal4294967325/styleSheetsActor5", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967325/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967325", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, storageActor:{_options:{id:"devtools/server/actors/storage", prefix:"storage", constructorName:"StorageActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"storageActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal4294967325/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967325", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"storageActor", actorID:"server0.conn0.windowGlobal4294967325/storageActor6", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967325/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967325", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, memoryActor:{_options:{id:"devtools/server/actors/memory", prefix:"memory", constructorName:"MemoryActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"memoryActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal4294967325/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967325", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"memoryActor", actorID:"server0.conn0.windowGlobal4294967325/memoryActor7", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967325/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967325", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, framerateActor:{_options:{id:"devtools/server/actors/framerate", prefix:"framerate", constructorName:"FramerateActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"framerateActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal4294967325/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967325", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"framerateActor", actorID:"server0.conn0.windowGlobal4294967325/framerateActor8", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967325/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967325", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, reflowActor:{_options:{id:"devtools/server/actors/reflow", prefix:"reflow", constructorName:"ReflowActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"reflowActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal4294967325/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967325", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"reflowActor", actorID:"server0.conn0.windowGlobal4294967325/reflowActor9", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967325/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967325", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, cssPropertiesActor:{_options:{id:"devtools/server/actors/css-properties", prefix:"cssProperties", constructorName:"CssPropertiesActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"cssPropertiesActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal4294967325/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967325", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"cssPropertiesActor", actorID:"server0.conn0.windowGlobal4294967325/cssPropertiesActor10", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967325/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967325", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, performanceActor:{_options:{id:"devtools/server/actors/performance", prefix:"performance", constructorName:"PerformanceActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"performanceActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal4294967325/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967325", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"performanceActor", actorID:"server0.conn0.windowGlobal4294967325/performanceActor11", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967325/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967325", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, animationsActor:{_options:{id:"devtools/server/actors/animation", prefix:"animations", constructorName:"AnimationsActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"animationsActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal4294967325/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967325", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"animationsActor", actorID:"server0.conn0.windowGlobal4294967325/animationsActor12", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967325/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967325", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, responsiveActor:{_options:{id:"devtools/server/actors/emulation/responsive", prefix:"responsive", constructorName:"ResponsiveActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"responsiveActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal4294967325/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967325", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"responsiveActor", actorID:"server0.conn0.windowGlobal4294967325/responsiveActor13", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967325/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967325", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, webExtensionInspectedWindowActor:{_options:{id:"devtools/server/actors/addon/webextension-inspected-window", prefix:"webExtensionInspectedWindow", constructorName:"WebExtensionInspectedWindowActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"webExtensionInspectedWindowActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal4294967325/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967325", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"webExtensionInspectedWindowActor", actorID:"server0.conn0.windowGlobal4294967325/webExtensionInspectedWindowActor14", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967325/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967325", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, accessibilityActor:{_options:{id:"devtools/server/actors/accessibility/accessibility", prefix:"accessibility", constructorName:"AccessibilityActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"accessibilityActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal4294967325/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967325", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"accessibilityActor", actorID:"server0.conn0.windowGlobal4294967325/accessibilityActor15", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967325/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967325", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, changesActor:{_options:{id:"devtools/server/actors/changes", prefix:"changes", constructorName:"ChangesActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"changesActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal4294967325/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967325", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"changesActor", actorID:"server0.conn0.windowGlobal4294967325/changesActor16", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967325/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967325", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, webSocketActor:{_options:{id:"devtools/server/actors/network-monitor/websocket-actor", prefix:"webSocket", constructorName:"WebSocketActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"webSocketActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal4294967325/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967325", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"webSocketActor", actorID:"server0.conn0.windowGlobal4294967325/webSocketActor17", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967325/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967325", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, eventSourceActor:{_options:{id:"devtools/server/actors/network-monitor/eventsource-actor", prefix:"eventSource", constructorName:"EventSourceActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"eventSourceActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal4294967325/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967325", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"eventSourceActor", actorID:"server0.conn0.windowGlobal4294967325/eventSourceActor18", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967325/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967325", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, manifestActor:{_options:{id:"devtools/server/actors/manifest", prefix:"manifest", constructorName:"ManifestActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"manifestActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal4294967325/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967325", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"manifestActor", actorID:"server0.conn0.windowGlobal4294967325/manifestActor19", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967325/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967325", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, networkContentActor:{_options:{id:"devtools/server/actors/network-monitor/network-content", prefix:"networkContent", constructorName:"NetworkContentActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"networkContentActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal4294967325/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967325", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"networkContentActor", actorID:"server0.conn0.windowGlobal4294967325/networkContentActor20", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967325/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967325", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, screenshotContentActor:{_options:{id:"devtools/server/actors/screenshot-content", prefix:"screenshotContent", constructorName:"ScreenshotContentActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"screenshotContentActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal4294967325/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967325", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"screenshotContentActor", actorID:"server0.conn0.windowGlobal4294967325/screenshotContentActor21", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967325/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967325", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}}, _sourcesManager:{_thread:{conn:{_prefix:"server0.conn0.windowGlobal4294967325/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967325", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {conn:{}, __poolMap:{}}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, actorID:"server0.conn0.windowGlobal4294967325/thread1", _actorSpec:{typeName:"thread", methods:[{name:"attach", request:{type:"attach", template:{type:"attach", options:{index:0, type:{toString() {
        return "[protocol type:" + name + "]";
      }, name:"json", primitive:true, read:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}, write:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}}}}, args:[{placeholder:{index:0, type:{toString() {
        return "[protocol type:" + name + "]";
      }, name:"json", primitive:true, read:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}, write:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}}}, path:["options"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"reconfigure", request:{type:"reconfigure", template:{type:"reconfigure", options:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["options"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"resume", request:{type:"resume", template:{type:"resume", resumeLimit:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, frameActorID:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["resumeLimit"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["frameActorID"]}]}, response:{template:{_type:"nullable:json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, retVal:{_type:"nullable:json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:[]}, release:(void 0), oneway:(void 0)}, {name:"frames", request:{type:"frames", template:{type:"frames", start:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, count:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["start"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["count"]}]}, response:{template:{_type:"thread.frames", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, retVal:{_type:"thread.frames", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:[]}, release:(void 0), oneway:(void 0)}, {name:"interrupt", request:{type:"interrupt", template:{type:"interrupt", when:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["when"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"sources", request:{type:"sources", template:{type:"sources"}, args:[]}, response:{template:{sources:{_type:"array:json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, retVal:{_type:"array:json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["sources"]}, release:(void 0), oneway:(void 0)}, {name:"skipBreakpoints", request:{type:"skipBreakpoints", template:{type:"skipBreakpoints", skip:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["skip"]}]}, response:{template:{skip:{index:0, type:{toString() {
        return "[protocol type:" + name + "]";
      }, name:"json", primitive:true, read:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}, write:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}}}}}, release:(void 0), oneway:(void 0)}, {name:"dumpThread", request:{type:"dumpThread", template:{type:"dumpThread"}, args:[]}, response:{template:{_type:"json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, retVal:{_type:"json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:[]}, release:(void 0), oneway:(void 0)}, {name:"dumpPools", request:{type:"dumpPools", template:{type:"dumpPools"}, args:[]}, response:{template:{_type:"json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, retVal:{_type:"json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:[]}, release:(void 0), oneway:(void 0)}, {name:"setBreakpoint", request:{type:"setBreakpoint", template:{type:"setBreakpoint", location:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, options:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["location"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["options"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"removeBreakpoint", request:{type:"removeBreakpoint", template:{type:"removeBreakpoint", location:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["location"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"setXHRBreakpoint", request:{type:"setXHRBreakpoint", template:{type:"setXHRBreakpoint", path:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, method:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["path"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["method"]}]}, response:{template:{value:{_type:"boolean", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, retVal:{_type:"boolean", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["value"]}, release:(void 0), oneway:(void 0)}, {name:"removeXHRBreakpoint", request:{type:"removeXHRBreakpoint", template:{type:"removeXHRBreakpoint", path:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, method:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["path"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["method"]}]}, response:{template:{value:{_type:"boolean", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, retVal:{_type:"boolean", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["value"]}, release:(void 0), oneway:(void 0)}, {name:"getAvailableEventBreakpoints", request:{type:"getAvailableEventBreakpoints", template:{type:"getAvailableEventBreakpoints"}, args:[]}, response:{template:{value:{_type:"array:available-breakpoint-group", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, retVal:{_type:"array:available-breakpoint-group", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["value"]}, release:(void 0), oneway:(void 0)}, {name:"getActiveEventBreakpoints", request:{type:"getActiveEventBreakpoints", template:{type:"getActiveEventBreakpoints"}, args:[]}, response:{template:{ids:{_type:"array:string", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, retVal:{_type:"array:string", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["ids"]}, release:(void 0), oneway:(void 0)}, {name:"setActiveEventBreakpoints", request:{type:"setActiveEventBreakpoints", template:{type:"setActiveEventBreakpoints", ids:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["ids"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"pauseOnExceptions", request:{type:"pauseOnExceptions", template:{type:"pauseOnExceptions", pauseOnExceptions:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, ignoreCaughtExceptions:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["pauseOnExceptions"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["ignoreCaughtExceptions"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"toggleEventLogging", request:{type:"toggleEventLogging", template:{type:"toggleEventLogging", logEventBreakpoints:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["logEventBreakpoints"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"isAttached", request:{type:"isAttached", template:{type:"isAttached"}, args:[]}, response:{template:{value:{_type:"boolean", type:{toString() {
        return "[protocol type:" + name + "]";
      }, name:"boolean", primitive:true, read:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}, write:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}}}}, retVal:{_type:"boolean", type:{toString() {
        return "[protocol type:" + name + "]";
      }, name:"boolean", primitive:true, read:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}, write:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}}}, path:["value"]}, release:(void 0), oneway:(void 0)}], events:{}}, _state:"running", _parent:{}, global:{get window() {
    [native code]
}, get document() {
    [native code]
}, get location() {
    [native code]
}, set location() {
    [native code]
}, get top() {
    [native code]
}, close:function close() {
    [native code]
}, stop:function stop() {
    [native code]
}, focus:function focus() {
    [native code]
}, blur:function blur() {
    [native code]
}, open:function open() {
    [native code]
}, alert:function alert() {
    [native code]
}, confirm:function confirm() {
    [native code]
}, prompt:function prompt() {
    [native code]
}, print:function print() {
    [native code]
}, printPreview:function printPreview() {
    [native code]
}, postMessage:function postMessage() {
    [native code]
}, captureEvents:function captureEvents() {
    [native code]
}, releaseEvents:function releaseEvents() {
    [native code]
}, getSelection:function getSelection() {
    [native code]
}, getComputedStyle:function getComputedStyle() {
    [native code]
}, matchMedia:function matchMedia() {
    [native code]
}, moveTo:function moveTo() {
    [native code]
}, moveBy:function moveBy() {
    [native code]
}, resizeTo:function resizeTo() {
    [native code]
}, resizeBy:function resizeBy() {
    [native code]
}, scroll:function scroll() {
    [native code]
}, scrollTo:function scrollTo() {
    [native code]
}, scrollBy:function scrollBy() {
    [native code]
}, getDefaultComputedStyle:function getDefaultComputedStyle() {
    [native code]
}, scrollByLines:function scrollByLines() {
    [native code]
}, scrollByPages:function scrollByPages() {
    [native code]
}, sizeToContent:function sizeToContent() {
    [native code]
}, updateCommands:function updateCommands() {
    [native code]
}, find:function find() {
    [native code]
}, dump:function dump() {
    [native code]
}, setResizable:function setResizable() {
    [native code]
}, requestIdleCallback:function requestIdleCallback() {
    [native code]
}, cancelIdleCallback:function cancelIdleCallback() {
    [native code]
}, getRegionalPrefsLocales:function getRegionalPrefsLocales() {
    [native code]
}, getWebExposedLocales:function getWebExposedLocales() {
    [native code]
}, requestAnimationFrame:function requestAnimationFrame() {
    [native code]
}, cancelAnimationFrame:function cancelAnimationFrame() {
    [native code]
}, reportError:function reportError() {
    [native code]
}, btoa:function btoa() {
    [native code]
}, atob:function atob() {
    [native code]
}, setTimeout:function setTimeout() {
    [native code]
}, clearTimeout:function clearTimeout() {
    [native code]
}, setInterval:function setInterval() {
    [native code]
}, clearInterval:function clearInterval() {
    [native code]
}, queueMicrotask:function queueMicrotask() {
    [native code]
}, createImageBitmap:function createImageBitmap() {
    [native code]
}, structuredClone:function structuredClone() {
    [native code]
}, fetch:function fetch() {
    [native code]
}, get self() {
    [native code]
}, set self() {
    [native code]
}, get name() {
    [native code]
}, set name() {
    [native code]
}, get history() {
    [native code]
}, get customElements() {
    [native code]
}, get locationbar() {
    [native code]
}, set locationbar() {
    [native code]
}, get menubar() {
    [native code]
}, set menubar() {
    [native code]
}, get personalbar() {
    [native code]
}, set personalbar() {
    [native code]
}, get scrollbars() {
    [native code]
}, set scrollbars() {
    [native code]
}, get statusbar() {
    [native code]
}, set statusbar() {
    [native code]
}, get toolbar() {
    [native code]
}, set toolbar() {
    [native code]
}, get status() {
    [native code]
}, set status() {
    [native code]
}, get closed() {
    [native code]
}, get event() {
    [native code]
}, set event() {
    [native code]
}, get frames() {
    [native code]
}, set frames() {
    [native code]
}, get length() {
    [native code]
}, set length() {
    [native code]
}, get opener() {
    [native code]
}, set opener() {
    [native code]
}, get parent() {
    [native code]
}, set parent() {
    [native code]
}, get frameElement() {
    [native code]
}, get navigator() {
    [native code]
}, get clientInformation() {
    [native code]
}, get external() {
    [native code]
}, set external() {
    [native code]
}, get screen() {
    [native code]
}, set screen() {
    [native code]
}, get innerWidth() {
    [native code]
}, set innerWidth() {
    [native code]
}, get innerHeight() {
    [native code]
}, set innerHeight() {
    [native code]
}, get scrollX() {
    [native code]
}, set scrollX() {
    [native code]
}, get pageXOffset() {
    [native code]
}, set pageXOffset() {
    [native code]
}, get scrollY() {
    [native code]
}, set scrollY() {
    [native code]
}, get pageYOffset() {
    [native code]
}, set pageYOffset() {
    [native code]
}, get screenLeft() {
    [native code]
}, set screenLeft() {
    [native code]
}, get screenTop() {
    [native code]
}, set screenTop() {
    [native code]
}, get screenX() {
    [native code]
}, set screenX() {
    [native code]
}, get screenY() {
    [native code]
}, set screenY() {
    [native code]
}, get outerWidth() {
    [native code]
}, set outerWidth() {
    [native code]
}, get outerHeight() {
    [native code]
}, set outerHeight() {
    [native code]
}, get performance() {
    [native code]
}, set performance() {
    [native code]
}, get mozInnerScreenX() {
    [native code]
}, get mozInnerScreenY() {
    [native code]
}, get devicePixelRatio() {
    [native code]
}, set devicePixelRatio() {
    [native code]
}, get scrollMaxX() {
    [native code]
}, set scrollMaxX() {
    [native code]
}, get scrollMaxY() {
    [native code]
}, set scrollMaxY() {
    [native code]
}, get fullScreen() {
    [native code]
}, set fullScreen() {
    [native code]
}, get ondevicemotion() {
    [native code]
}, set ondevicemotion() {
    [native code]
}, get ondeviceorientation() {
    [native code]
}, set ondeviceorientation() {
    [native code]
}, get onabsolutedeviceorientation() {
    [native code]
}, set onabsolutedeviceorientation() {
    [native code]
}, get InstallTrigger() {
    [native code]
}, set InstallTrigger() {
    [native code]
}, get intlUtils() {
    [native code]
}, get visualViewport() {
    [native code]
}, set visualViewport() {
    [native code]
}, get crypto() {
    [native code]
}, get onabort() {
    [native code]
}, set onabort() {
    [native code]
}, get onblur() {
    [native code]
}, set onblur() {
    [native code]
}, get onfocus() {
    [native code]
}, set onfocus() {
    [native code]
}, get onauxclick() {
    [native code]
}, set onauxclick() {
    [native code]
}, get onbeforeinput() {
    [native code]
}, set onbeforeinput() {
    [native code]
}, get oncanplay() {
    [native code]
}, set oncanplay() {
    [native code]
}, get oncanplaythrough() {
    [native code]
}, set oncanplaythrough() {
    [native code]
}, get onchange() {
    [native code]
}, set onchange() {
    [native code]
}, get onclick() {
    [native code]
}, set onclick() {
    [native code]
}, get onclose() {
    [native code]
}, set onclose() {
    [native code]
}, get oncontextmenu() {
    [native code]
}, set oncontextmenu() {
    [native code]
}, get oncuechange() {
    [native code]
}, set oncuechange() {
    [native code]
}, get ondblclick() {
    [native code]
}, set ondblclick() {
    [native code]
}, get ondrag() {
    [native code]
}, set ondrag() {
    [native code]
}, get ondragend() {
    [native code]
}, set ondragend() {
    [native code]
}, get ondragenter() {
    [native code]
}, set ondragenter() {
    [native code]
}, get ondragexit() {
    [native code]
}, set ondragexit() {
    [native code]
}, get ondragleave() {
    [native code]
}, set ondragleave() {
    [native code]
}, get ondragover() {
    [native code]
}, set ondragover() {
    [native code]
}, get ondragstart() {
    [native code]
}, set ondragstart() {
    [native code]
}, get ondrop() {
    [native code]
}, set ondrop() {
    [native code]
}, get ondurationchange() {
    [native code]
}, set ondurationchange() {
    [native code]
}, get onemptied() {
    [native code]
}, set onemptied() {
    [native code]
}, get onended() {
    [native code]
}, set onended() {
    [native code]
}, get onformdata() {
    [native code]
}, set onformdata() {
    [native code]
}, get oninput() {
    [native code]
}, set oninput() {
    [native code]
}, get oninvalid() {
    [native code]
}, set oninvalid() {
    [native code]
}, get onkeydown() {
    [native code]
}, set onkeydown() {
    [native code]
}, get onkeypress() {
    [native code]
}, set onkeypress() {
    [native code]
}, get onkeyup() {
    [native code]
}, set onkeyup() {
    [native code]
}, get onload() {
    [native code]
}, set onload() {
    [native code]
}, get onloadeddata() {
    [native code]
}, set onloadeddata() {
    [native code]
}, get onloadedmetadata() {
    [native code]
}, set onloadedmetadata() {
    [native code]
}, get onloadend() {
    [native code]
}, set onloadend() {
    [native code]
}, get onloadstart() {
    [native code]
}, set onloadstart() {
    [native code]
}, get onmousedown() {
    [native code]
}, set onmousedown() {
    [native code]
}, get onmouseenter() {
    [native code]
}, set onmouseenter() {
    [native code]
}, get onmouseleave() {
    [native code]
}, set onmouseleave() {
    [native code]
}, get onmousemove() {
    [native code]
}, set onmousemove() {
    [native code]
}, get onmouseout() {
    [native code]
}, set onmouseout() {
    [native code]
}, get onmouseover() {
    [native code]
}, set onmouseover() {
    [native code]
}, get onmouseup() {
    [native code]
}, set onmouseup() {
    [native code]
}, get onwheel() {
    [native code]
}, set onwheel() {
    [native code]
}, get onpause() {
    [native code]
}, set onpause() {
    [native code]
}, get onplay() {
    [native code]
}, set onplay() {
    [native code]
}, get onplaying() {
    [native code]
}, set onplaying() {
    [native code]
}, get onprogress() {
    [native code]
}, set onprogress() {
    [native code]
}, get onratechange() {
    [native code]
}, set onratechange() {
    [native code]
}, get onreset() {
    [native code]
}, set onreset() {
    [native code]
}, get onresize() {
    [native code]
}, set onresize() {
    [native code]
}, get onscroll() {
    [native code]
}, set onscroll() {
    [native code]
}, get onsecuritypolicyviolation() {
    [native code]
}, set onsecuritypolicyviolation() {
    [native code]
}, get onseeked() {
    [native code]
}, set onseeked() {
    [native code]
}, get onseeking() {
    [native code]
}, set onseeking() {
    [native code]
}, get onselect() {
    [native code]
}, set onselect() {
    [native code]
}, get onslotchange() {
    [native code]
}, set onslotchange() {
    [native code]
}, get onstalled() {
    [native code]
}, set onstalled() {
    [native code]
}, get onsubmit() {
    [native code]
}, set onsubmit() {
    [native code]
}, get onsuspend() {
    [native code]
}, set onsuspend() {
    [native code]
}, get ontimeupdate() {
    [native code]
}, set ontimeupdate() {
    [native code]
}, get onvolumechange() {
    [native code]
}, set onvolumechange() {
    [native code]
}, get onwaiting() {
    [native code]
}, set onwaiting() {
    [native code]
}, get onselectstart() {
    [native code]
}, set onselectstart() {
    [native code]
}, get onselectionchange() {
    [native code]
}, set onselectionchange() {
    [native code]
}, get ontoggle() {
    [native code]
}, set ontoggle() {
    [native code]
}, get onpointercancel() {
    [native code]
}, set onpointercancel() {
    [native code]
}, get onpointerdown() {
    [native code]
}, set onpointerdown() {
    [native code]
}, get onpointerup() {
    [native code]
}, set onpointerup() {
    [native code]
}, get onpointermove() {
    [native code]
}, set onpointermove() {
    [native code]
}, get onpointerout() {
    [native code]
}, set onpointerout() {
    [native code]
}, get onpointerover() {
    [native code]
}, set onpointerover() {
    [native code]
}, get onpointerenter() {
    [native code]
}, set onpointerenter() {
    [native code]
}, get onpointerleave() {
    [native code]
}, set onpointerleave() {
    [native code]
}, get ongotpointercapture() {
    [native code]
}, set ongotpointercapture() {
    [native code]
}, get onlostpointercapture() {
    [native code]
}, set onlostpointercapture() {
    [native code]
}, get onmozfullscreenchange() {
    [native code]
}, set onmozfullscreenchange() {
    [native code]
}, get onmozfullscreenerror() {
    [native code]
}, set onmozfullscreenerror() {
    [native code]
}, get onanimationcancel() {
    [native code]
}, set onanimationcancel() {
    [native code]
}, get onanimationend() {
    [native code]
}, set onanimationend() {
    [native code]
}, get onanimationiteration() {
    [native code]
}, set onanimationiteration() {
    [native code]
}, get onanimationstart() {
    [native code]
}, set onanimationstart() {
    [native code]
}, get ontransitioncancel() {
    [native code]
}, set ontransitioncancel() {
    [native code]
}, get ontransitionend() {
    [native code]
}, set ontransitionend() {
    [native code]
}, get ontransitionrun() {
    [native code]
}, set ontransitionrun() {
    [native code]
}, get ontransitionstart() {
    [native code]
}, set ontransitionstart() {
    [native code]
}, get onwebkitanimationend() {
    [native code]
}, set onwebkitanimationend() {
    [native code]
}, get onwebkitanimationiteration() {
    [native code]
}, set onwebkitanimationiteration() {
    [native code]
}, get onwebkitanimationstart() {
    [native code]
}, set onwebkitanimationstart() {
    [native code]
}, get onwebkittransitionend() {
    [native code]
}, set onwebkittransitionend() {
    [native code]
}, get u2f() {
    [native code]
}, set u2f() {
    [native code]
}, get onerror() {
    [native code]
}, set onerror() {
    [native code]
}, get speechSynthesis() {
    [native code]
}, get onafterprint() {
    [native code]
}, set onafterprint() {
    [native code]
}, get onbeforeprint() {
    [native code]
}, set onbeforeprint() {
    [native code]
}, get onbeforeunload() {
    [native code]
}, set onbeforeunload() {
    [native code]
}, get onhashchange() {
    [native code]
}, set onhashchange() {
    [native code]
}, get onlanguagechange() {
    [native code]
}, set onlanguagechange() {
    [native code]
}, get onmessage() {
    [native code]
}, set onmessage() {
    [native code]
}, get onmessageerror() {
    [native code]
}, set onmessageerror() {
    [native code]
}, get onoffline() {
    [native code]
}, set onoffline() {
    [native code]
}, get ononline() {
    [native code]
}, set ononline() {
    [native code]
}, get onpagehide() {
    [native code]
}, set onpagehide() {
    [native code]
}, get onpageshow() {
    [native code]
}, set onpageshow() {
    [native code]
}, get onpopstate() {
    [native code]
}, set onpopstate() {
    [native code]
}, get onrejectionhandled() {
    [native code]
}, set onrejectionhandled() {
    [native code]
}, get onstorage() {
    [native code]
}, set onstorage() {
    [native code]
}, get onunhandledrejection() {
    [native code]
}, set onunhandledrejection() {
    [native code]
}, get onunload() {
    [native code]
}, set onunload() {
    [native code]
}, get ongamepadconnected() {
    [native code]
}, set ongamepadconnected() {
    [native code]
}, get ongamepaddisconnected() {
    [native code]
}, set ongamepaddisconnected() {
    [native code]
}, get localStorage() {
    [native code]
}, get origin() {
    [native code]
}, set origin() {
    [native code]
}, get crossOriginIsolated() {
    [native code]
}, get isSecureContext() {
    [native code]
}, get indexedDB() {
    [native code]
}, get caches() {
    [native code]
}, get sessionStorage() {
    [native code]
}, mozScrollSnap:function mozScrollSnap() {
    [native code]
}, openDialog:function openDialog() {
    [native code]
}, getInterface:function getInterface() {
    [native code]
}, shouldReportForServiceWorkerScope:function shouldReportForServiceWorkerScope() {
    [native code]
}, setScrollMarks:function setScrollMarks() {
    [native code]
}, get controllers() {
    [native code]
}, set controllers() {
    [native code]
}, get realFrameElement() {
    [native code]
}, get docShell() {
    [native code]
}, get browsingContext() {
    [native code]
}, get desktopToDeviceScale() {
    [native code]
}, get scrollMinX() {
    [native code]
}, get scrollMinY() {
    [native code]
}, get windowRoot() {
    [native code]
}, get windowUtils() {
    [native code]
}, get windowGlobalChild() {
    [native code]
}, get clientPrincipal() {
    [native code]
}, get isChromeWindow() {
    [native code]
}, get Glean() {
    [native code]
}, get GleanPings() {
    [native code]
}}, _options:{skipBreakpoints:false, pauseOnExceptions:false, ignoreCaughtExceptions:true, shouldShowOverlay:true, shouldIncludeSavedFrames:true, shouldIncludeAsyncLiveFrames:false, logEventBreakpoints:false, observeAsmJS:true}, _gripDepth:0, _parentClosed:false, _observingNetwork:false, _frameActors:[], _xhrBreakpoints:[], _dbg:{addDebuggees:(function() {
    for (const global of findDebuggees(this)) {
      safeAddDebuggee(this, global);
    }
  }), disable:(function() {
    dbg.removeAllDebuggees();
    dbg.onNewGlobalObject = undefined;
  }), enable:(function() {
    dbg.addDebuggees();
    dbg.onNewGlobalObject = onNewGlobalObject;
  }), onNewDebuggee:function bound _onNewDebuggee() {
    [native code]
}}, _threadLifetimePool:null, _activeEventPause:null, _pauseOverlay:null, _priorPause:null, _activeEventBreakpoints:{}, _frameActorMap:{}, _debuggerSourcesSeen:{}, _onLoadBreakpointURLs:{}, _handledFrameExceptions:{}, _watchpointsMap:{threadActor:{}, _watchpoints:{}}, breakpointActorMap:{_threadActor:{}, _actors:{}}, _nestedEventLoop:{_thread:{}, _entered:false, _resolved:false}, onNewSourceEvent:function bound onNewSourceEvent() {
    [native code]
}, createCompletionGrip:function bound createCompletionGrip() {
    [native code]
}, onDebuggerStatement:function bound onDebuggerStatement() {
    [native code]
}, onNewScript:function bound onNewScript() {
    [native code]
}, objectGrip:function bound objectGrip() {
    [native code]
}, pauseObjectGrip:function bound pauseObjectGrip() {
    [native code]
}, _onOpeningRequest:function bound _onOpeningRequest() {
    [native code]
}, _onNewDebuggee:function bound _onNewDebuggee() {
    [native code]
}, _onExceptionUnwind:function bound _onExceptionUnwind() {
    [native code]
}, _eventBreakpointListener:function bound _eventBreakpointListener() {
    [native code]
}, _onWindowReady:function bound _onWindowReady() {
    [native code]
}, _onWillNavigate:function bound _onWillNavigate() {
    [native code]
}, _onNavigate:function bound _onNavigate() {
    [native code]
}, _firstStatementBreakpoint:null, _debuggerNotificationObserver:{}, parentPool:{}, alreadyAttached:true, wrappedJSObject:{}, _shouldEmitNewSource:false, _pendingResponse:{}, [Symbol("EventEmitter/listeners")]:{}}, blackBoxedSources:{}, _sourceActors:{}, _urlContents:{}, _urlWaiters:{}, _sourcesByInternalSourceId:null, [Symbol("EventEmitter/listeners")]:{}}, _styleSheetActors:{}, _shouldAddNewGlobalAsDebuggee:function bound _shouldAddNewGlobalAsDebuggee() {
    [native code]
}, makeDebugger:function bound makeDebugger() {
    [native code]
}, watchNewDocShells:false, _isNewPerfPanelEnabled:true, _workerDescriptorActorList:null, _workerDescriptorActorPool:null, _onWorkerDescriptorActorListChanged:function bound _onWorkerDescriptorActorListChanged() {
    [native code]
}, _onConsoleApiProfilerEvent:function bound _onConsoleApiProfilerEvent() {
    [native code]
}, threadActor:{conn:{_prefix:"server0.conn0.windowGlobal4294967325/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967325", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {conn:{}, __poolMap:{}}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, actorID:"server0.conn0.windowGlobal4294967325/thread1", _actorSpec:{typeName:"thread", methods:[{name:"attach", request:{type:"attach", template:{type:"attach", options:{index:0, type:{toString() {
        return "[protocol type:" + name + "]";
      }, name:"json", primitive:true, read:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}, write:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}}}}, args:[{placeholder:{index:0, type:{toString() {
        return "[protocol type:" + name + "]";
      }, name:"json", primitive:true, read:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}, write:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}}}, path:["options"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"reconfigure", request:{type:"reconfigure", template:{type:"reconfigure", options:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["options"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"resume", request:{type:"resume", template:{type:"resume", resumeLimit:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, frameActorID:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["resumeLimit"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["frameActorID"]}]}, response:{template:{_type:"nullable:json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, retVal:{_type:"nullable:json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:[]}, release:(void 0), oneway:(void 0)}, {name:"frames", request:{type:"frames", template:{type:"frames", start:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, count:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["start"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["count"]}]}, response:{template:{_type:"thread.frames", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, retVal:{_type:"thread.frames", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:[]}, release:(void 0), oneway:(void 0)}, {name:"interrupt", request:{type:"interrupt", template:{type:"interrupt", when:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["when"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"sources", request:{type:"sources", template:{type:"sources"}, args:[]}, response:{template:{sources:{_type:"array:json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, retVal:{_type:"array:json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["sources"]}, release:(void 0), oneway:(void 0)}, {name:"skipBreakpoints", request:{type:"skipBreakpoints", template:{type:"skipBreakpoints", skip:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["skip"]}]}, response:{template:{skip:{index:0, type:{toString() {
        return "[protocol type:" + name + "]";
      }, name:"json", primitive:true, read:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}, write:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}}}}}, release:(void 0), oneway:(void 0)}, {name:"dumpThread", request:{type:"dumpThread", template:{type:"dumpThread"}, args:[]}, response:{template:{_type:"json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, retVal:{_type:"json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:[]}, release:(void 0), oneway:(void 0)}, {name:"dumpPools", request:{type:"dumpPools", template:{type:"dumpPools"}, args:[]}, response:{template:{_type:"json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, retVal:{_type:"json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:[]}, release:(void 0), oneway:(void 0)}, {name:"setBreakpoint", request:{type:"setBreakpoint", template:{type:"setBreakpoint", location:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, options:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["location"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["options"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"removeBreakpoint", request:{type:"removeBreakpoint", template:{type:"removeBreakpoint", location:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["location"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"setXHRBreakpoint", request:{type:"setXHRBreakpoint", template:{type:"setXHRBreakpoint", path:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, method:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["path"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["method"]}]}, response:{template:{value:{_type:"boolean", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, retVal:{_type:"boolean", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["value"]}, release:(void 0), oneway:(void 0)}, {name:"removeXHRBreakpoint", request:{type:"removeXHRBreakpoint", template:{type:"removeXHRBreakpoint", path:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, method:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["path"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["method"]}]}, response:{template:{value:{_type:"boolean", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, retVal:{_type:"boolean", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["value"]}, release:(void 0), oneway:(void 0)}, {name:"getAvailableEventBreakpoints", request:{type:"getAvailableEventBreakpoints", template:{type:"getAvailableEventBreakpoints"}, args:[]}, response:{template:{value:{_type:"array:available-breakpoint-group", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, retVal:{_type:"array:available-breakpoint-group", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["value"]}, release:(void 0), oneway:(void 0)}, {name:"getActiveEventBreakpoints", request:{type:"getActiveEventBreakpoints", template:{type:"getActiveEventBreakpoints"}, args:[]}, response:{template:{ids:{_type:"array:string", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, retVal:{_type:"array:string", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["ids"]}, release:(void 0), oneway:(void 0)}, {name:"setActiveEventBreakpoints", request:{type:"setActiveEventBreakpoints", template:{type:"setActiveEventBreakpoints", ids:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["ids"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"pauseOnExceptions", request:{type:"pauseOnExceptions", template:{type:"pauseOnExceptions", pauseOnExceptions:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, ignoreCaughtExceptions:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["pauseOnExceptions"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["ignoreCaughtExceptions"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"toggleEventLogging", request:{type:"toggleEventLogging", template:{type:"toggleEventLogging", logEventBreakpoints:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["logEventBreakpoints"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"isAttached", request:{type:"isAttached", template:{type:"isAttached"}, args:[]}, response:{template:{value:{_type:"boolean", type:{toString() {
        return "[protocol type:" + name + "]";
      }, name:"boolean", primitive:true, read:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}, write:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}}}}, retVal:{_type:"boolean", type:{toString() {
        return "[protocol type:" + name + "]";
      }, name:"boolean", primitive:true, read:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}, write:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}}}, path:["value"]}, release:(void 0), oneway:(void 0)}], events:{}}, _state:"running", _parent:{}, global:{get window() {
    [native code]
}, get document() {
    [native code]
}, get location() {
    [native code]
}, set location() {
    [native code]
}, get top() {
    [native code]
}, close:function close() {
    [native code]
}, stop:function stop() {
    [native code]
}, focus:function focus() {
    [native code]
}, blur:function blur() {
    [native code]
}, open:function open() {
    [native code]
}, alert:function alert() {
    [native code]
}, confirm:function confirm() {
    [native code]
}, prompt:function prompt() {
    [native code]
}, print:function print() {
    [native code]
}, printPreview:function printPreview() {
    [native code]
}, postMessage:function postMessage() {
    [native code]
}, captureEvents:function captureEvents() {
    [native code]
}, releaseEvents:function releaseEvents() {
    [native code]
}, getSelection:function getSelection() {
    [native code]
}, getComputedStyle:function getComputedStyle() {
    [native code]
}, matchMedia:function matchMedia() {
    [native code]
}, moveTo:function moveTo() {
    [native code]
}, moveBy:function moveBy() {
    [native code]
}, resizeTo:function resizeTo() {
    [native code]
}, resizeBy:function resizeBy() {
    [native code]
}, scroll:function scroll() {
    [native code]
}, scrollTo:function scrollTo() {
    [native code]
}, scrollBy:function scrollBy() {
    [native code]
}, getDefaultComputedStyle:function getDefaultComputedStyle() {
    [native code]
}, scrollByLines:function scrollByLines() {
    [native code]
}, scrollByPages:function scrollByPages() {
    [native code]
}, sizeToContent:function sizeToContent() {
    [native code]
}, updateCommands:function updateCommands() {
    [native code]
}, find:function find() {
    [native code]
}, dump:function dump() {
    [native code]
}, setResizable:function setResizable() {
    [native code]
}, requestIdleCallback:function requestIdleCallback() {
    [native code]
}, cancelIdleCallback:function cancelIdleCallback() {
    [native code]
}, getRegionalPrefsLocales:function getRegionalPrefsLocales() {
    [native code]
}, getWebExposedLocales:function getWebExposedLocales() {
    [native code]
}, requestAnimationFrame:function requestAnimationFrame() {
    [native code]
}, cancelAnimationFrame:function cancelAnimationFrame() {
    [native code]
}, reportError:function reportError() {
    [native code]
}, btoa:function btoa() {
    [native code]
}, atob:function atob() {
    [native code]
}, setTimeout:function setTimeout() {
    [native code]
}, clearTimeout:function clearTimeout() {
    [native code]
}, setInterval:function setInterval() {
    [native code]
}, clearInterval:function clearInterval() {
    [native code]
}, queueMicrotask:function queueMicrotask() {
    [native code]
}, createImageBitmap:function createImageBitmap() {
    [native code]
}, structuredClone:function structuredClone() {
    [native code]
}, fetch:function fetch() {
    [native code]
}, get self() {
    [native code]
}, set self() {
    [native code]
}, get name() {
    [native code]
}, set name() {
    [native code]
}, get history() {
    [native code]
}, get customElements() {
    [native code]
}, get locationbar() {
    [native code]
}, set locationbar() {
    [native code]
}, get menubar() {
    [native code]
}, set menubar() {
    [native code]
}, get personalbar() {
    [native code]
}, set personalbar() {
    [native code]
}, get scrollbars() {
    [native code]
}, set scrollbars() {
    [native code]
}, get statusbar() {
    [native code]
}, set statusbar() {
    [native code]
}, get toolbar() {
    [native code]
}, set toolbar() {
    [native code]
}, get status() {
    [native code]
}, set status() {
    [native code]
}, get closed() {
    [native code]
}, get event() {
    [native code]
}, set event() {
    [native code]
}, get frames() {
    [native code]
}, set frames() {
    [native code]
}, get length() {
    [native code]
}, set length() {
    [native code]
}, get opener() {
    [native code]
}, set opener() {
    [native code]
}, get parent() {
    [native code]
}, set parent() {
    [native code]
}, get frameElement() {
    [native code]
}, get navigator() {
    [native code]
}, get clientInformation() {
    [native code]
}, get external() {
    [native code]
}, set external() {
    [native code]
}, get screen() {
    [native code]
}, set screen() {
    [native code]
}, get innerWidth() {
    [native code]
}, set innerWidth() {
    [native code]
}, get innerHeight() {
    [native code]
}, set innerHeight() {
    [native code]
}, get scrollX() {
    [native code]
}, set scrollX() {
    [native code]
}, get pageXOffset() {
    [native code]
}, set pageXOffset() {
    [native code]
}, get scrollY() {
    [native code]
}, set scrollY() {
    [native code]
}, get pageYOffset() {
    [native code]
}, set pageYOffset() {
    [native code]
}, get screenLeft() {
    [native code]
}, set screenLeft() {
    [native code]
}, get screenTop() {
    [native code]
}, set screenTop() {
    [native code]
}, get screenX() {
    [native code]
}, set screenX() {
    [native code]
}, get screenY() {
    [native code]
}, set screenY() {
    [native code]
}, get outerWidth() {
    [native code]
}, set outerWidth() {
    [native code]
}, get outerHeight() {
    [native code]
}, set outerHeight() {
    [native code]
}, get performance() {
    [native code]
}, set performance() {
    [native code]
}, get mozInnerScreenX() {
    [native code]
}, get mozInnerScreenY() {
    [native code]
}, get devicePixelRatio() {
    [native code]
}, set devicePixelRatio() {
    [native code]
}, get scrollMaxX() {
    [native code]
}, set scrollMaxX() {
    [native code]
}, get scrollMaxY() {
    [native code]
}, set scrollMaxY() {
    [native code]
}, get fullScreen() {
    [native code]
}, set fullScreen() {
    [native code]
}, get ondevicemotion() {
    [native code]
}, set ondevicemotion() {
    [native code]
}, get ondeviceorientation() {
    [native code]
}, set ondeviceorientation() {
    [native code]
}, get onabsolutedeviceorientation() {
    [native code]
}, set onabsolutedeviceorientation() {
    [native code]
}, get InstallTrigger() {
    [native code]
}, set InstallTrigger() {
    [native code]
}, get intlUtils() {
    [native code]
}, get visualViewport() {
    [native code]
}, set visualViewport() {
    [native code]
}, get crypto() {
    [native code]
}, get onabort() {
    [native code]
}, set onabort() {
    [native code]
}, get onblur() {
    [native code]
}, set onblur() {
    [native code]
}, get onfocus() {
    [native code]
}, set onfocus() {
    [native code]
}, get onauxclick() {
    [native code]
}, set onauxclick() {
    [native code]
}, get onbeforeinput() {
    [native code]
}, set onbeforeinput() {
    [native code]
}, get oncanplay() {
    [native code]
}, set oncanplay() {
    [native code]
}, get oncanplaythrough() {
    [native code]
}, set oncanplaythrough() {
    [native code]
}, get onchange() {
    [native code]
}, set onchange() {
    [native code]
}, get onclick() {
    [native code]
}, set onclick() {
    [native code]
}, get onclose() {
    [native code]
}, set onclose() {
    [native code]
}, get oncontextmenu() {
    [native code]
}, set oncontextmenu() {
    [native code]
}, get oncuechange() {
    [native code]
}, set oncuechange() {
    [native code]
}, get ondblclick() {
    [native code]
}, set ondblclick() {
    [native code]
}, get ondrag() {
    [native code]
}, set ondrag() {
    [native code]
}, get ondragend() {
    [native code]
}, set ondragend() {
    [native code]
}, get ondragenter() {
    [native code]
}, set ondragenter() {
    [native code]
}, get ondragexit() {
    [native code]
}, set ondragexit() {
    [native code]
}, get ondragleave() {
    [native code]
}, set ondragleave() {
    [native code]
}, get ondragover() {
    [native code]
}, set ondragover() {
    [native code]
}, get ondragstart() {
    [native code]
}, set ondragstart() {
    [native code]
}, get ondrop() {
    [native code]
}, set ondrop() {
    [native code]
}, get ondurationchange() {
    [native code]
}, set ondurationchange() {
    [native code]
}, get onemptied() {
    [native code]
}, set onemptied() {
    [native code]
}, get onended() {
    [native code]
}, set onended() {
    [native code]
}, get onformdata() {
    [native code]
}, set onformdata() {
    [native code]
}, get oninput() {
    [native code]
}, set oninput() {
    [native code]
}, get oninvalid() {
    [native code]
}, set oninvalid() {
    [native code]
}, get onkeydown() {
    [native code]
}, set onkeydown() {
    [native code]
}, get onkeypress() {
    [native code]
}, set onkeypress() {
    [native code]
}, get onkeyup() {
    [native code]
}, set onkeyup() {
    [native code]
}, get onload() {
    [native code]
}, set onload() {
    [native code]
}, get onloadeddata() {
    [native code]
}, set onloadeddata() {
    [native code]
}, get onloadedmetadata() {
    [native code]
}, set onloadedmetadata() {
    [native code]
}, get onloadend() {
    [native code]
}, set onloadend() {
    [native code]
}, get onloadstart() {
    [native code]
}, set onloadstart() {
    [native code]
}, get onmousedown() {
    [native code]
}, set onmousedown() {
    [native code]
}, get onmouseenter() {
    [native code]
}, set onmouseenter() {
    [native code]
}, get onmouseleave() {
    [native code]
}, set onmouseleave() {
    [native code]
}, get onmousemove() {
    [native code]
}, set onmousemove() {
    [native code]
}, get onmouseout() {
    [native code]
}, set onmouseout() {
    [native code]
}, get onmouseover() {
    [native code]
}, set onmouseover() {
    [native code]
}, get onmouseup() {
    [native code]
}, set onmouseup() {
    [native code]
}, get onwheel() {
    [native code]
}, set onwheel() {
    [native code]
}, get onpause() {
    [native code]
}, set onpause() {
    [native code]
}, get onplay() {
    [native code]
}, set onplay() {
    [native code]
}, get onplaying() {
    [native code]
}, set onplaying() {
    [native code]
}, get onprogress() {
    [native code]
}, set onprogress() {
    [native code]
}, get onratechange() {
    [native code]
}, set onratechange() {
    [native code]
}, get onreset() {
    [native code]
}, set onreset() {
    [native code]
}, get onresize() {
    [native code]
}, set onresize() {
    [native code]
}, get onscroll() {
    [native code]
}, set onscroll() {
    [native code]
}, get onsecuritypolicyviolation() {
    [native code]
}, set onsecuritypolicyviolation() {
    [native code]
}, get onseeked() {
    [native code]
}, set onseeked() {
    [native code]
}, get onseeking() {
    [native code]
}, set onseeking() {
    [native code]
}, get onselect() {
    [native code]
}, set onselect() {
    [native code]
}, get onslotchange() {
    [native code]
}, set onslotchange() {
    [native code]
}, get onstalled() {
    [native code]
}, set onstalled() {
    [native code]
}, get onsubmit() {
    [native code]
}, set onsubmit() {
    [native code]
}, get onsuspend() {
    [native code]
}, set onsuspend() {
    [native code]
}, get ontimeupdate() {
    [native code]
}, set ontimeupdate() {
    [native code]
}, get onvolumechange() {
    [native code]
}, set onvolumechange() {
    [native code]
}, get onwaiting() {
    [native code]
}, set onwaiting() {
    [native code]
}, get onselectstart() {
    [native code]
}, set onselectstart() {
    [native code]
}, get onselectionchange() {
    [native code]
}, set onselectionchange() {
    [native code]
}, get ontoggle() {
    [native code]
}, set ontoggle() {
    [native code]
}, get onpointercancel() {
    [native code]
}, set onpointercancel() {
    [native code]
}, get onpointerdown() {
    [native code]
}, set onpointerdown() {
    [native code]
}, get onpointerup() {
    [native code]
}, set onpointerup() {
    [native code]
}, get onpointermove() {
    [native code]
}, set onpointermove() {
    [native code]
}, get onpointerout() {
    [native code]
}, set onpointerout() {
    [native code]
}, get onpointerover() {
    [native code]
}, set onpointerover() {
    [native code]
}, get onpointerenter() {
    [native code]
}, set onpointerenter() {
    [native code]
}, get onpointerleave() {
    [native code]
}, set onpointerleave() {
    [native code]
}, get ongotpointercapture() {
    [native code]
}, set ongotpointercapture() {
    [native code]
}, get onlostpointercapture() {
    [native code]
}, set onlostpointercapture() {
    [native code]
}, get onmozfullscreenchange() {
    [native code]
}, set onmozfullscreenchange() {
    [native code]
}, get onmozfullscreenerror() {
    [native code]
}, set onmozfullscreenerror() {
    [native code]
}, get onanimationcancel() {
    [native code]
}, set onanimationcancel() {
    [native code]
}, get onanimationend() {
    [native code]
}, set onanimationend() {
    [native code]
}, get onanimationiteration() {
    [native code]
}, set onanimationiteration() {
    [native code]
}, get onanimationstart() {
    [native code]
}, set onanimationstart() {
    [native code]
}, get ontransitioncancel() {
    [native code]
}, set ontransitioncancel() {
    [native code]
}, get ontransitionend() {
    [native code]
}, set ontransitionend() {
    [native code]
}, get ontransitionrun() {
    [native code]
}, set ontransitionrun() {
    [native code]
}, get ontransitionstart() {
    [native code]
}, set ontransitionstart() {
    [native code]
}, get onwebkitanimationend() {
    [native code]
}, set onwebkitanimationend() {
    [native code]
}, get onwebkitanimationiteration() {
    [native code]
}, set onwebkitanimationiteration() {
    [native code]
}, get onwebkitanimationstart() {
    [native code]
}, set onwebkitanimationstart() {
    [native code]
}, get onwebkittransitionend() {
    [native code]
}, set onwebkittransitionend() {
    [native code]
}, get u2f() {
    [native code]
}, set u2f() {
    [native code]
}, get onerror() {
    [native code]
}, set onerror() {
    [native code]
}, get speechSynthesis() {
    [native code]
}, get onafterprint() {
    [native code]
}, set onafterprint() {
    [native code]
}, get onbeforeprint() {
    [native code]
}, set onbeforeprint() {
    [native code]
}, get onbeforeunload() {
    [native code]
}, set onbeforeunload() {
    [native code]
}, get onhashchange() {
    [native code]
}, set onhashchange() {
    [native code]
}, get onlanguagechange() {
    [native code]
}, set onlanguagechange() {
    [native code]
}, get onmessage() {
    [native code]
}, set onmessage() {
    [native code]
}, get onmessageerror() {
    [native code]
}, set onmessageerror() {
    [native code]
}, get onoffline() {
    [native code]
}, set onoffline() {
    [native code]
}, get ononline() {
    [native code]
}, set ononline() {
    [native code]
}, get onpagehide() {
    [native code]
}, set onpagehide() {
    [native code]
}, get onpageshow() {
    [native code]
}, set onpageshow() {
    [native code]
}, get onpopstate() {
    [native code]
}, set onpopstate() {
    [native code]
}, get onrejectionhandled() {
    [native code]
}, set onrejectionhandled() {
    [native code]
}, get onstorage() {
    [native code]
}, set onstorage() {
    [native code]
}, get onunhandledrejection() {
    [native code]
}, set onunhandledrejection() {
    [native code]
}, get onunload() {
    [native code]
}, set onunload() {
    [native code]
}, get ongamepadconnected() {
    [native code]
}, set ongamepadconnected() {
    [native code]
}, get ongamepaddisconnected() {
    [native code]
}, set ongamepaddisconnected() {
    [native code]
}, get localStorage() {
    [native code]
}, get origin() {
    [native code]
}, set origin() {
    [native code]
}, get crossOriginIsolated() {
    [native code]
}, get isSecureContext() {
    [native code]
}, get indexedDB() {
    [native code]
}, get caches() {
    [native code]
}, get sessionStorage() {
    [native code]
}, mozScrollSnap:function mozScrollSnap() {
    [native code]
}, openDialog:function openDialog() {
    [native code]
}, getInterface:function getInterface() {
    [native code]
}, shouldReportForServiceWorkerScope:function shouldReportForServiceWorkerScope() {
    [native code]
}, setScrollMarks:function setScrollMarks() {
    [native code]
}, get controllers() {
    [native code]
}, set controllers() {
    [native code]
}, get realFrameElement() {
    [native code]
}, get docShell() {
    [native code]
}, get browsingContext() {
    [native code]
}, get desktopToDeviceScale() {
    [native code]
}, get scrollMinX() {
    [native code]
}, get scrollMinY() {
    [native code]
}, get windowRoot() {
    [native code]
}, get windowUtils() {
    [native code]
}, get windowGlobalChild() {
    [native code]
}, get clientPrincipal() {
    [native code]
}, get isChromeWindow() {
    [native code]
}, get Glean() {
    [native code]
}, get GleanPings() {
    [native code]
}}, _options:{skipBreakpoints:false, pauseOnExceptions:false, ignoreCaughtExceptions:true, shouldShowOverlay:true, shouldIncludeSavedFrames:true, shouldIncludeAsyncLiveFrames:false, logEventBreakpoints:false, observeAsmJS:true}, _gripDepth:0, _parentClosed:false, _observingNetwork:false, _frameActors:[], _xhrBreakpoints:[], _dbg:{addDebuggees:(function() {
    for (const global of findDebuggees(this)) {
      safeAddDebuggee(this, global);
    }
  }), disable:(function() {
    dbg.removeAllDebuggees();
    dbg.onNewGlobalObject = undefined;
  }), enable:(function() {
    dbg.addDebuggees();
    dbg.onNewGlobalObject = onNewGlobalObject;
  }), onNewDebuggee:function bound _onNewDebuggee() {
    [native code]
}}, _threadLifetimePool:null, _activeEventPause:null, _pauseOverlay:null, _priorPause:null, _activeEventBreakpoints:{}, _frameActorMap:{}, _debuggerSourcesSeen:{}, _onLoadBreakpointURLs:{}, _handledFrameExceptions:{}, _watchpointsMap:{threadActor:{}, _watchpoints:{}}, breakpointActorMap:{_threadActor:{}, _actors:{}}, _nestedEventLoop:{_thread:{}, _entered:false, _resolved:false}, onNewSourceEvent:function bound onNewSourceEvent() {
    [native code]
}, createCompletionGrip:function bound createCompletionGrip() {
    [native code]
}, onDebuggerStatement:function bound onDebuggerStatement() {
    [native code]
}, onNewScript:function bound onNewScript() {
    [native code]
}, objectGrip:function bound objectGrip() {
    [native code]
}, pauseObjectGrip:function bound pauseObjectGrip() {
    [native code]
}, _onOpeningRequest:function bound _onOpeningRequest() {
    [native code]
}, _onNewDebuggee:function bound _onNewDebuggee() {
    [native code]
}, _onExceptionUnwind:function bound _onExceptionUnwind() {
    [native code]
}, _eventBreakpointListener:function bound _eventBreakpointListener() {
    [native code]
}, _onWindowReady:function bound _onWindowReady() {
    [native code]
}, _onWillNavigate:function bound _onWillNavigate() {
    [native code]
}, _onNavigate:function bound _onNavigate() {
    [native code]
}, _firstStatementBreakpoint:null, _debuggerNotificationObserver:{}, parentPool:{}, alreadyAttached:true, wrappedJSObject:{}, _shouldEmitNewSource:false, _pendingResponse:{}, [Symbol("EventEmitter/listeners")]:{}}, __poolMap:{}, _progressListener:{_targetActor:{}, _onWindowCreated:function bound () {
    [native code]
}, _onWindowHidden:function bound () {
    [native code]
}, _knownWindowIDs:{}, _watchedDocShells:{}}, _docShellsObserved:true, parentPool:{}, createdFromJsWindowActor:true, _targetScopedActorPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967325/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967325", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, _dbg:{addDebuggees:(function() {
    for (const global of findDebuggees(this)) {
      safeAddDebuggee(this, global);
    }
  }), disable:(function() {
    dbg.removeAllDebuggees();
    dbg.onNewGlobalObject = undefined;
  }), enable:(function() {
    dbg.addDebuggees();
    dbg.onNewGlobalObject = onNewGlobalObject;
  }), onNewDebuggee:function bound _onNewDebuggee() {
    [native code]
}}, _styleSheetManager:{_styleSheetCount:0, _styleSheetMap:{}, _mqlList:[], _targetActor:{}, _onApplicableStateChanged:function bound _onApplicableStateChanged() {
    [native code]
}, _onTargetActorWindowReady:function bound _onTargetActorWindowReady() {
    [native code]
}, [Symbol("EventEmitter/listeners")]:{}}, [Symbol("EventEmitter/listeners")]:{}}) ": " (new TypeError("this._targetActor.chromeEventHandler is null", "resource://devtools/server/actors/utils/stylesheets-manager.js", 868))
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 1710: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/connectors/js-window-actor/DevToolsFrameChild.jsm, line 402: InvalidStateError: JSWindowActorChild.sendAsyncMessage: JSWindowActorChild cannot send at the moment
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 420: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: , line 0: NotFoundError: No such JSWindowActor 'DevToolsFrame'
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
SourceActor threw an exception: [Exception... "Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]"  nsresult: "0x80470002 (NS_BASE_STREAM_CLOSED)"  location: "JS frame :: resource://devtools/shared/DevToolsUtils.js :: onResponse :: line 567"  data: no]
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:567:34
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 567, column: 0
console.error: ({})
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 567: NS_BASE_STREAM_CLOSED: Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]
SourceActor threw an exception: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:556:16
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 556, column: 16
console.error: (new Error("Failed to fetch https://gen-bizbd.com/web. Code 2152924148.", "resource://devtools/shared/DevToolsUtils.js", 556))
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 556: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
console.error: (new TypeError("parent is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: parent is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 420: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 420: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 420: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, 1650524763263	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "63211" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileyfpxEe"
1650524763870	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileyfpxEe\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:63211/devtools/browser/55251ff4-6fb8-4e73-adc1-4373eb5b0f35
1650524766540	Marionette	INFO	Listening on port 63218
1650524767047	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
JavaScript error: resource://gre/modules/LoginManagerParent.jsm, line 136: TypeError: gRecipeManager is null
JavaScript warning: https://gen-bizbd.com/web/content/53594-92c9dad/web.assets_backend.js, line 5051: unreachable code after return statement
JavaScript error: , line 0: NS_ERROR_NOT_AVAILABLE
console.error: "Error while calling actor 'pagestyle's method 'getApplied'" "node is null"
console.error: (new TypeError("node is null", "resource://devtools/server/actors/page-style.js", 570))
console.error: (new TypeError("parent is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: parent is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

console.error: (new Error("Protocol error (TypeError): node is null from: server0.conn0.windowGlobal4294967299/pagestyle26 (resource://devtools/server/actors/page-style.js:570:5)", "resource://devtools/shared/protocol/Front.js", 365))
console.error: (new TypeError("parent is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: parent is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

console.error: "Error while calling actor 'pagestyle's method 'getLayout'" "node is null"
console.error: (new TypeError("node is null", "resource://devtools/server/actors/page-style.js", 1001))
console.error: (new TypeError("parent is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: parent is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

console.error: (new Error("Protocol error (TypeError): node is null from: server0.conn0.windowGlobal4294967299/pagestyle26 (resource://devtools/server/actors/page-style.js:1001:5)", "resource://devtools/shared/protocol/Front.js", 365))
console.error: (new TypeError("null has no properties", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: null has no properties: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

console.error: "Error while calling actor 'pagestyle's method 'getLayout'" "node is null"
console.error: (new TypeError("node is null", "resource://devtools/server/actors/page-style.js", 1001))
console.error: (new TypeError("null has no properties", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: null has no properties: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

console.error: (new Error("Protocol error (TypeError): node is null from: server0.conn0.windowGlobal4294967299/pagestyle26 (resource://devtools/server/actors/page-style.js:1001:5)", "resource://devtools/shared/protocol/Front.js", 365))
console.error: (new TypeError("null has no properties", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: null has no properties: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

console.error: (new TypeError("null has no properties", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: null has no properties: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

console.error: (new TypeError("null has no properties", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: null has no properties: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

console.error: "Error while calling actor 'pagestyle's method 'getLayout'" "node is null"
console.error: (new TypeError("node is null", "resource://devtools/server/actors/page-style.js", 1001))
console.error: (new Error("Protocol error (TypeError): node is null from: server0.conn0.windowGlobal4294967299/pagestyle26 (resource://devtools/server/actors/page-style.js:1001:5)", "resource://devtools/shared/protocol/Front.js", 365))
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, 1650527349878	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "57555" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileKcCQT7"
1650527350657	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileKcCQT7\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:57555/devtools/browser/c6fe66f2-de70-4348-aa0e-24fa690b49e6
1650527353442	Marionette	INFO	Listening on port 57561
1650527353716	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
JavaScript error: resource://gre/modules/LoginManagerParent.jsm, line 136: TypeError: gRecipeManager is null
JavaScript warning: https://gen-bizbd.com/web/content/53594-92c9dad/web.assets_backend.js, line 5051: unreachable code after return statement
SourceActor threw an exception: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:556:16
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 556, column: 16
console.error: (new Error("Failed to fetch https://gen-bizbd.com/web. Code 2152924148.", "resource://devtools/shared/DevToolsUtils.js", 556))
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 556: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
SourceActor threw an exception: [Exception... "Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]"  nsresult: "0x80470002 (NS_BASE_STREAM_CLOSED)"  location: "JS frame :: resource://devtools/shared/DevToolsUtils.js :: onResponse :: line 567"  data: no]
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:567:34
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 567, column: 0
console.error: ({})
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 567: NS_BASE_STREAM_CLOSED: Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]
console.error: (new TypeError("parent is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: parent is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

console.error: (new TypeError("parent is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: parent is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

console.error: "Error while calling actor 'pagestyle's method 'getLayout'" "node is null"
console.error: (new TypeError("node is null", "resource://devtools/server/actors/page-style.js", 1001))
console.error: (new Error("Protocol error (TypeError): node is null from: server0.conn0.windowGlobal4294967299/pagestyle26 (resource://devtools/server/actors/page-style.js:1001:5)", "resource://devtools/shared/protocol/Front.js", 365))
console.error: "Error when attaching target:" (new Error("Connection closed, pending request to server0.conn0.windowGlobal4294967403/thread1, type isAttached failed\n\nRequest stack:\nrequest@resource://devtools/shared/protocol/Front.js:292:14\ngenerateRequestMethods/</frontProto[name]@resource://devtools/shared/protocol/Front/FrontClassWithSpec.js:46:19\nattachThread@resource://devtools/client/fronts/targets/target-mixin.js:573:49\n", "resource://devtools/shared/protocol/Front.js", 106))
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
console.error: (new TypeError("parent is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: parent is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

console.error: (new TypeError("container.node.targetFront is null", "resource://devtools/client/inspector/markup/markup.js", 2320))
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
Handler function threw an exception: [Exception... "Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]"  nsresult: "0x80040111 (NS_ERROR_NOT_AVAILABLE)"  location: "JS frame :: resource://devtools/server/actors/targets/window-global.js :: watch :: line 1662"  data: no]
Stack: watch@resource://devtools/server/actors/targets/window-global.js:1662:28
_watchDocshells@resource://devtools/server/actors/targets/window-global.js:773:28
initialize/<@resource://devtools/server/actors/targets/window-global.js:346:42
exports.makeInfallible/<@resource://devtools/shared/ThreadSafeDevToolsUtils.js:103:22
Line: 1662, column: 0
console.error: ({})
console.error: "Error while calling actor 'thread's method 'isAttached'" "JSWindowActorChild.sendAsyncMessage: JSWindowActorChild cannot send at the moment"
console.error: (new InvalidStateError("JSWindowActorChild.sendAsyncMessage: JSWindowActorChild cannot send at the moment", (void 0), 402))
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
console.error: "Error when destroying StyleSheet manager for" ({notifyResourceAvailable:function bound notifyResourceAvailable() {
    [native code]
}, notifyResourceDestroyed:function bound notifyResourceDestroyed() {
    [native code]
}, notifyResourceUpdated:function bound notifyResourceUpdated() {
    [native code]
}, conn:{_prefix:"server0.conn0.windowGlobal4294967403/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967403", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {conn:{}, __poolMap:{}}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, actorID:"server0.conn0.windowGlobal4294967403/windowGlobalTarget2", _actorSpec:{typeName:"windowGlobalTarget", methods:[{name:"detach", request:{type:"detach", template:{type:"detach"}, args:[]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"ensureCSSErrorReportingEnabled", request:{type:"ensureCSSErrorReportingEnabled", template:{type:"ensureCSSErrorReportingEnabled"}, args:[]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"focus", request:{type:"focus", template:{type:"focus"}, args:[]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"goForward", request:{type:"goForward", template:{type:"goForward"}, args:[]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"goBack", request:{type:"goBack", template:{type:"goBack"}, args:[]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"reload", request:{type:"reload", template:{type:"reload", options:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["options"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"navigateTo", request:{type:"navigateTo", template:{type:"navigateTo", url:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["url"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"reconfigure", request:{type:"reconfigure", template:{type:"reconfigure", options:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["options"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"switchToFrame", request:{type:"switchToFrame", template:{type:"switchToFrame", windowId:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["windowId"]}]}, response:{template:{_type:"windowGlobalTarget.switchtoframe", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, retVal:{_type:"windowGlobalTarget.switchtoframe", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:[]}, release:(void 0), oneway:(void 0)}, {name:"listFrames", request:{type:"listFrames", template:{type:"listFrames"}, args:[]}, response:{template:{_type:"windowGlobalTarget.listframes", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, retVal:{_type:"windowGlobalTarget.listframes", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:[]}, release:(void 0), oneway:(void 0)}, {name:"listWorkers", request:{type:"listWorkers", template:{type:"listWorkers"}, args:[]}, response:{template:{_type:"windowGlobalTarget.workers", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, retVal:{_type:"windowGlobalTarget.workers", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:[]}, release:(void 0), oneway:(void 0)}, {name:"logInPage", request:{type:"logInPage", template:{type:"logInPage", text:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, category:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, flags:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["text"]}, {placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["category"]}, {placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["flags"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}], events:{}}, docShell:({}), _originalWindow:{get window() {
    [native code]
}, get document() {
    [native code]
}, get location() {
    [native code]
}, set location() {
    [native code]
}, get top() {
    [native code]
}, close:function close() {
    [native code]
}, stop:function stop() {
    [native code]
}, focus:function focus() {
    [native code]
}, blur:function blur() {
    [native code]
}, open:function open() {
    [native code]
}, alert:function alert() {
    [native code]
}, confirm:function confirm() {
    [native code]
}, prompt:function prompt() {
    [native code]
}, print:function print() {
    [native code]
}, printPreview:function printPreview() {
    [native code]
}, postMessage:function postMessage() {
    [native code]
}, captureEvents:function captureEvents() {
    [native code]
}, releaseEvents:function releaseEvents() {
    [native code]
}, getSelection:function getSelection() {
    [native code]
}, getComputedStyle:function getComputedStyle() {
    [native code]
}, matchMedia:function matchMedia() {
    [native code]
}, moveTo:function moveTo() {
    [native code]
}, moveBy:function moveBy() {
    [native code]
}, resizeTo:function resizeTo() {
    [native code]
}, resizeBy:function resizeBy() {
    [native code]
}, scroll:function scroll() {
    [native code]
}, scrollTo:function scrollTo() {
    [native code]
}, scrollBy:function scrollBy() {
    [native code]
}, getDefaultComputedStyle:function getDefaultComputedStyle() {
    [native code]
}, scrollByLines:function scrollByLines() {
    [native code]
}, scrollByPages:function scrollByPages() {
    [native code]
}, sizeToContent:function sizeToContent() {
    [native code]
}, updateCommands:function updateCommands() {
    [native code]
}, find:function find() {
    [native code]
}, dump:function dump() {
    [native code]
}, setResizable:function setResizable() {
    [native code]
}, requestIdleCallback:function requestIdleCallback() {
    [native code]
}, cancelIdleCallback:function cancelIdleCallback() {
    [native code]
}, getRegionalPrefsLocales:function getRegionalPrefsLocales() {
    [native code]
}, getWebExposedLocales:function getWebExposedLocales() {
    [native code]
}, requestAnimationFrame:function requestAnimationFrame() {
    [native code]
}, cancelAnimationFrame:function cancelAnimationFrame() {
    [native code]
}, reportError:function reportError() {
    [native code]
}, btoa:function btoa() {
    [native code]
}, atob:function atob() {
    [native code]
}, setTimeout:function setTimeout() {
    [native code]
}, clearTimeout:function clearTimeout() {
    [native code]
}, setInterval:function setInterval() {
    [native code]
}, clearInterval:function clearInterval() {
    [native code]
}, queueMicrotask:function queueMicrotask() {
    [native code]
}, createImageBitmap:function createImageBitmap() {
    [native code]
}, structuredClone:function structuredClone() {
    [native code]
}, fetch:function fetch() {
    [native code]
}, get self() {
    [native code]
}, set self() {
    [native code]
}, get name() {
    [native code]
}, set name() {
    [native code]
}, get history() {
    [native code]
}, get customElements() {
    [native code]
}, get locationbar() {
    [native code]
}, set locationbar() {
    [native code]
}, get menubar() {
    [native code]
}, set menubar() {
    [native code]
}, get personalbar() {
    [native code]
}, set personalbar() {
    [native code]
}, get scrollbars() {
    [native code]
}, set scrollbars() {
    [native code]
}, get statusbar() {
    [native code]
}, set statusbar() {
    [native code]
}, get toolbar() {
    [native code]
}, set toolbar() {
    [native code]
}, get status() {
    [native code]
}, set status() {
    [native code]
}, get closed() {
    [native code]
}, get event() {
    [native code]
}, set event() {
    [native code]
}, get frames() {
    [native code]
}, set frames() {
    [native code]
}, get length() {
    [native code]
}, set length() {
    [native code]
}, get opener() {
    [native code]
}, set opener() {
    [native code]
}, get parent() {
    [native code]
}, set parent() {
    [native code]
}, get frameElement() {
    [native code]
}, get navigator() {
    [native code]
}, get clientInformation() {
    [native code]
}, get external() {
    [native code]
}, set external() {
    [native code]
}, get screen() {
    [native code]
}, set screen() {
    [native code]
}, get innerWidth() {
    [native code]
}, set innerWidth() {
    [native code]
}, get innerHeight() {
    [native code]
}, set innerHeight() {
    [native code]
}, get scrollX() {
    [native code]
}, set scrollX() {
    [native code]
}, get pageXOffset() {
    [native code]
}, set pageXOffset() {
    [native code]
}, get scrollY() {
    [native code]
}, set scrollY() {
    [native code]
}, get pageYOffset() {
    [native code]
}, set pageYOffset() {
    [native code]
}, get screenLeft() {
    [native code]
}, set screenLeft() {
    [native code]
}, get screenTop() {
    [native code]
}, set screenTop() {
    [native code]
}, get screenX() {
    [native code]
}, set screenX() {
    [native code]
}, get screenY() {
    [native code]
}, set screenY() {
    [native code]
}, get outerWidth() {
    [native code]
}, set outerWidth() {
    [native code]
}, get outerHeight() {
    [native code]
}, set outerHeight() {
    [native code]
}, get performance() {
    [native code]
}, set performance() {
    [native code]
}, get mozInnerScreenX() {
    [native code]
}, get mozInnerScreenY() {
    [native code]
}, get devicePixelRatio() {
    [native code]
}, set devicePixelRatio() {
    [native code]
}, get scrollMaxX() {
    [native code]
}, set scrollMaxX() {
    [native code]
}, get scrollMaxY() {
    [native code]
}, set scrollMaxY() {
    [native code]
}, get fullScreen() {
    [native code]
}, set fullScreen() {
    [native code]
}, get ondevicemotion() {
    [native code]
}, set ondevicemotion() {
    [native code]
}, get ondeviceorientation() {
    [native code]
}, set ondeviceorientation() {
    [native code]
}, get onabsolutedeviceorientation() {
    [native code]
}, set onabsolutedeviceorientation() {
    [native code]
}, get InstallTrigger() {
    [native code]
}, set InstallTrigger() {
    [native code]
}, get intlUtils() {
    [native code]
}, get visualViewport() {
    [native code]
}, set visualViewport() {
    [native code]
}, get crypto() {
    [native code]
}, get onabort() {
    [native code]
}, set onabort() {
    [native code]
}, get onblur() {
    [native code]
}, set onblur() {
    [native code]
}, get onfocus() {
    [native code]
}, set onfocus() {
    [native code]
}, get onauxclick() {
    [native code]
}, set onauxclick() {
    [native code]
}, get onbeforeinput() {
    [native code]
}, set onbeforeinput() {
    [native code]
}, get oncanplay() {
    [native code]
}, set oncanplay() {
    [native code]
}, get oncanplaythrough() {
    [native code]
}, set oncanplaythrough() {
    [native code]
}, get onchange() {
    [native code]
}, set onchange() {
    [native code]
}, get onclick() {
    [native code]
}, set onclick() {
    [native code]
}, get onclose() {
    [native code]
}, set onclose() {
    [native code]
}, get oncontextmenu() {
    [native code]
}, set oncontextmenu() {
    [native code]
}, get oncuechange() {
    [native code]
}, set oncuechange() {
    [native code]
}, get ondblclick() {
    [native code]
}, set ondblclick() {
    [native code]
}, get ondrag() {
    [native code]
}, set ondrag() {
    [native code]
}, get ondragend() {
    [native code]
}, set ondragend() {
    [native code]
}, get ondragenter() {
    [native code]
}, set ondragenter() {
    [native code]
}, get ondragexit() {
    [native code]
}, set ondragexit() {
    [native code]
}, get ondragleave() {
    [native code]
}, set ondragleave() {
    [native code]
}, get ondragover() {
    [native code]
}, set ondragover() {
    [native code]
}, get ondragstart() {
    [native code]
}, set ondragstart() {
    [native code]
}, get ondrop() {
    [native code]
}, set ondrop() {
    [native code]
}, get ondurationchange() {
    [native code]
}, set ondurationchange() {
    [native code]
}, get onemptied() {
    [native code]
}, set onemptied() {
    [native code]
}, get onended() {
    [native code]
}, set onended() {
    [native code]
}, get onformdata() {
    [native code]
}, set onformdata() {
    [native code]
}, get oninput() {
    [native code]
}, set oninput() {
    [native code]
}, get oninvalid() {
    [native code]
}, set oninvalid() {
    [native code]
}, get onkeydown() {
    [native code]
}, set onkeydown() {
    [native code]
}, get onkeypress() {
    [native code]
}, set onkeypress() {
    [native code]
}, get onkeyup() {
    [native code]
}, set onkeyup() {
    [native code]
}, get onload() {
    [native code]
}, set onload() {
    [native code]
}, get onloadeddata() {
    [native code]
}, set onloadeddata() {
    [native code]
}, get onloadedmetadata() {
    [native code]
}, set onloadedmetadata() {
    [native code]
}, get onloadend() {
    [native code]
}, set onloadend() {
    [native code]
}, get onloadstart() {
    [native code]
}, set onloadstart() {
    [native code]
}, get onmousedown() {
    [native code]
}, set onmousedown() {
    [native code]
}, get onmouseenter() {
    [native code]
}, set onmouseenter() {
    [native code]
}, get onmouseleave() {
    [native code]
}, set onmouseleave() {
    [native code]
}, get onmousemove() {
    [native code]
}, set onmousemove() {
    [native code]
}, get onmouseout() {
    [native code]
}, set onmouseout() {
    [native code]
}, get onmouseover() {
    [native code]
}, set onmouseover() {
    [native code]
}, get onmouseup() {
    [native code]
}, set onmouseup() {
    [native code]
}, get onwheel() {
    [native code]
}, set onwheel() {
    [native code]
}, get onpause() {
    [native code]
}, set onpause() {
    [native code]
}, get onplay() {
    [native code]
}, set onplay() {
    [native code]
}, get onplaying() {
    [native code]
}, set onplaying() {
    [native code]
}, get onprogress() {
    [native code]
}, set onprogress() {
    [native code]
}, get onratechange() {
    [native code]
}, set onratechange() {
    [native code]
}, get onreset() {
    [native code]
}, set onreset() {
    [native code]
}, get onresize() {
    [native code]
}, set onresize() {
    [native code]
}, get onscroll() {
    [native code]
}, set onscroll() {
    [native code]
}, get onsecuritypolicyviolation() {
    [native code]
}, set onsecuritypolicyviolation() {
    [native code]
}, get onseeked() {
    [native code]
}, set onseeked() {
    [native code]
}, get onseeking() {
    [native code]
}, set onseeking() {
    [native code]
}, get onselect() {
    [native code]
}, set onselect() {
    [native code]
}, get onslotchange() {
    [native code]
}, set onslotchange() {
    [native code]
}, get onstalled() {
    [native code]
}, set onstalled() {
    [native code]
}, get onsubmit() {
    [native code]
}, set onsubmit() {
    [native code]
}, get onsuspend() {
    [native code]
}, set onsuspend() {
    [native code]
}, get ontimeupdate() {
    [native code]
}, set ontimeupdate() {
    [native code]
}, get onvolumechange() {
    [native code]
}, set onvolumechange() {
    [native code]
}, get onwaiting() {
    [native code]
}, set onwaiting() {
    [native code]
}, get onselectstart() {
    [native code]
}, set onselectstart() {
    [native code]
}, get onselectionchange() {
    [native code]
}, set onselectionchange() {
    [native code]
}, get ontoggle() {
    [native code]
}, set ontoggle() {
    [native code]
}, get onpointercancel() {
    [native code]
}, set onpointercancel() {
    [native code]
}, get onpointerdown() {
    [native code]
}, set onpointerdown() {
    [native code]
}, get onpointerup() {
    [native code]
}, set onpointerup() {
    [native code]
}, get onpointermove() {
    [native code]
}, set onpointermove() {
    [native code]
}, get onpointerout() {
    [native code]
}, set onpointerout() {
    [native code]
}, get onpointerover() {
    [native code]
}, set onpointerover() {
    [native code]
}, get onpointerenter() {
    [native code]
}, set onpointerenter() {
    [native code]
}, get onpointerleave() {
    [native code]
}, set onpointerleave() {
    [native code]
}, get ongotpointercapture() {
    [native code]
}, set ongotpointercapture() {
    [native code]
}, get onlostpointercapture() {
    [native code]
}, set onlostpointercapture() {
    [native code]
}, get onmozfullscreenchange() {
    [native code]
}, set onmozfullscreenchange() {
    [native code]
}, get onmozfullscreenerror() {
    [native code]
}, set onmozfullscreenerror() {
    [native code]
}, get onanimationcancel() {
    [native code]
}, set onanimationcancel() {
    [native code]
}, get onanimationend() {
    [native code]
}, set onanimationend() {
    [native code]
}, get onanimationiteration() {
    [native code]
}, set onanimationiteration() {
    [native code]
}, get onanimationstart() {
    [native code]
}, set onanimationstart() {
    [native code]
}, get ontransitioncancel() {
    [native code]
}, set ontransitioncancel() {
    [native code]
}, get ontransitionend() {
    [native code]
}, set ontransitionend() {
    [native code]
}, get ontransitionrun() {
    [native code]
}, set ontransitionrun() {
    [native code]
}, get ontransitionstart() {
    [native code]
}, set ontransitionstart() {
    [native code]
}, get onwebkitanimationend() {
    [native code]
}, set onwebkitanimationend() {
    [native code]
}, get onwebkitanimationiteration() {
    [native code]
}, set onwebkitanimationiteration() {
    [native code]
}, get onwebkitanimationstart() {
    [native code]
}, set onwebkitanimationstart() {
    [native code]
}, get onwebkittransitionend() {
    [native code]
}, set onwebkittransitionend() {
    [native code]
}, get u2f() {
    [native code]
}, set u2f() {
    [native code]
}, get onerror() {
    [native code]
}, set onerror() {
    [native code]
}, get speechSynthesis() {
    [native code]
}, get onafterprint() {
    [native code]
}, set onafterprint() {
    [native code]
}, get onbeforeprint() {
    [native code]
}, set onbeforeprint() {
    [native code]
}, get onbeforeunload() {
    [native code]
}, set onbeforeunload() {
    [native code]
}, get onhashchange() {
    [native code]
}, set onhashchange() {
    [native code]
}, get onlanguagechange() {
    [native code]
}, set onlanguagechange() {
    [native code]
}, get onmessage() {
    [native code]
}, set onmessage() {
    [native code]
}, get onmessageerror() {
    [native code]
}, set onmessageerror() {
    [native code]
}, get onoffline() {
    [native code]
}, set onoffline() {
    [native code]
}, get ononline() {
    [native code]
}, set ononline() {
    [native code]
}, get onpagehide() {
    [native code]
}, set onpagehide() {
    [native code]
}, get onpageshow() {
    [native code]
}, set onpageshow() {
    [native code]
}, get onpopstate() {
    [native code]
}, set onpopstate() {
    [native code]
}, get onrejectionhandled() {
    [native code]
}, set onrejectionhandled() {
    [native code]
}, get onstorage() {
    [native code]
}, set onstorage() {
    [native code]
}, get onunhandledrejection() {
    [native code]
}, set onunhandledrejection() {
    [native code]
}, get onunload() {
    [native code]
}, set onunload() {
    [native code]
}, get ongamepadconnected() {
    [native code]
}, set ongamepadconnected() {
    [native code]
}, get ongamepaddisconnected() {
    [native code]
}, set ongamepaddisconnected() {
    [native code]
}, get localStorage() {
    [native code]
}, get origin() {
    [native code]
}, set origin() {
    [native code]
}, get crossOriginIsolated() {
    [native code]
}, get isSecureContext() {
    [native code]
}, get indexedDB() {
    [native code]
}, get caches() {
    [native code]
}, get sessionStorage() {
    [native code]
}, mozScrollSnap:function mozScrollSnap() {
    [native code]
}, openDialog:function openDialog() {
    [native code]
}, getInterface:function getInterface() {
    [native code]
}, shouldReportForServiceWorkerScope:function shouldReportForServiceWorkerScope() {
    [native code]
}, setScrollMarks:function setScrollMarks() {
    [native code]
}, get controllers() {
    [native code]
}, set controllers() {
    [native code]
}, get realFrameElement() {
    [native code]
}, get docShell() {
    [native code]
}, get browsingContext() {
    [native code]
}, get desktopToDeviceScale() {
    [native code]
}, get scrollMinX() {
    [native code]
}, get scrollMinY() {
    [native code]
}, get windowRoot() {
    [native code]
}, get windowUtils() {
    [native code]
}, get windowGlobalChild() {
    [native code]
}, get clientPrincipal() {
    [native code]
}, get isChromeWindow() {
    [native code]
}, get Glean() {
    [native code]
}, get GleanPings() {
    [native code]
}}, followWindowGlobalLifeCycle:true, isTopLevelTarget:false, ignoreSubFrames:true, sessionContext:{type:"browser-element", browserId:8, isServerTargetSwitchingEnabled:true, isPopupDebuggingEnabled:false}, _extraActors:{consoleActor:{_options:{id:"devtools/server/actors/webconsole", prefix:"console", constructorName:"WebConsoleActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"consoleActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal4294967403/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967403", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"consoleActor", actorID:"server0.conn0.windowGlobal4294967403/consoleActor3", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967403/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967403", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, inspectorActor:{_options:{id:"devtools/server/actors/inspector/inspector", prefix:"inspector", constructorName:"InspectorActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"inspectorActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal4294967403/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967403", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"inspectorActor", actorID:"server0.conn0.windowGlobal4294967403/inspectorActor4", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967403/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967403", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, styleSheetsActor:{_options:{id:"devtools/server/actors/style-sheets", prefix:"styleSheets", constructorName:"StyleSheetsActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"styleSheetsActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal4294967403/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967403", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"styleSheetsActor", actorID:"server0.conn0.windowGlobal4294967403/styleSheetsActor5", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967403/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967403", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, storageActor:{_options:{id:"devtools/server/actors/storage", prefix:"storage", constructorName:"StorageActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"storageActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal4294967403/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967403", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"storageActor", actorID:"server0.conn0.windowGlobal4294967403/storageActor6", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967403/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967403", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, memoryActor:{_options:{id:"devtools/server/actors/memory", prefix:"memory", constructorName:"MemoryActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"memoryActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal4294967403/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967403", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"memoryActor", actorID:"server0.conn0.windowGlobal4294967403/memoryActor7", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967403/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967403", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, framerateActor:{_options:{id:"devtools/server/actors/framerate", prefix:"framerate", constructorName:"FramerateActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"framerateActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal4294967403/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967403", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"framerateActor", actorID:"server0.conn0.windowGlobal4294967403/framerateActor8", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967403/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967403", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, reflowActor:{_options:{id:"devtools/server/actors/reflow", prefix:"reflow", constructorName:"ReflowActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"reflowActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal4294967403/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967403", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"reflowActor", actorID:"server0.conn0.windowGlobal4294967403/reflowActor9", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967403/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967403", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, cssPropertiesActor:{_options:{id:"devtools/server/actors/css-properties", prefix:"cssProperties", constructorName:"CssPropertiesActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"cssPropertiesActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal4294967403/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967403", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"cssPropertiesActor", actorID:"server0.conn0.windowGlobal4294967403/cssPropertiesActor10", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967403/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967403", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, performanceActor:{_options:{id:"devtools/server/actors/performance", prefix:"performance", constructorName:"PerformanceActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"performanceActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal4294967403/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967403", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"performanceActor", actorID:"server0.conn0.windowGlobal4294967403/performanceActor11", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967403/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967403", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, animationsActor:{_options:{id:"devtools/server/actors/animation", prefix:"animations", constructorName:"AnimationsActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"animationsActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal4294967403/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967403", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"animationsActor", actorID:"server0.conn0.windowGlobal4294967403/animationsActor12", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967403/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967403", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, responsiveActor:{_options:{id:"devtools/server/actors/emulation/responsive", prefix:"responsive", constructorName:"ResponsiveActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"responsiveActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal4294967403/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967403", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"responsiveActor", actorID:"server0.conn0.windowGlobal4294967403/responsiveActor13", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967403/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967403", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, webExtensionInspectedWindowActor:{_options:{id:"devtools/server/actors/addon/webextension-inspected-window", prefix:"webExtensionInspectedWindow", constructorName:"WebExtensionInspectedWindowActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"webExtensionInspectedWindowActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal4294967403/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967403", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"webExtensionInspectedWindowActor", actorID:"server0.conn0.windowGlobal4294967403/webExtensionInspectedWindowActor14", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967403/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967403", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, accessibilityActor:{_options:{id:"devtools/server/actors/accessibility/accessibility", prefix:"accessibility", constructorName:"AccessibilityActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"accessibilityActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal4294967403/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967403", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"accessibilityActor", actorID:"server0.conn0.windowGlobal4294967403/accessibilityActor15", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967403/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967403", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, changesActor:{_options:{id:"devtools/server/actors/changes", prefix:"changes", constructorName:"ChangesActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"changesActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal4294967403/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967403", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"changesActor", actorID:"server0.conn0.windowGlobal4294967403/changesActor16", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967403/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967403", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, webSocketActor:{_options:{id:"devtools/server/actors/network-monitor/websocket-actor", prefix:"webSocket", constructorName:"WebSocketActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"webSocketActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal4294967403/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967403", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"webSocketActor", actorID:"server0.conn0.windowGlobal4294967403/webSocketActor17", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967403/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967403", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, eventSourceActor:{_options:{id:"devtools/server/actors/network-monitor/eventsource-actor", prefix:"eventSource", constructorName:"EventSourceActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"eventSourceActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal4294967403/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967403", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"eventSourceActor", actorID:"server0.conn0.windowGlobal4294967403/eventSourceActor18", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967403/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967403", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, manifestActor:{_options:{id:"devtools/server/actors/manifest", prefix:"manifest", constructorName:"ManifestActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"manifestActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal4294967403/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967403", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"manifestActor", actorID:"server0.conn0.windowGlobal4294967403/manifestActor19", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967403/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967403", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, networkContentActor:{_options:{id:"devtools/server/actors/network-monitor/network-content", prefix:"networkContent", constructorName:"NetworkContentActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"networkContentActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal4294967403/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967403", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"networkContentActor", actorID:"server0.conn0.windowGlobal4294967403/networkContentActor20", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967403/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967403", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, screenshotContentActor:{_options:{id:"devtools/server/actors/screenshot-content", prefix:"screenshotContent", constructorName:"ScreenshotContentActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"screenshotContentActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal4294967403/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967403", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"screenshotContentActor", actorID:"server0.conn0.windowGlobal4294967403/screenshotContentActor21", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967403/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967403", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}}, _sourcesManager:{_thread:{conn:{_prefix:"server0.conn0.windowGlobal4294967403/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967403", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {conn:{}, __poolMap:{}}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, actorID:"server0.conn0.windowGlobal4294967403/thread1", _actorSpec:{typeName:"thread", methods:[{name:"attach", request:{type:"attach", template:{type:"attach", options:{index:0, type:{toString() {
        return "[protocol type:" + name + "]";
      }, name:"json", primitive:true, read:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}, write:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}}}}, args:[{placeholder:{index:0, type:{toString() {
        return "[protocol type:" + name + "]";
      }, name:"json", primitive:true, read:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}, write:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}}}, path:["options"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"reconfigure", request:{type:"reconfigure", template:{type:"reconfigure", options:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["options"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"resume", request:{type:"resume", template:{type:"resume", resumeLimit:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, frameActorID:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["resumeLimit"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["frameActorID"]}]}, response:{template:{_type:"nullable:json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, retVal:{_type:"nullable:json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:[]}, release:(void 0), oneway:(void 0)}, {name:"frames", request:{type:"frames", template:{type:"frames", start:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, count:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["start"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["count"]}]}, response:{template:{_type:"thread.frames", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, retVal:{_type:"thread.frames", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:[]}, release:(void 0), oneway:(void 0)}, {name:"interrupt", request:{type:"interrupt", template:{type:"interrupt", when:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["when"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"sources", request:{type:"sources", template:{type:"sources"}, args:[]}, response:{template:{sources:{_type:"array:json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, retVal:{_type:"array:json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["sources"]}, release:(void 0), oneway:(void 0)}, {name:"skipBreakpoints", request:{type:"skipBreakpoints", template:{type:"skipBreakpoints", skip:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["skip"]}]}, response:{template:{skip:{index:0, type:{toString() {
        return "[protocol type:" + name + "]";
      }, name:"json", primitive:true, read:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}, write:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}}}}}, release:(void 0), oneway:(void 0)}, {name:"dumpThread", request:{type:"dumpThread", template:{type:"dumpThread"}, args:[]}, response:{template:{_type:"json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, retVal:{_type:"json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:[]}, release:(void 0), oneway:(void 0)}, {name:"dumpPools", request:{type:"dumpPools", template:{type:"dumpPools"}, args:[]}, response:{template:{_type:"json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, retVal:{_type:"json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:[]}, release:(void 0), oneway:(void 0)}, {name:"setBreakpoint", request:{type:"setBreakpoint", template:{type:"setBreakpoint", location:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, options:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["location"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["options"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"removeBreakpoint", request:{type:"removeBreakpoint", template:{type:"removeBreakpoint", location:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["location"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"setXHRBreakpoint", request:{type:"setXHRBreakpoint", template:{type:"setXHRBreakpoint", path:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, method:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["path"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["method"]}]}, response:{template:{value:{_type:"boolean", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, retVal:{_type:"boolean", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["value"]}, release:(void 0), oneway:(void 0)}, {name:"removeXHRBreakpoint", request:{type:"removeXHRBreakpoint", template:{type:"removeXHRBreakpoint", path:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, method:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["path"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["method"]}]}, response:{template:{value:{_type:"boolean", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, retVal:{_type:"boolean", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["value"]}, release:(void 0), oneway:(void 0)}, {name:"getAvailableEventBreakpoints", request:{type:"getAvailableEventBreakpoints", template:{type:"getAvailableEventBreakpoints"}, args:[]}, response:{template:{value:{_type:"array:available-breakpoint-group", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, retVal:{_type:"array:available-breakpoint-group", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["value"]}, release:(void 0), oneway:(void 0)}, {name:"getActiveEventBreakpoints", request:{type:"getActiveEventBreakpoints", template:{type:"getActiveEventBreakpoints"}, args:[]}, response:{template:{ids:{_type:"array:string", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, retVal:{_type:"array:string", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["ids"]}, release:(void 0), oneway:(void 0)}, {name:"setActiveEventBreakpoints", request:{type:"setActiveEventBreakpoints", template:{type:"setActiveEventBreakpoints", ids:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["ids"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"pauseOnExceptions", request:{type:"pauseOnExceptions", template:{type:"pauseOnExceptions", pauseOnExceptions:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, ignoreCaughtExceptions:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["pauseOnExceptions"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["ignoreCaughtExceptions"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"toggleEventLogging", request:{type:"toggleEventLogging", template:{type:"toggleEventLogging", logEventBreakpoints:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["logEventBreakpoints"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"isAttached", request:{type:"isAttached", template:{type:"isAttached"}, args:[]}, response:{template:{value:{_type:"boolean", type:{toString() {
        return "[protocol type:" + name + "]";
      }, name:"boolean", primitive:true, read:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}, write:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}}}}, retVal:{_type:"boolean", type:{toString() {
        return "[protocol type:" + name + "]";
      }, name:"boolean", primitive:true, read:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}, write:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}}}, path:["value"]}, release:(void 0), oneway:(void 0)}], events:{}}, _state:"running", _parent:{}, global:{get window() {
    [native code]
}, get document() {
    [native code]
}, get location() {
    [native code]
}, set location() {
    [native code]
}, get top() {
    [native code]
}, close:function close() {
    [native code]
}, stop:function stop() {
    [native code]
}, focus:function focus() {
    [native code]
}, blur:function blur() {
    [native code]
}, open:function open() {
    [native code]
}, alert:function alert() {
    [native code]
}, confirm:function confirm() {
    [native code]
}, prompt:function prompt() {
    [native code]
}, print:function print() {
    [native code]
}, printPreview:function printPreview() {
    [native code]
}, postMessage:function postMessage() {
    [native code]
}, captureEvents:function captureEvents() {
    [native code]
}, releaseEvents:function releaseEvents() {
    [native code]
}, getSelection:function getSelection() {
    [native code]
}, getComputedStyle:function getComputedStyle() {
    [native code]
}, matchMedia:function matchMedia() {
    [native code]
}, moveTo:function moveTo() {
    [native code]
}, moveBy:function moveBy() {
    [native code]
}, resizeTo:function resizeTo() {
    [native code]
}, resizeBy:function resizeBy() {
    [native code]
}, scroll:function scroll() {
    [native code]
}, scrollTo:function scrollTo() {
    [native code]
}, scrollBy:function scrollBy() {
    [native code]
}, getDefaultComputedStyle:function getDefaultComputedStyle() {
    [native code]
}, scrollByLines:function scrollByLines() {
    [native code]
}, scrollByPages:function scrollByPages() {
    [native code]
}, sizeToContent:function sizeToContent() {
    [native code]
}, updateCommands:function updateCommands() {
    [native code]
}, find:function find() {
    [native code]
}, dump:function dump() {
    [native code]
}, setResizable:function setResizable() {
    [native code]
}, requestIdleCallback:function requestIdleCallback() {
    [native code]
}, cancelIdleCallback:function cancelIdleCallback() {
    [native code]
}, getRegionalPrefsLocales:function getRegionalPrefsLocales() {
    [native code]
}, getWebExposedLocales:function getWebExposedLocales() {
    [native code]
}, requestAnimationFrame:function requestAnimationFrame() {
    [native code]
}, cancelAnimationFrame:function cancelAnimationFrame() {
    [native code]
}, reportError:function reportError() {
    [native code]
}, btoa:function btoa() {
    [native code]
}, atob:function atob() {
    [native code]
}, setTimeout:function setTimeout() {
    [native code]
}, clearTimeout:function clearTimeout() {
    [native code]
}, setInterval:function setInterval() {
    [native code]
}, clearInterval:function clearInterval() {
    [native code]
}, queueMicrotask:function queueMicrotask() {
    [native code]
}, createImageBitmap:function createImageBitmap() {
    [native code]
}, structuredClone:function structuredClone() {
    [native code]
}, fetch:function fetch() {
    [native code]
}, get self() {
    [native code]
}, set self() {
    [native code]
}, get name() {
    [native code]
}, set name() {
    [native code]
}, get history() {
    [native code]
}, get customElements() {
    [native code]
}, get locationbar() {
    [native code]
}, set locationbar() {
    [native code]
}, get menubar() {
    [native code]
}, set menubar() {
    [native code]
}, get personalbar() {
    [native code]
}, set personalbar() {
    [native code]
}, get scrollbars() {
    [native code]
}, set scrollbars() {
    [native code]
}, get statusbar() {
    [native code]
}, set statusbar() {
    [native code]
}, get toolbar() {
    [native code]
}, set toolbar() {
    [native code]
}, get status() {
    [native code]
}, set status() {
    [native code]
}, get closed() {
    [native code]
}, get event() {
    [native code]
}, set event() {
    [native code]
}, get frames() {
    [native code]
}, set frames() {
    [native code]
}, get length() {
    [native code]
}, set length() {
    [native code]
}, get opener() {
    [native code]
}, set opener() {
    [native code]
}, get parent() {
    [native code]
}, set parent() {
    [native code]
}, get frameElement() {
    [native code]
}, get navigator() {
    [native code]
}, get clientInformation() {
    [native code]
}, get external() {
    [native code]
}, set external() {
    [native code]
}, get screen() {
    [native code]
}, set screen() {
    [native code]
}, get innerWidth() {
    [native code]
}, set innerWidth() {
    [native code]
}, get innerHeight() {
    [native code]
}, set innerHeight() {
    [native code]
}, get scrollX() {
    [native code]
}, set scrollX() {
    [native code]
}, get pageXOffset() {
    [native code]
}, set pageXOffset() {
    [native code]
}, get scrollY() {
    [native code]
}, set scrollY() {
    [native code]
}, get pageYOffset() {
    [native code]
}, set pageYOffset() {
    [native code]
}, get screenLeft() {
    [native code]
}, set screenLeft() {
    [native code]
}, get screenTop() {
    [native code]
}, set screenTop() {
    [native code]
}, get screenX() {
    [native code]
}, set screenX() {
    [native code]
}, get screenY() {
    [native code]
}, set screenY() {
    [native code]
}, get outerWidth() {
    [native code]
}, set outerWidth() {
    [native code]
}, get outerHeight() {
    [native code]
}, set outerHeight() {
    [native code]
}, get performance() {
    [native code]
}, set performance() {
    [native code]
}, get mozInnerScreenX() {
    [native code]
}, get mozInnerScreenY() {
    [native code]
}, get devicePixelRatio() {
    [native code]
}, set devicePixelRatio() {
    [native code]
}, get scrollMaxX() {
    [native code]
}, set scrollMaxX() {
    [native code]
}, get scrollMaxY() {
    [native code]
}, set scrollMaxY() {
    [native code]
}, get fullScreen() {
    [native code]
}, set fullScreen() {
    [native code]
}, get ondevicemotion() {
    [native code]
}, set ondevicemotion() {
    [native code]
}, get ondeviceorientation() {
    [native code]
}, set ondeviceorientation() {
    [native code]
}, get onabsolutedeviceorientation() {
    [native code]
}, set onabsolutedeviceorientation() {
    [native code]
}, get InstallTrigger() {
    [native code]
}, set InstallTrigger() {
    [native code]
}, get intlUtils() {
    [native code]
}, get visualViewport() {
    [native code]
}, set visualViewport() {
    [native code]
}, get crypto() {
    [native code]
}, get onabort() {
    [native code]
}, set onabort() {
    [native code]
}, get onblur() {
    [native code]
}, set onblur() {
    [native code]
}, get onfocus() {
    [native code]
}, set onfocus() {
    [native code]
}, get onauxclick() {
    [native code]
}, set onauxclick() {
    [native code]
}, get onbeforeinput() {
    [native code]
}, set onbeforeinput() {
    [native code]
}, get oncanplay() {
    [native code]
}, set oncanplay() {
    [native code]
}, get oncanplaythrough() {
    [native code]
}, set oncanplaythrough() {
    [native code]
}, get onchange() {
    [native code]
}, set onchange() {
    [native code]
}, get onclick() {
    [native code]
}, set onclick() {
    [native code]
}, get onclose() {
    [native code]
}, set onclose() {
    [native code]
}, get oncontextmenu() {
    [native code]
}, set oncontextmenu() {
    [native code]
}, get oncuechange() {
    [native code]
}, set oncuechange() {
    [native code]
}, get ondblclick() {
    [native code]
}, set ondblclick() {
    [native code]
}, get ondrag() {
    [native code]
}, set ondrag() {
    [native code]
}, get ondragend() {
    [native code]
}, set ondragend() {
    [native code]
}, get ondragenter() {
    [native code]
}, set ondragenter() {
    [native code]
}, get ondragexit() {
    [native code]
}, set ondragexit() {
    [native code]
}, get ondragleave() {
    [native code]
}, set ondragleave() {
    [native code]
}, get ondragover() {
    [native code]
}, set ondragover() {
    [native code]
}, get ondragstart() {
    [native code]
}, set ondragstart() {
    [native code]
}, get ondrop() {
    [native code]
}, set ondrop() {
    [native code]
}, get ondurationchange() {
    [native code]
}, set ondurationchange() {
    [native code]
}, get onemptied() {
    [native code]
}, set onemptied() {
    [native code]
}, get onended() {
    [native code]
}, set onended() {
    [native code]
}, get onformdata() {
    [native code]
}, set onformdata() {
    [native code]
}, get oninput() {
    [native code]
}, set oninput() {
    [native code]
}, get oninvalid() {
    [native code]
}, set oninvalid() {
    [native code]
}, get onkeydown() {
    [native code]
}, set onkeydown() {
    [native code]
}, get onkeypress() {
    [native code]
}, set onkeypress() {
    [native code]
}, get onkeyup() {
    [native code]
}, set onkeyup() {
    [native code]
}, get onload() {
    [native code]
}, set onload() {
    [native code]
}, get onloadeddata() {
    [native code]
}, set onloadeddata() {
    [native code]
}, get onloadedmetadata() {
    [native code]
}, set onloadedmetadata() {
    [native code]
}, get onloadend() {
    [native code]
}, set onloadend() {
    [native code]
}, get onloadstart() {
    [native code]
}, set onloadstart() {
    [native code]
}, get onmousedown() {
    [native code]
}, set onmousedown() {
    [native code]
}, get onmouseenter() {
    [native code]
}, set onmouseenter() {
    [native code]
}, get onmouseleave() {
    [native code]
}, set onmouseleave() {
    [native code]
}, get onmousemove() {
    [native code]
}, set onmousemove() {
    [native code]
}, get onmouseout() {
    [native code]
}, set onmouseout() {
    [native code]
}, get onmouseover() {
    [native code]
}, set onmouseover() {
    [native code]
}, get onmouseup() {
    [native code]
}, set onmouseup() {
    [native code]
}, get onwheel() {
    [native code]
}, set onwheel() {
    [native code]
}, get onpause() {
    [native code]
}, set onpause() {
    [native code]
}, get onplay() {
    [native code]
}, set onplay() {
    [native code]
}, get onplaying() {
    [native code]
}, set onplaying() {
    [native code]
}, get onprogress() {
    [native code]
}, set onprogress() {
    [native code]
}, get onratechange() {
    [native code]
}, set onratechange() {
    [native code]
}, get onreset() {
    [native code]
}, set onreset() {
    [native code]
}, get onresize() {
    [native code]
}, set onresize() {
    [native code]
}, get onscroll() {
    [native code]
}, set onscroll() {
    [native code]
}, get onsecuritypolicyviolation() {
    [native code]
}, set onsecuritypolicyviolation() {
    [native code]
}, get onseeked() {
    [native code]
}, set onseeked() {
    [native code]
}, get onseeking() {
    [native code]
}, set onseeking() {
    [native code]
}, get onselect() {
    [native code]
}, set onselect() {
    [native code]
}, get onslotchange() {
    [native code]
}, set onslotchange() {
    [native code]
}, get onstalled() {
    [native code]
}, set onstalled() {
    [native code]
}, get onsubmit() {
    [native code]
}, set onsubmit() {
    [native code]
}, get onsuspend() {
    [native code]
}, set onsuspend() {
    [native code]
}, get ontimeupdate() {
    [native code]
}, set ontimeupdate() {
    [native code]
}, get onvolumechange() {
    [native code]
}, set onvolumechange() {
    [native code]
}, get onwaiting() {
    [native code]
}, set onwaiting() {
    [native code]
}, get onselectstart() {
    [native code]
}, set onselectstart() {
    [native code]
}, get onselectionchange() {
    [native code]
}, set onselectionchange() {
    [native code]
}, get ontoggle() {
    [native code]
}, set ontoggle() {
    [native code]
}, get onpointercancel() {
    [native code]
}, set onpointercancel() {
    [native code]
}, get onpointerdown() {
    [native code]
}, set onpointerdown() {
    [native code]
}, get onpointerup() {
    [native code]
}, set onpointerup() {
    [native code]
}, get onpointermove() {
    [native code]
}, set onpointermove() {
    [native code]
}, get onpointerout() {
    [native code]
}, set onpointerout() {
    [native code]
}, get onpointerover() {
    [native code]
}, set onpointerover() {
    [native code]
}, get onpointerenter() {
    [native code]
}, set onpointerenter() {
    [native code]
}, get onpointerleave() {
    [native code]
}, set onpointerleave() {
    [native code]
}, get ongotpointercapture() {
    [native code]
}, set ongotpointercapture() {
    [native code]
}, get onlostpointercapture() {
    [native code]
}, set onlostpointercapture() {
    [native code]
}, get onmozfullscreenchange() {
    [native code]
}, set onmozfullscreenchange() {
    [native code]
}, get onmozfullscreenerror() {
    [native code]
}, set onmozfullscreenerror() {
    [native code]
}, get onanimationcancel() {
    [native code]
}, set onanimationcancel() {
    [native code]
}, get onanimationend() {
    [native code]
}, set onanimationend() {
    [native code]
}, get onanimationiteration() {
    [native code]
}, set onanimationiteration() {
    [native code]
}, get onanimationstart() {
    [native code]
}, set onanimationstart() {
    [native code]
}, get ontransitioncancel() {
    [native code]
}, set ontransitioncancel() {
    [native code]
}, get ontransitionend() {
    [native code]
}, set ontransitionend() {
    [native code]
}, get ontransitionrun() {
    [native code]
}, set ontransitionrun() {
    [native code]
}, get ontransitionstart() {
    [native code]
}, set ontransitionstart() {
    [native code]
}, get onwebkitanimationend() {
    [native code]
}, set onwebkitanimationend() {
    [native code]
}, get onwebkitanimationiteration() {
    [native code]
}, set onwebkitanimationiteration() {
    [native code]
}, get onwebkitanimationstart() {
    [native code]
}, set onwebkitanimationstart() {
    [native code]
}, get onwebkittransitionend() {
    [native code]
}, set onwebkittransitionend() {
    [native code]
}, get u2f() {
    [native code]
}, set u2f() {
    [native code]
}, get onerror() {
    [native code]
}, set onerror() {
    [native code]
}, get speechSynthesis() {
    [native code]
}, get onafterprint() {
    [native code]
}, set onafterprint() {
    [native code]
}, get onbeforeprint() {
    [native code]
}, set onbeforeprint() {
    [native code]
}, get onbeforeunload() {
    [native code]
}, set onbeforeunload() {
    [native code]
}, get onhashchange() {
    [native code]
}, set onhashchange() {
    [native code]
}, get onlanguagechange() {
    [native code]
}, set onlanguagechange() {
    [native code]
}, get onmessage() {
    [native code]
}, set onmessage() {
    [native code]
}, get onmessageerror() {
    [native code]
}, set onmessageerror() {
    [native code]
}, get onoffline() {
    [native code]
}, set onoffline() {
    [native code]
}, get ononline() {
    [native code]
}, set ononline() {
    [native code]
}, get onpagehide() {
    [native code]
}, set onpagehide() {
    [native code]
}, get onpageshow() {
    [native code]
}, set onpageshow() {
    [native code]
}, get onpopstate() {
    [native code]
}, set onpopstate() {
    [native code]
}, get onrejectionhandled() {
    [native code]
}, set onrejectionhandled() {
    [native code]
}, get onstorage() {
    [native code]
}, set onstorage() {
    [native code]
}, get onunhandledrejection() {
    [native code]
}, set onunhandledrejection() {
    [native code]
}, get onunload() {
    [native code]
}, set onunload() {
    [native code]
}, get ongamepadconnected() {
    [native code]
}, set ongamepadconnected() {
    [native code]
}, get ongamepaddisconnected() {
    [native code]
}, set ongamepaddisconnected() {
    [native code]
}, get localStorage() {
    [native code]
}, get origin() {
    [native code]
}, set origin() {
    [native code]
}, get crossOriginIsolated() {
    [native code]
}, get isSecureContext() {
    [native code]
}, get indexedDB() {
    [native code]
}, get caches() {
    [native code]
}, get sessionStorage() {
    [native code]
}, mozScrollSnap:function mozScrollSnap() {
    [native code]
}, openDialog:function openDialog() {
    [native code]
}, getInterface:function getInterface() {
    [native code]
}, shouldReportForServiceWorkerScope:function shouldReportForServiceWorkerScope() {
    [native code]
}, setScrollMarks:function setScrollMarks() {
    [native code]
}, get controllers() {
    [native code]
}, set controllers() {
    [native code]
}, get realFrameElement() {
    [native code]
}, get docShell() {
    [native code]
}, get browsingContext() {
    [native code]
}, get desktopToDeviceScale() {
    [native code]
}, get scrollMinX() {
    [native code]
}, get scrollMinY() {
    [native code]
}, get windowRoot() {
    [native code]
}, get windowUtils() {
    [native code]
}, get windowGlobalChild() {
    [native code]
}, get clientPrincipal() {
    [native code]
}, get isChromeWindow() {
    [native code]
}, get Glean() {
    [native code]
}, get GleanPings() {
    [native code]
}}, _options:{skipBreakpoints:false, pauseOnExceptions:false, ignoreCaughtExceptions:true, shouldShowOverlay:true, shouldIncludeSavedFrames:true, shouldIncludeAsyncLiveFrames:false, logEventBreakpoints:false, observeAsmJS:true}, _gripDepth:0, _parentClosed:false, _observingNetwork:false, _frameActors:[], _xhrBreakpoints:[], _dbg:{addDebuggees:(function() {
    for (const global of findDebuggees(this)) {
      safeAddDebuggee(this, global);
    }
  }), disable:(function() {
    dbg.removeAllDebuggees();
    dbg.onNewGlobalObject = undefined;
  }), enable:(function() {
    dbg.addDebuggees();
    dbg.onNewGlobalObject = onNewGlobalObject;
  }), onNewDebuggee:function bound _onNewDebuggee() {
    [native code]
}}, _threadLifetimePool:null, _activeEventPause:null, _pauseOverlay:null, _priorPause:null, _activeEventBreakpoints:{}, _frameActorMap:{}, _debuggerSourcesSeen:{}, _onLoadBreakpointURLs:{}, _handledFrameExceptions:{}, _watchpointsMap:{threadActor:{}, _watchpoints:{}}, breakpointActorMap:{_threadActor:{}, _actors:{}}, _nestedEventLoop:{_thread:{}, _entered:false, _resolved:false}, onNewSourceEvent:function bound onNewSourceEvent() {
    [native code]
}, createCompletionGrip:function bound createCompletionGrip() {
    [native code]
}, onDebuggerStatement:function bound onDebuggerStatement() {
    [native code]
}, onNewScript:function bound onNewScript() {
    [native code]
}, objectGrip:function bound objectGrip() {
    [native code]
}, pauseObjectGrip:function bound pauseObjectGrip() {
    [native code]
}, _onOpeningRequest:function bound _onOpeningRequest() {
    [native code]
}, _onNewDebuggee:function bound _onNewDebuggee() {
    [native code]
}, _onExceptionUnwind:function bound _onExceptionUnwind() {
    [native code]
}, _eventBreakpointListener:function bound _eventBreakpointListener() {
    [native code]
}, _onWindowReady:function bound _onWindowReady() {
    [native code]
}, _onWillNavigate:function bound _onWillNavigate() {
    [native code]
}, _onNavigate:function bound _onNavigate() {
    [native code]
}, _firstStatementBreakpoint:null, _debuggerNotificationObserver:{}, parentPool:{}, alreadyAttached:true, wrappedJSObject:{}, _shouldEmitNewSource:false, _pendingResponse:{}, [Symbol("EventEmitter/listeners")]:{}}, blackBoxedSources:{}, _sourceActors:{}, _urlContents:{}, _urlWaiters:{}, _sourcesByInternalSourceId:null, [Symbol("EventEmitter/listeners")]:{}}, _styleSheetActors:{}, _shouldAddNewGlobalAsDebuggee:function bound _shouldAddNewGlobalAsDebuggee() {
    [native code]
}, makeDebugger:function bound makeDebugger() {
    [native code]
}, watchNewDocShells:false, _isNewPerfPanelEnabled:true, _workerDescriptorActorList:null, _workerDescriptorActorPool:null, _onWorkerDescriptorActorListChanged:function bound _onWorkerDescriptorActorListChanged() {
    [native code]
}, _onConsoleApiProfilerEvent:function bound _onConsoleApiProfilerEvent() {
    [native code]
}, threadActor:{conn:{_prefix:"server0.conn0.windowGlobal4294967403/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967403", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {conn:{}, __poolMap:{}}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, actorID:"server0.conn0.windowGlobal4294967403/thread1", _actorSpec:{typeName:"thread", methods:[{name:"attach", request:{type:"attach", template:{type:"attach", options:{index:0, type:{toString() {
        return "[protocol type:" + name + "]";
      }, name:"json", primitive:true, read:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}, write:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}}}}, args:[{placeholder:{index:0, type:{toString() {
        return "[protocol type:" + name + "]";
      }, name:"json", primitive:true, read:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}, write:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}}}, path:["options"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"reconfigure", request:{type:"reconfigure", template:{type:"reconfigure", options:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["options"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"resume", request:{type:"resume", template:{type:"resume", resumeLimit:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, frameActorID:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["resumeLimit"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["frameActorID"]}]}, response:{template:{_type:"nullable:json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, retVal:{_type:"nullable:json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:[]}, release:(void 0), oneway:(void 0)}, {name:"frames", request:{type:"frames", template:{type:"frames", start:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, count:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["start"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["count"]}]}, response:{template:{_type:"thread.frames", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, retVal:{_type:"thread.frames", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:[]}, release:(void 0), oneway:(void 0)}, {name:"interrupt", request:{type:"interrupt", template:{type:"interrupt", when:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["when"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"sources", request:{type:"sources", template:{type:"sources"}, args:[]}, response:{template:{sources:{_type:"array:json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, retVal:{_type:"array:json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["sources"]}, release:(void 0), oneway:(void 0)}, {name:"skipBreakpoints", request:{type:"skipBreakpoints", template:{type:"skipBreakpoints", skip:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["skip"]}]}, response:{template:{skip:{index:0, type:{toString() {
        return "[protocol type:" + name + "]";
      }, name:"json", primitive:true, read:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}, write:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}}}}}, release:(void 0), oneway:(void 0)}, {name:"dumpThread", request:{type:"dumpThread", template:{type:"dumpThread"}, args:[]}, response:{template:{_type:"json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, retVal:{_type:"json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:[]}, release:(void 0), oneway:(void 0)}, {name:"dumpPools", request:{type:"dumpPools", template:{type:"dumpPools"}, args:[]}, response:{template:{_type:"json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, retVal:{_type:"json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:[]}, release:(void 0), oneway:(void 0)}, {name:"setBreakpoint", request:{type:"setBreakpoint", template:{type:"setBreakpoint", location:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, options:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["location"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["options"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"removeBreakpoint", request:{type:"removeBreakpoint", template:{type:"removeBreakpoint", location:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["location"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"setXHRBreakpoint", request:{type:"setXHRBreakpoint", template:{type:"setXHRBreakpoint", path:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, method:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["path"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["method"]}]}, response:{template:{value:{_type:"boolean", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, retVal:{_type:"boolean", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["value"]}, release:(void 0), oneway:(void 0)}, {name:"removeXHRBreakpoint", request:{type:"removeXHRBreakpoint", template:{type:"removeXHRBreakpoint", path:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, method:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["path"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["method"]}]}, response:{template:{value:{_type:"boolean", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, retVal:{_type:"boolean", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["value"]}, release:(void 0), oneway:(void 0)}, {name:"getAvailableEventBreakpoints", request:{type:"getAvailableEventBreakpoints", template:{type:"getAvailableEventBreakpoints"}, args:[]}, response:{template:{value:{_type:"array:available-breakpoint-group", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, retVal:{_type:"array:available-breakpoint-group", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["value"]}, release:(void 0), oneway:(void 0)}, {name:"getActiveEventBreakpoints", request:{type:"getActiveEventBreakpoints", template:{type:"getActiveEventBreakpoints"}, args:[]}, response:{template:{ids:{_type:"array:string", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, retVal:{_type:"array:string", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["ids"]}, release:(void 0), oneway:(void 0)}, {name:"setActiveEventBreakpoints", request:{type:"setActiveEventBreakpoints", template:{type:"setActiveEventBreakpoints", ids:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["ids"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"pauseOnExceptions", request:{type:"pauseOnExceptions", template:{type:"pauseOnExceptions", pauseOnExceptions:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, ignoreCaughtExceptions:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["pauseOnExceptions"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["ignoreCaughtExceptions"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"toggleEventLogging", request:{type:"toggleEventLogging", template:{type:"toggleEventLogging", logEventBreakpoints:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["logEventBreakpoints"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"isAttached", request:{type:"isAttached", template:{type:"isAttached"}, args:[]}, response:{template:{value:{_type:"boolean", type:{toString() {
        return "[protocol type:" + name + "]";
      }, name:"boolean", primitive:true, read:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}, write:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}}}}, retVal:{_type:"boolean", type:{toString() {
        return "[protocol type:" + name + "]";
      }, name:"boolean", primitive:true, read:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}, write:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}}}, path:["value"]}, release:(void 0), oneway:(void 0)}], events:{}}, _state:"running", _parent:{}, global:{get window() {
    [native code]
}, get document() {
    [native code]
}, get location() {
    [native code]
}, set location() {
    [native code]
}, get top() {
    [native code]
}, close:function close() {
    [native code]
}, stop:function stop() {
    [native code]
}, focus:function focus() {
    [native code]
}, blur:function blur() {
    [native code]
}, open:function open() {
    [native code]
}, alert:function alert() {
    [native code]
}, confirm:function confirm() {
    [native code]
}, prompt:function prompt() {
    [native code]
}, print:function print() {
    [native code]
}, printPreview:function printPreview() {
    [native code]
}, postMessage:function postMessage() {
    [native code]
}, captureEvents:function captureEvents() {
    [native code]
}, releaseEvents:function releaseEvents() {
    [native code]
}, getSelection:function getSelection() {
    [native code]
}, getComputedStyle:function getComputedStyle() {
    [native code]
}, matchMedia:function matchMedia() {
    [native code]
}, moveTo:function moveTo() {
    [native code]
}, moveBy:function moveBy() {
    [native code]
}, resizeTo:function resizeTo() {
    [native code]
}, resizeBy:function resizeBy() {
    [native code]
}, scroll:function scroll() {
    [native code]
}, scrollTo:function scrollTo() {
    [native code]
}, scrollBy:function scrollBy() {
    [native code]
}, getDefaultComputedStyle:function getDefaultComputedStyle() {
    [native code]
}, scrollByLines:function scrollByLines() {
    [native code]
}, scrollByPages:function scrollByPages() {
    [native code]
}, sizeToContent:function sizeToContent() {
    [native code]
}, updateCommands:function updateCommands() {
    [native code]
}, find:function find() {
    [native code]
}, dump:function dump() {
    [native code]
}, setResizable:function setResizable() {
    [native code]
}, requestIdleCallback:function requestIdleCallback() {
    [native code]
}, cancelIdleCallback:function cancelIdleCallback() {
    [native code]
}, getRegionalPrefsLocales:function getRegionalPrefsLocales() {
    [native code]
}, getWebExposedLocales:function getWebExposedLocales() {
    [native code]
}, requestAnimationFrame:function requestAnimationFrame() {
    [native code]
}, cancelAnimationFrame:function cancelAnimationFrame() {
    [native code]
}, reportError:function reportError() {
    [native code]
}, btoa:function btoa() {
    [native code]
}, atob:function atob() {
    [native code]
}, setTimeout:function setTimeout() {
    [native code]
}, clearTimeout:function clearTimeout() {
    [native code]
}, setInterval:function setInterval() {
    [native code]
}, clearInterval:function clearInterval() {
    [native code]
}, queueMicrotask:function queueMicrotask() {
    [native code]
}, createImageBitmap:function createImageBitmap() {
    [native code]
}, structuredClone:function structuredClone() {
    [native code]
}, fetch:function fetch() {
    [native code]
}, get self() {
    [native code]
}, set self() {
    [native code]
}, get name() {
    [native code]
}, set name() {
    [native code]
}, get history() {
    [native code]
}, get customElements() {
    [native code]
}, get locationbar() {
    [native code]
}, set locationbar() {
    [native code]
}, get menubar() {
    [native code]
}, set menubar() {
    [native code]
}, get personalbar() {
    [native code]
}, set personalbar() {
    [native code]
}, get scrollbars() {
    [native code]
}, set scrollbars() {
    [native code]
}, get statusbar() {
    [native code]
}, set statusbar() {
    [native code]
}, get toolbar() {
    [native code]
}, set toolbar() {
    [native code]
}, get status() {
    [native code]
}, set status() {
    [native code]
}, get closed() {
    [native code]
}, get event() {
    [native code]
}, set event() {
    [native code]
}, get frames() {
    [native code]
}, set frames() {
    [native code]
}, get length() {
    [native code]
}, set length() {
    [native code]
}, get opener() {
    [native code]
}, set opener() {
    [native code]
}, get parent() {
    [native code]
}, set parent() {
    [native code]
}, get frameElement() {
    [native code]
}, get navigator() {
    [native code]
}, get clientInformation() {
    [native code]
}, get external() {
    [native code]
}, set external() {
    [native code]
}, get screen() {
    [native code]
}, set screen() {
    [native code]
}, get innerWidth() {
    [native code]
}, set innerWidth() {
    [native code]
}, get innerHeight() {
    [native code]
}, set innerHeight() {
    [native code]
}, get scrollX() {
    [native code]
}, set scrollX() {
    [native code]
}, get pageXOffset() {
    [native code]
}, set pageXOffset() {
    [native code]
}, get scrollY() {
    [native code]
}, set scrollY() {
    [native code]
}, get pageYOffset() {
    [native code]
}, set pageYOffset() {
    [native code]
}, get screenLeft() {
    [native code]
}, set screenLeft() {
    [native code]
}, get screenTop() {
    [native code]
}, set screenTop() {
    [native code]
}, get screenX() {
    [native code]
}, set screenX() {
    [native code]
}, get screenY() {
    [native code]
}, set screenY() {
    [native code]
}, get outerWidth() {
    [native code]
}, set outerWidth() {
    [native code]
}, get outerHeight() {
    [native code]
}, set outerHeight() {
    [native code]
}, get performance() {
    [native code]
}, set performance() {
    [native code]
}, get mozInnerScreenX() {
    [native code]
}, get mozInnerScreenY() {
    [native code]
}, get devicePixelRatio() {
    [native code]
}, set devicePixelRatio() {
    [native code]
}, get scrollMaxX() {
    [native code]
}, set scrollMaxX() {
    [native code]
}, get scrollMaxY() {
    [native code]
}, set scrollMaxY() {
    [native code]
}, get fullScreen() {
    [native code]
}, set fullScreen() {
    [native code]
}, get ondevicemotion() {
    [native code]
}, set ondevicemotion() {
    [native code]
}, get ondeviceorientation() {
    [native code]
}, set ondeviceorientation() {
    [native code]
}, get onabsolutedeviceorientation() {
    [native code]
}, set onabsolutedeviceorientation() {
    [native code]
}, get InstallTrigger() {
    [native code]
}, set InstallTrigger() {
    [native code]
}, get intlUtils() {
    [native code]
}, get visualViewport() {
    [native code]
}, set visualViewport() {
    [native code]
}, get crypto() {
    [native code]
}, get onabort() {
    [native code]
}, set onabort() {
    [native code]
}, get onblur() {
    [native code]
}, set onblur() {
    [native code]
}, get onfocus() {
    [native code]
}, set onfocus() {
    [native code]
}, get onauxclick() {
    [native code]
}, set onauxclick() {
    [native code]
}, get onbeforeinput() {
    [native code]
}, set onbeforeinput() {
    [native code]
}, get oncanplay() {
    [native code]
}, set oncanplay() {
    [native code]
}, get oncanplaythrough() {
    [native code]
}, set oncanplaythrough() {
    [native code]
}, get onchange() {
    [native code]
}, set onchange() {
    [native code]
}, get onclick() {
    [native code]
}, set onclick() {
    [native code]
}, get onclose() {
    [native code]
}, set onclose() {
    [native code]
}, get oncontextmenu() {
    [native code]
}, set oncontextmenu() {
    [native code]
}, get oncuechange() {
    [native code]
}, set oncuechange() {
    [native code]
}, get ondblclick() {
    [native code]
}, set ondblclick() {
    [native code]
}, get ondrag() {
    [native code]
}, set ondrag() {
    [native code]
}, get ondragend() {
    [native code]
}, set ondragend() {
    [native code]
}, get ondragenter() {
    [native code]
}, set ondragenter() {
    [native code]
}, get ondragexit() {
    [native code]
}, set ondragexit() {
    [native code]
}, get ondragleave() {
    [native code]
}, set ondragleave() {
    [native code]
}, get ondragover() {
    [native code]
}, set ondragover() {
    [native code]
}, get ondragstart() {
    [native code]
}, set ondragstart() {
    [native code]
}, get ondrop() {
    [native code]
}, set ondrop() {
    [native code]
}, get ondurationchange() {
    [native code]
}, set ondurationchange() {
    [native code]
}, get onemptied() {
    [native code]
}, set onemptied() {
    [native code]
}, get onended() {
    [native code]
}, set onended() {
    [native code]
}, get onformdata() {
    [native code]
}, set onformdata() {
    [native code]
}, get oninput() {
    [native code]
}, set oninput() {
    [native code]
}, get oninvalid() {
    [native code]
}, set oninvalid() {
    [native code]
}, get onkeydown() {
    [native code]
}, set onkeydown() {
    [native code]
}, get onkeypress() {
    [native code]
}, set onkeypress() {
    [native code]
}, get onkeyup() {
    [native code]
}, set onkeyup() {
    [native code]
}, get onload() {
    [native code]
}, set onload() {
    [native code]
}, get onloadeddata() {
    [native code]
}, set onloadeddata() {
    [native code]
}, get onloadedmetadata() {
    [native code]
}, set onloadedmetadata() {
    [native code]
}, get onloadend() {
    [native code]
}, set onloadend() {
    [native code]
}, get onloadstart() {
    [native code]
}, set onloadstart() {
    [native code]
}, get onmousedown() {
    [native code]
}, set onmousedown() {
    [native code]
}, get onmouseenter() {
    [native code]
}, set onmouseenter() {
    [native code]
}, get onmouseleave() {
    [native code]
}, set onmouseleave() {
    [native code]
}, get onmousemove() {
    [native code]
}, set onmousemove() {
    [native code]
}, get onmouseout() {
    [native code]
}, set onmouseout() {
    [native code]
}, get onmouseover() {
    [native code]
}, set onmouseover() {
    [native code]
}, get onmouseup() {
    [native code]
}, set onmouseup() {
    [native code]
}, get onwheel() {
    [native code]
}, set onwheel() {
    [native code]
}, get onpause() {
    [native code]
}, set onpause() {
    [native code]
}, get onplay() {
    [native code]
}, set onplay() {
    [native code]
}, get onplaying() {
    [native code]
}, set onplaying() {
    [native code]
}, get onprogress() {
    [native code]
}, set onprogress() {
    [native code]
}, get onratechange() {
    [native code]
}, set onratechange() {
    [native code]
}, get onreset() {
    [native code]
}, set onreset() {
    [native code]
}, get onresize() {
    [native code]
}, set onresize() {
    [native code]
}, get onscroll() {
    [native code]
}, set onscroll() {
    [native code]
}, get onsecuritypolicyviolation() {
    [native code]
}, set onsecuritypolicyviolation() {
    [native code]
}, get onseeked() {
    [native code]
}, set onseeked() {
    [native code]
}, get onseeking() {
    [native code]
}, set onseeking() {
    [native code]
}, get onselect() {
    [native code]
}, set onselect() {
    [native code]
}, get onslotchange() {
    [native code]
}, set onslotchange() {
    [native code]
}, get onstalled() {
    [native code]
}, set onstalled() {
    [native code]
}, get onsubmit() {
    [native code]
}, set onsubmit() {
    [native code]
}, get onsuspend() {
    [native code]
}, set onsuspend() {
    [native code]
}, get ontimeupdate() {
    [native code]
}, set ontimeupdate() {
    [native code]
}, get onvolumechange() {
    [native code]
}, set onvolumechange() {
    [native code]
}, get onwaiting() {
    [native code]
}, set onwaiting() {
    [native code]
}, get onselectstart() {
    [native code]
}, set onselectstart() {
    [native code]
}, get onselectionchange() {
    [native code]
}, set onselectionchange() {
    [native code]
}, get ontoggle() {
    [native code]
}, set ontoggle() {
    [native code]
}, get onpointercancel() {
    [native code]
}, set onpointercancel() {
    [native code]
}, get onpointerdown() {
    [native code]
}, set onpointerdown() {
    [native code]
}, get onpointerup() {
    [native code]
}, set onpointerup() {
    [native code]
}, get onpointermove() {
    [native code]
}, set onpointermove() {
    [native code]
}, get onpointerout() {
    [native code]
}, set onpointerout() {
    [native code]
}, get onpointerover() {
    [native code]
}, set onpointerover() {
    [native code]
}, get onpointerenter() {
    [native code]
}, set onpointerenter() {
    [native code]
}, get onpointerleave() {
    [native code]
}, set onpointerleave() {
    [native code]
}, get ongotpointercapture() {
    [native code]
}, set ongotpointercapture() {
    [native code]
}, get onlostpointercapture() {
    [native code]
}, set onlostpointercapture() {
    [native code]
}, get onmozfullscreenchange() {
    [native code]
}, set onmozfullscreenchange() {
    [native code]
}, get onmozfullscreenerror() {
    [native code]
}, set onmozfullscreenerror() {
    [native code]
}, get onanimationcancel() {
    [native code]
}, set onanimationcancel() {
    [native code]
}, get onanimationend() {
    [native code]
}, set onanimationend() {
    [native code]
}, get onanimationiteration() {
    [native code]
}, set onanimationiteration() {
    [native code]
}, get onanimationstart() {
    [native code]
}, set onanimationstart() {
    [native code]
}, get ontransitioncancel() {
    [native code]
}, set ontransitioncancel() {
    [native code]
}, get ontransitionend() {
    [native code]
}, set ontransitionend() {
    [native code]
}, get ontransitionrun() {
    [native code]
}, set ontransitionrun() {
    [native code]
}, get ontransitionstart() {
    [native code]
}, set ontransitionstart() {
    [native code]
}, get onwebkitanimationend() {
    [native code]
}, set onwebkitanimationend() {
    [native code]
}, get onwebkitanimationiteration() {
    [native code]
}, set onwebkitanimationiteration() {
    [native code]
}, get onwebkitanimationstart() {
    [native code]
}, set onwebkitanimationstart() {
    [native code]
}, get onwebkittransitionend() {
    [native code]
}, set onwebkittransitionend() {
    [native code]
}, get u2f() {
    [native code]
}, set u2f() {
    [native code]
}, get onerror() {
    [native code]
}, set onerror() {
    [native code]
}, get speechSynthesis() {
    [native code]
}, get onafterprint() {
    [native code]
}, set onafterprint() {
    [native code]
}, get onbeforeprint() {
    [native code]
}, set onbeforeprint() {
    [native code]
}, get onbeforeunload() {
    [native code]
}, set onbeforeunload() {
    [native code]
}, get onhashchange() {
    [native code]
}, set onhashchange() {
    [native code]
}, get onlanguagechange() {
    [native code]
}, set onlanguagechange() {
    [native code]
}, get onmessage() {
    [native code]
}, set onmessage() {
    [native code]
}, get onmessageerror() {
    [native code]
}, set onmessageerror() {
    [native code]
}, get onoffline() {
    [native code]
}, set onoffline() {
    [native code]
}, get ononline() {
    [native code]
}, set ononline() {
    [native code]
}, get onpagehide() {
    [native code]
}, set onpagehide() {
    [native code]
}, get onpageshow() {
    [native code]
}, set onpageshow() {
    [native code]
}, get onpopstate() {
    [native code]
}, set onpopstate() {
    [native code]
}, get onrejectionhandled() {
    [native code]
}, set onrejectionhandled() {
    [native code]
}, get onstorage() {
    [native code]
}, set onstorage() {
    [native code]
}, get onunhandledrejection() {
    [native code]
}, set onunhandledrejection() {
    [native code]
}, get onunload() {
    [native code]
}, set onunload() {
    [native code]
}, get ongamepadconnected() {
    [native code]
}, set ongamepadconnected() {
    [native code]
}, get ongamepaddisconnected() {
    [native code]
}, set ongamepaddisconnected() {
    [native code]
}, get localStorage() {
    [native code]
}, get origin() {
    [native code]
}, set origin() {
    [native code]
}, get crossOriginIsolated() {
    [native code]
}, get isSecureContext() {
    [native code]
}, get indexedDB() {
    [native code]
}, get caches() {
    [native code]
}, get sessionStorage() {
    [native code]
}, mozScrollSnap:function mozScrollSnap() {
    [native code]
}, openDialog:function openDialog() {
    [native code]
}, getInterface:function getInterface() {
    [native code]
}, shouldReportForServiceWorkerScope:function shouldReportForServiceWorkerScope() {
    [native code]
}, setScrollMarks:function setScrollMarks() {
    [native code]
}, get controllers() {
    [native code]
}, set controllers() {
    [native code]
}, get realFrameElement() {
    [native code]
}, get docShell() {
    [native code]
}, get browsingContext() {
    [native code]
}, get desktopToDeviceScale() {
    [native code]
}, get scrollMinX() {
    [native code]
}, get scrollMinY() {
    [native code]
}, get windowRoot() {
    [native code]
}, get windowUtils() {
    [native code]
}, get windowGlobalChild() {
    [native code]
}, get clientPrincipal() {
    [native code]
}, get isChromeWindow() {
    [native code]
}, get Glean() {
    [native code]
}, get GleanPings() {
    [native code]
}}, _options:{skipBreakpoints:false, pauseOnExceptions:false, ignoreCaughtExceptions:true, shouldShowOverlay:true, shouldIncludeSavedFrames:true, shouldIncludeAsyncLiveFrames:false, logEventBreakpoints:false, observeAsmJS:true}, _gripDepth:0, _parentClosed:false, _observingNetwork:false, _frameActors:[], _xhrBreakpoints:[], _dbg:{addDebuggees:(function() {
    for (const global of findDebuggees(this)) {
      safeAddDebuggee(this, global);
    }
  }), disable:(function() {
    dbg.removeAllDebuggees();
    dbg.onNewGlobalObject = undefined;
  }), enable:(function() {
    dbg.addDebuggees();
    dbg.onNewGlobalObject = onNewGlobalObject;
  }), onNewDebuggee:function bound _onNewDebuggee() {
    [native code]
}}, _threadLifetimePool:null, _activeEventPause:null, _pauseOverlay:null, _priorPause:null, _activeEventBreakpoints:{}, _frameActorMap:{}, _debuggerSourcesSeen:{}, _onLoadBreakpointURLs:{}, _handledFrameExceptions:{}, _watchpointsMap:{threadActor:{}, _watchpoints:{}}, breakpointActorMap:{_threadActor:{}, _actors:{}}, _nestedEventLoop:{_thread:{}, _entered:false, _resolved:false}, onNewSourceEvent:function bound onNewSourceEvent() {
    [native code]
}, createCompletionGrip:function bound createCompletionGrip() {
    [native code]
}, onDebuggerStatement:function bound onDebuggerStatement() {
    [native code]
}, onNewScript:function bound onNewScript() {
    [native code]
}, objectGrip:function bound objectGrip() {
    [native code]
}, pauseObjectGrip:function bound pauseObjectGrip() {
    [native code]
}, _onOpeningRequest:function bound _onOpeningRequest() {
    [native code]
}, _onNewDebuggee:function bound _onNewDebuggee() {
    [native code]
}, _onExceptionUnwind:function bound _onExceptionUnwind() {
    [native code]
}, _eventBreakpointListener:function bound _eventBreakpointListener() {
    [native code]
}, _onWindowReady:function bound _onWindowReady() {
    [native code]
}, _onWillNavigate:function bound _onWillNavigate() {
    [native code]
}, _onNavigate:function bound _onNavigate() {
    [native code]
}, _firstStatementBreakpoint:null, _debuggerNotificationObserver:{}, parentPool:{}, alreadyAttached:true, wrappedJSObject:{}, _shouldEmitNewSource:false, _pendingResponse:{}, [Symbol("EventEmitter/listeners")]:{}}, __poolMap:{}, _progressListener:{_targetActor:{}, _onWindowCreated:function bound () {
    [native code]
}, _onWindowHidden:function bound () {
    [native code]
}, _knownWindowIDs:{}, _watchedDocShells:{}}, _docShellsObserved:true, parentPool:{}, createdFromJsWindowActor:true, _targetScopedActorPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967403/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, _onConnectionChange:function bound _onConnectionChange() {
    [native code]
}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
} = {}) {
  const paths = {
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  // DAMP tests use a dynamic path. If DEBUG_DEVTOOLS_DAMP_TEST_PATH was set as
  // a custom preference, add a corresponding path mapping entry.
  // DAMP runner and tests are under testing/talos/talos/tests/devtools
  const dampTestPath = Services.prefs.getCharPref(
    "devtools.damp.test-path",
    ""
  );
  if (dampTestPath) {
    // damp-test points to testing/talos/talos/tests/devtools/addon/content/
    // (prefixed by the dynamically generated talos server)
    paths["damp-test"] = dampTestPath;
  }

  this.loader = new Loader({
    paths,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "devtools/shared/loader/builtin-modules"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.globals,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.import("resource://devtools/shared/loader/Loader.jsm");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyImporter = globals.loader.lazyImporter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get: function() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyImporter:function defineLazyModuleGetter(object, name, resource) {
  defineLazyGetter(object, name, function() {
    try {
      return ChromeUtils.import(resource)[name];
    } catch (ex) {
      Cu.reportError("Failed to load module " + resource + ".");
      throw ex;
    }
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, StructuredCloneHolder:(void 0)}}, _prefix:"server0.conn0.windowGlobal4294967403", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:22, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, _dbg:{addDebuggees:(function() {
    for (const global of findDebuggees(this)) {
      safeAddDebuggee(this, global);
    }
  }), disable:(function() {
    dbg.removeAllDebuggees();
    dbg.onNewGlobalObject = undefined;
  }), enable:(function() {
    dbg.addDebuggees();
    dbg.onNewGlobalObject = onNewGlobalObject;
  }), onNewDebuggee:function bound _onNewDebuggee() {
    [native code]
}}, _styleSheetManager:{_styleSheetCount:0, _styleSheetMap:{}, _mqlList:[], _targetActor:{}, _onApplicableStateChanged:function bound _onApplicableStateChanged() {
    [native code]
}, _onTargetActorWindowReady:function bound _onTargetActorWindowReady() {
    [native code]
}, [Symbol("EventEmitter/listeners")]:{}}, [Symbol("EventEmitter/listeners")]:{}}) ": " (new TypeError("this._targetActor.chromeEventHandler is null", "resource://devtools/server/actors/utils/stylesheets-manager.js", 868))
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 1710: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/connectors/js-window-actor/DevToolsFrameChild.jsm, line 402: InvalidStateError: JSWindowActorChild.sendAsyncMessage: JSWindowActorChild cannot send at the moment
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 420: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 420: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
console.error: (new TypeError("parent is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: parent is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
console.error: "Error while calling actor 'pagestyle's method 'getLayout'" "node is null"
console.error: (new TypeError("node is null", "resource://devtools/server/actors/page-style.js", 1001))
console.error: (new Error("Protocol error (TypeError): node is null from: server0.conn0.windowGlobal4294967299/pagestyle26 (resource://devtools/server/actors/page-style.js:1001:5)", "resource://devtools/shared/protocol/Front.js", 365))
console.error: "Error while calling actor 'pagestyle's method 'getApplied'" "node is null"
console.error: (new TypeError("node is null", "resource://devtools/server/actors/page-style.js", 570))
console.error: (new Error("Protocol error (TypeError): node is null from: server0.conn0.windowGlobal4294967299/pagestyle26 (resource://devtools/server/actors/page-style.js:570:5)", "resource://devtools/shared/protocol/Front.js", 365))
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 420: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: , line 0: NS_ERROR_NOT_AVAILABLE
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
console.error: "Error while calling actor 'pagestyle's method 'getApplied'" "node is null"
console.error: (new TypeError("node is null", "resource://devtools/server/actors/page-style.js", 570))
console.error: (new TypeError("null has no properties", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: null has no properties: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

console.error: (new Error("Protocol error (TypeError): node is null from: server0.conn0.windowGlobal4294967299/pagestyle26 (resource://devtools/server/actors/page-style.js:570:5)", "resource://devtools/shared/protocol/Front.js", 365))
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
console.error: "Error while calling actor 'pagestyle's method 'getApplied'" "node is null"
console.error: (new TypeError("node is null", "resource://devtools/server/actors/page-style.js", 570))
console.error: (new TypeError("null has no properties", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: null has no properties: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

console.error: (new Error("Protocol error (TypeError): node is null from: server0.conn0.windowGlobal4294967299/pagestyle26 (resource://devtools/server/actors/page-style.js:570:5)", "resource://devtools/shared/protocol/Front.js", 365))
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 420: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
console.error: (new TypeError("null has no properties", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: null has no properties: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 467: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/1650528757508	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "61950" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofilecdNArv"
1650528758165	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofilecdNArv\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:61950/devtools/browser/4e6dcd6f-9102-4fea-aabb-293269e55624
1650528760650	Marionette	INFO	Listening on port 61955
1650528760776	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
JavaScript error: resource://gre/modules/LoginManagerParent.jsm, line 136: TypeError: gRecipeManager is null
JavaScript warning: https://gen-bizbd.com/web/content/53594-92c9dad/web.assets_backend.js, line 5051: unreachable code after return statement
SourceActor threw an exception: [Exception... "Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]"  nsresult: "0x80470002 (NS_BASE_STREAM_CLOSED)"  location: "JS frame :: resource://devtools/shared/DevToolsUtils.js :: onResponse :: line 567"  data: no]
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:567:34
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 567, column: 0
console.error: ({})
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 567: NS_BASE_STREAM_CLOSED: Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]
SourceActor threw an exception: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:556:16
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 556, column: 16
console.error: (new Error("Failed to fetch https://gen-bizbd.com/web. Code 2152924148.", "resource://devtools/shared/DevToolsUtils.js", 556))
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 556: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
console.error: (new TypeError("parent is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: parent is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

console.error: (new TypeError("parent is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: parent is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

console.error: "Error while calling actor 'pagestyle's method 'getApplied'" "node is null"
console.error: (new TypeError("node is null", "resource://devtools/server/actors/page-style.js", 570))
console.error: (new Error("Protocol error (TypeError): node is null from: server0.conn0.windowGlobal4294967299/pagestyle26 (resource://devtools/server/actors/page-style.js:570:5)", "resource://devtools/shared/protocol/Front.js", 365))
console.error: (new TypeError("parent is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: parent is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

JavaScript error: , line 0: NotFoundError: No such JSWindowActor 'DevToolsFrame'
SourceActor threw an exception: [Exception... "Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]"  nsresult: "0x80470002 (NS_BASE_STREAM_CLOSED)"  location: "JS frame :: resource://devtools/shared/DevToolsUtils.js :: onResponse :: line 567"  data: no]
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:567:34
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 567, column: 0
console.error: ({})
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 567: NS_BASE_STREAM_CLOSED: Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]
SourceActor threw an exception: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:556:16
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 556, column: 16
console.error: (new Error("Failed to fetch https://gen-bizbd.com/web. Code 2152924148.", "resource://devtools/shared/DevToolsUtils.js", 556))
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 556: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
JavaScript error: , line 0: NS_ERROR_NOT_AVAILABLE
console.error: "Error while calling actor 'pagestyle's method 'getApplied'" "node is null"
console.error: (new TypeError("node is null", "resource://devtools/server/actors/page-style.js", 570))
console.error: (new TypeError("parent is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: parent is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

console.error: (new Error("Protocol error (TypeError): node is null from: server0.conn1.windowGlobal4294967299/pagestyle26 (resource://devtools/server/actors/page-style.js:570:5)", "resource://devtools/shared/protocol/Front.js", 365))
console.error: (new TypeError("parent is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: parent is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

console.error: (new TypeError("parent is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: parent is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

console.error: "Error while calling actor 'pagestyle's method 'getApplied'" "node is null"
console.error: (new TypeError("node is null", "resource://devtools/server/actors/page-style.js", 570))
console.error: (new TypeError("parent is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: parent is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

console.error: (new Error("Protocol error (TypeError): node is null from: server0.conn1.windowGlobal4294967299/pagestyle26 (resource://devtools/server/actors/page-style.js:570:5)", "resource://devtools/shared/protocol/Front.js", 365))
console.error: "Error while calling actor 'pagestyle's method 'getLayout'" "node is null"
console.error: (new TypeError("node is null", "resource://devtools/server/actors/page-style.js", 1001))
console.error: (new TypeError("null has no properties", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: null has no properties: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

console.error: (new Error("Protocol error (TypeError): node is null from: server0.conn1.windowGlobal4294967299/pagestyle26 (resource://devtools/server/actors/page-style.js:1001:5)", "resource://devtools/shared/protocol/Front.js", 365))
console.error: (new TypeError("null has no properties", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: null has no properties: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

JavaScript error: , line 0: NotFoundError: No such JSWindowActor 'DevToolsFrame'
SourceActor threw an exception: [Exception... "Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]"  nsresult: "0x80470002 (NS_BASE_STREAM_CLOSED)"  location: "JS frame :: resource://devtools/shared/DevToolsUtils.js :: onResponse :: line 567"  data: no]
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:567:34
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 567, column: 0
console.error: ({})
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 567: NS_BASE_STREAM_CLOSED: Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]
SourceActor threw an exception: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:556:16
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 556, column: 16
console.error: (new Error("Failed to fetch https://gen-bizbd.com/web. Code 2152924148.", "resource://devtools/shared/DevToolsUtils.js", 556))
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 556: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
JavaScript error: , line 0: NotFoundError: No such JSWindowActor 'DevToolsFrame'
SourceActor threw an exception: [Exception... "Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]"  nsresult: "0x80470002 (NS_BASE_STREAM_CLOSED)"  location: "JS frame :: resource://devtools/shared/DevToolsUtils.js :: onResponse :: line 567"  data: no]
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:567:34
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 567, column: 0
console.error: ({})
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 567: NS_BASE_STREAM_CLOSED: Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]
SourceActor threw an exception: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:556:16
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 556, column: 16
console.error: (new Error("Failed to fetch https://gen-bizbd.com/web. Code 2152924148.", "resource://devtools/shared/DevToolsUtils.js", 556))
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 556: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
JavaScript error: , line 0: NotFoundError: No such JSWindowActor 'DevToolsFrame'
SourceActor threw an exception: [Exception... "Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]"  nsresult: "0x80470002 (NS_BASE_STREAM_CLOSED)"  location: "JS frame :: resource://devtools/shared/DevToolsUtils.js :: onResponse :: line 567"  data: no]
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:567:34
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 567, column: 0
console.error: ({})
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 567: NS_BASE_STREAM_CLOSED: Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]
SourceActor threw an exception: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:556:16
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 556, column: 16
console.error: (new Error("Failed to fetch https://gen-bizbd.com/web. Code 2152924148.", "resource://devtools/shared/DevToolsUtils.js", 556))
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 556: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
JavaScript error: , line 0: NotFoundError: No such JSWindowActor 'DevToolsFrame'
SourceActor threw an exception: [Exception... "Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]"  nsresult: "0x80470002 (NS_BASE_STREAM_CLOSED)"  location: "JS frame :: resource://devtools/shared/DevToolsUtils.js :: onResponse :: line 567"  data: no]
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:567:34
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 567, column: 0
console.error: ({})
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 567: NS_BASE_STREAM_CLOSED: Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]
SourceActor threw an exception: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:556:16
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 556, column: 16
console.error: (new Error("Failed to fetch https://gen-bizbd.com/web. Code 2152924148.", "resource://devtools/shared/DevToolsUtils.js", 556))
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 556: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
JavaScript error: , line 0: NotFoundError: No such JSWindowActor 'DevToolsFrame'
SourceActor threw an exception: [Exception... "Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]"  nsresult: "0x80470002 (NS_BASE_STREAM_CLOSED)"  location: "JS frame :: resource://devtools/shared/DevToolsUtils.js :: onResponse :: line 567"  data: no]
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:567:34
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 567, column: 0
console.error: ({})
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 567: NS_BASE_STREAM_CLOSED: Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]
SourceActor threw an exception: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:556:16
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 556, column: 16
console.error: (new Error("Failed to fetch https://gen-bizbd.com/web. Code 2152924148.", "resource://devtools/shared/DevToolsUtils.js", 556))
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 556: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
JavaScript error: , line 0: NotFoundError: No such JSWindowActor 'DevToolsFrame'
SourceActor threw an exception: [Exception... "Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]"  nsresult: "0x80470002 (NS_BASE_STREAM_CLOSED)"  location: "JS frame :: resource://devtools/shared/DevToolsUtils.js :: onResponse :: line 567"  data: no]
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:567:34
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 567, column: 0
console.error: ({})
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 567: NS_BASE_STREAM_CLOSED: Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]
SourceActor threw an exception: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:556:16
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 556, column: 16
console.error: (new Error("Failed to fetch https://gen-bizbd.com/web. Code 2152924148.", "resource://devtools/shared/DevToolsUtils.js", 556))
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 556: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
JavaScript error: , line 0: NotFoundError: No such JSWindowActor 'DevToolsFrame'
SourceActor threw an exception: [Exception... "Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]"  nsresult: "0x80470002 (NS_BASE_STREAM_CLOSED)"  location: "JS frame :: resource://devtools/shared/DevToolsUtils.js :: onResponse :: line 567"  data: no]
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:567:34
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 567, column: 0
console.error: ({})
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 567: NS_BASE_STREAM_CLOSED: Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]
SourceActor threw an exception: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:556:16
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 556, column: 16
console.error: (new Error("Failed to fetch https://gen-bizbd.com/web. Code 2152924148.", "resource://devtools/shared/DevToolsUtils.js", 556))
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 556: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
JavaScript error: , line 0: NotFoundError: No such JSWindowActor 'DevToolsFrame'
SourceActor threw an exception: [Exception... "Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]"  nsresult: "0x80470002 (NS_BASE_STREAM_CLOSED)"  location: "JS frame :: resource://devtools/shared/DevToolsUtils.js :: onResponse :: line 567"  data: no]
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:567:34
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 567, column: 0
console.error: ({})
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 567: NS_BASE_STREAM_CLOSED: Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]
SourceActor threw an exception: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:556:16
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 556, column: 16
console.error: (new Error("Failed to fetch https://gen-bizbd.com/web. Code 2152924148.", "resource://devtools/shared/DevToolsUtils.js", 556))
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 556: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
JavaScript error: , line 0: NotFoundError: No such JSWindowActor 'DevToolsFrame'
SourceActor threw an exception: [Exception... "Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]"  nsresult: "0x80470002 (NS_BASE_STREAM_CLOSED)"  location: "JS frame :: resource://devtools/shared/DevToolsUtils.js :: onResponse :: line 567"  data: no]
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:567:34
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 567, column: 0
console.error: ({})
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 567: NS_BASE_STREAM_CLOSED: Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]
SourceActor threw an exception: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:556:16
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 556, column: 16
console.error: (new Error("Failed to fetch https://gen-bizbd.com/web. Code 2152924148.", "resource://devtools/shared/DevToolsUtils.js", 556))
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 556: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
JavaScript error: , line 0: NotFoundError: No such JSWindowActor 'DevToolsFrame'
1650530086408	Marionette	INFO	Stopped listening on port 6195165
###!!! [Child][PContentChild] Error: RunMessage(msgname=PHttpChannel::Msg_DeleteSelf) Channel closing: too late to send/recv, messages will be lost

console.warn: TopSitesFeed: Failed to fetch data from Contile server: NetworkError when attempti1650530087261	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileV6P4oi\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:56458/devtools/browser/c7e51983-0cfd-44e0-b112-699cd68e8e31
1650530089816	Marionette	INFO	Listening on port 56463
1650530089846	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.error: Region.jsm: "Error fetching region" (new Error("TIMEOUT", "resource://gre/modules/Region.jsm", 772))
console.error: Region.jsm: "Failed to fetch region" (new Error("TIMEOUT", "resource://gre/modules/Region.jsm", 419))
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
JavaScript error: resource://gre/modules/LoginManagerParent.jsm, line 136: TypeError: gRecipeManager is null
JavaScript warning: https://gen-bizbd.com/web/content/53594-92c9dad/web.assets_backend.js, line 5051: unreachable code after return statement
SourceActor threw an exception: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:556:16
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 556, column: 16
console.error: (new Error("Failed to fetch https://gen-bizbd.com/web. Code 2152924148.", "resource://devtools/shared/DevToolsUtils.js", 556))
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 556: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
SourceActor threw an exception: [Exception... "Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]"  nsresult: "0x80470002 (NS_BASE_STREAM_CLOSED)"  location: "JS frame :: resource://devtools/shared/DevToolsUtils.js :: onResponse :: line 567"  data: no]
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:567:34
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 567, column: 0
console.error: ({})
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 567: NS_BASE_STREAM_CLOSED: Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 575: NotFoundError: No such JSWindowActor 'DevToolsFrame'
1650530535652	Marionette	INFO	Stopped listening on port 56463
1650532989148	geckodriver	INFO	Listening on 127.0.0.1:58221
1650532992502	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "58222" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofilecuYLN3"
1650532994514	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofilecuYLN3\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:58222/devtools/browser/26c4b56c-abc2-478f-9e31-ab0183f14148
1650532999121	Marionette	INFO	Listening on port 58227
1650532999639	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
JavaScript error: resource://gre/modules/LoginManagerParent.jsm, line 136: TypeError: gRecipeManager is null
JavaScript warning: https://gen-bizbd.com/web/content/53594-92c9dad/web.assets_backend.js, line 5051: unreachable code after return statement
SourceActor threw an exception: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:556:16
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 556, column: 16
console.error: (new Error("Failed to fetch https://gen-bizbd.com/web. Code 2152924148.", "resource://devtools/shared/DevToolsUtils.js", 556))
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 556: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
SourceActor threw an exception: [Exception... "Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]"  nsresult: "0x80470002 (NS_BASE_STREAM_CLOSED)"  location: "JS frame :: resource://devtools/shared/DevToolsUtils.js :: onResponse :: line 567"  data: no]
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:567:34
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 567, column: 0
console.error: ({})
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 567: NS_BASE_STREAM_CLOSED: Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, 1650533198883	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "51998" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileMIzZqd"
1650533199522	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileMIzZqd\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:51998/devtools/browser/918bb5d5-a65e-4f4c-aace-89353a574054
1650533202122	Marionette	INFO	Listening on port 52003
1650533202652	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
JavaScript error: resource://gre/modules/LoginManagerParent.jsm, line 136: TypeError: gRecipeManager is null
JavaScript warning: https://gen-bizbd.com/web/content/53594-92c9dad/web.assets_backend.js, line 5051: unreachable code after return statement
SourceActor threw an exception: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:556:16
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 556, column: 16
console.error: (new Error("Failed to fetch https://gen-bizbd.com/web. Code 2152924148.", "resource://devtools/shared/DevToolsUtils.js", 556))
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 556: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
SourceActor threw an exception: [Exception... "Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]"  nsresult: "0x80470002 (NS_BASE_STREAM_CLOSED)"  location: "JS frame :: resource://devtools/shared/DevToolsUtils.js :: onResponse :: line 567"  data: no]
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:567:34
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 567, column: 0
console.error: ({})
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 567: NS_BASE_STREAM_CLOSED: Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, 1650533480638	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "54441" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileF9knfZ"
1650533481213	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileF9knfZ\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:54441/devtools/browser/376b13b9-3b27-47b1-8daf-b51d6684e3a7
1650533484038	Marionette	INFO	Listening on port 54446
1650533484362	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
JavaScript error: resource://gre/modules/LoginManagerParent.jsm, line 136: TypeError: gRecipeManager is null
JavaScript warning: https://gen-bizbd.com/web/content/53594-92c9dad/web.assets_backend.js, line 5051: unreachable code after return statement
SourceActor threw an exception: [Exception... "Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]"  nsresult: "0x80470002 (NS_BASE_STREAM_CLOSED)"  location: "JS frame :: resource://devtools/shared/DevToolsUtils.js :: onResponse :: line 567"  data: no]
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:567:34
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 567, column: 0
console.error: ({})
SourceActor threw an exception: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:556:16
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 556, column: 16
console.error: (new Error("Failed to fetch https://gen-bizbd.com/web. Code 2152924148.", "resource://devtools/shared/DevToolsUtils.js", 556))
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 567: NS_BASE_STREAM_CLOSED: Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 556: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, 1650533869287	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "49645" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileWeGVkk"
1650533869994	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileWeGVkk\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:49645/devtools/browser/354c27b7-a4a8-463e-811d-f617cac59b82
1650533874126	Marionette	INFO	Listening on port 49650
1650533874186	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
JavaScript error: resource://gre/modules/LoginManagerParent.jsm, line 136: TypeError: gRecipeManager is null
JavaScript warning: https://gen-bizbd.com/web/content/53594-92c9dad/web.assets_backend.js, line 5051: unreachable code after return statement
SourceActor threw an exception: [Exception... "Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]"  nsresult: "0x80470002 (NS_BASE_STREAM_CLOSED)"  location: "JS frame :: resource://devtools/shared/DevToolsUtils.js :: onResponse :: line 567"  data: no]
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:567:34
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 567, column: 0
console.error: ({})
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 567: NS_BASE_STREAM_CLOSED: Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]
SourceActor threw an exception: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:556:16
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 556, column: 16
console.error: (new Error("Failed to fetch https://gen-bizbd.com/web. Code 2152924148.", "resource://devtools/shared/DevToolsUtils.js", 556))
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 556: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, 1650534121071	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "50999" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofilek2umrB"
1650534121640	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofilek2umrB\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:50999/devtools/browser/12724d33-c8c9-450b-83c7-4b43f4ad44f6
1650534124497	Marionette	INFO	Listening on port 51004
1650534124826	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
JavaScript error: resource://gre/modules/LoginManagerParent.jsm, line 136: TypeError: gRecipeManager is null
JavaScript warning: https://gen-bizbd.com/web/content/53594-92c9dad/web.assets_backend.js, line 5051: unreachable code after return statement
SourceActor threw an exception: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:556:16
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 556, column: 16
console.error: (new Error("Failed to fetch https://gen-bizbd.com/web. Code 2152924148.", "resource://devtools/shared/DevToolsUtils.js", 556))
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 556: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
SourceActor threw an exception: [Exception... "Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]"  nsresult: "0x80470002 (NS_BASE_STREAM_CLOSED)"  location: "JS frame :: resource://devtools/shared/DevToolsUtils.js :: onResponse :: line 567"  data: no]
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:567:34
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 567, column: 0
console.error: ({})
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 567: NS_BASE_STREAM_CLOSED: Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, 1650534387135	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "51412" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileoxXMzE"
1650534387678	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileoxXMzE\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:51412/devtools/browser/f2023031-90c8-493f-8a15-0edb6787a787
1650534390211	Marionette	INFO	Listening on port 51417
1650534390407	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
JavaScript error: resource://gre/modules/LoginManagerParent.jsm, line 136: TypeError: gRecipeManager is null
JavaScript warning: https://gen-bizbd.com/web/content/53594-92c9dad/web.assets_backend.js, line 5051: unreachable code after return statement
SourceActor threw an exception: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:556:16
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 556, column: 16
console.error: (new Error("Failed to fetch https://gen-bizbd.com/web. Code 2152924148.", "resource://devtools/shared/DevToolsUtils.js", 556))
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 556: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
SourceActor threw an exception: [Exception... "Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]"  nsresult: "0x80470002 (NS_BASE_STREAM_CLOSED)"  location: "JS frame :: resource://devtools/shared/DevToolsUtils.js :: onResponse :: line 567"  data: no]
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:567:34
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 567, column: 0
console.error: ({})
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 567: NS_BASE_STREAM_CLOSED: Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, 1650534604855	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "52593" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofile1Ou0Ed"
1650534605478	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofile1Ou0Ed\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:52593/devtools/browser/c42a2828-59dc-473d-9874-2dc4ff3a059d
1650534608446	Marionette	INFO	Listening on port 52598
1650534608634	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
JavaScript error: resource://gre/modules/LoginManagerParent.jsm, line 136: TypeError: gRecipeManager is null
JavaScript warning: https://gen-bizbd.com/web/content/53594-92c9dad/web.assets_backend.js, line 5051: unreachable code after return statement
SourceActor threw an exception: [Exception... "Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]"  nsresult: "0x80470002 (NS_BASE_STREAM_CLOSED)"  location: "JS frame :: resource://devtools/shared/DevToolsUtils.js :: onResponse :: line 567"  data: no]
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:567:34
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 567, column: 0
console.error: ({})
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 567: NS_BASE_STREAM_CLOSED: Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]
SourceActor threw an exception: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:556:16
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 556, column: 16
console.error: (new Error("Failed to fetch https://gen-bizbd.com/web. Code 2152924148.", "resource://devtools/shared/DevToolsUtils.js", 556))
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 556: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
JavaScript error: , line 0: NotFoundError: No such JSWindowActor 'DevToolsFrame'
1650535217833	Marionette	INFO	Stopped listening on port 52598
console.warn: TopSitesFeed: Failed to fetch data from Contile server: NetworkError when attempting to fetch resource.

###!!! [Child][PContentChild] Error: RunMessage(msgname=PHttpChannel::Msg_DeleteSelf) Channel closing: too late to send/recv, messages will be lost

1650535222145	geckodriver	INFO	Listening on 127.0.0.1:58715
1650535225217	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "58716" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileZvkBw5"
1650535225764	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileZvkBw5\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:58716/devtools/browser/62f33b47-94b5-48aa-a87a-0d3e0d6e6613
1650535228345	Marionette	INFO	Listening on port 58721
1650535228442	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
JavaScript error: resource://gre/modules/LoginManagerParent.jsm, line 136: TypeError: gRecipeManager is null
JavaScript warning: https://gen-bizbd.com/web/content/53594-92c9dad/web.assets_backend.js, line 5051: unreachable code after return statement
SourceActor threw an exception: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:556:16
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 556, column: 16
console.error: (new Error("Failed to fetch https://gen-bizbd.com/web. Code 2152924148.", "resource://devtools/shared/DevToolsUtils.js", 556))
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 556: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
SourceActor threw an exception: [Exception... "Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]"  nsresult: "0x80470002 (NS_BASE_STREAM_CLOSED)"  location: "JS frame :: resource://devtools/shared/DevToolsUtils.js :: onResponse :: line 567"  data: no]
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:567:34
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 567, column: 0
console.error: ({})
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 567: NS_BASE_STREAM_CLOSED: Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, 1650535667803	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "55419" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofilestWnTZ"
1650535668336	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofilestWnTZ\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:55419/devtools/browser/d516e502-e2f6-4c84-bef9-2c43ee55d4d0
1650535670813	Marionette	INFO	Listening on port 55424
1650535671027	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
JavaScript error: resource://gre/modules/LoginManagerParent.jsm, line 136: TypeError: gRecipeManager is null
JavaScript warning: https://gen-bizbd.com/web/content/53594-92c9dad/web.assets_backend.js, line 5051: unreachable code after return statement
1650536111241	Marionette	INFO	Stopped listening on port 55421650536111966	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "63888" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofilerx8TGr"
1650536112629	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofilerx8TGr\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:63888/devtools/browser/4f1a7e82-80a3-4fcc-b20f-fa852705b330
1650536115279	Marionette	INFO	Listening on port 63894
1650536115733	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
JavaScript error: resource://gre/modules/LoginManagerParent.jsm, line 136: TypeError: gRecipeManager is null
JavaScript warning: https://gen-bizbd.com/web/content/53594-92c9dad/web.assets_backend.js, line 5051: unreachable code after return statement
1650536137748	Marionette	WARN	TimedPromise timed out after 500 ms: stacktrace:
TimedPromise/<@chrome://remote/content/marionette/sync.js:235:19
TimedPromise@chrome://remote/content/marionette/sync.js:220:10
interaction.flushEventLoop@chrome://remote/content/marionette/interaction.js:431:10
webdriverClickElement@chrome://remote/content/marionette/interaction.js:179:31
1650536164333	Marionette	INFO	Stopped listening on port 63891650536166181	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "63946" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileHaMAzj"
1650536166951	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileHaMAzj\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:63946/devtools/browser/0ee9defe-c31d-47af-9b58-233431cf529d
1650536170066	Marionette	INFO	Listening on port 63952
1650536170651	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
JavaScript error: resource://gre/modules/LoginManagerParent.jsm, line 136: TypeError: gRecipeManager is null
JavaScript warning: https://gen-bizbd.com/web/content/53594-92c9dad/web.assets_backend.js, line 5051: unreachable code after return statement
1650536377131	Marionette	INFO	Stopped listening on port 63951650536378948	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "61482" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofile8lNbvN"
1650536379472	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofile8lNbvN\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:61482/devtools/browser/00a6b63e-48e0-4daa-81b3-9570e00a88ba
1650536382558	Marionette	INFO	Listening on port 61487
1650536382679	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
1650536433909	Marionette	INFO	Stopped listening on port 61481650536435860	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "61535" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofiletThn9f"
1650536436409	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofiletThn9f\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:61535/devtools/browser/92a7870b-fa26-4060-af45-e9d24f606af9
1650536438913	Marionette	INFO	Listening on port 61541
1650536439108	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
JavaScript error: , line 0: NS_ERROR_NOT_AVAILABLE
1650537946014	Marionette	INFO	Stopped listening on port 61541
console.warn: TopSitesFeed: Failed to fetch data from Contile server: NetworkError when attempting to fetch resource.
1650537978530	geckodriver	INFO	Listening on 127.0.0.1:60603
1650537981581	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "60604" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileg1hUGS"
1650537982210	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileg1hUGS\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:60604/devtools/browser/9978337f-059e-4605-9bf8-80c2dc39bbbe
1650537984727	Marionette	INFO	Listening on port 60609
1650537984835	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
JavaScript error: resource://gre/modules/LoginManagerParent.jsm, line 136: TypeError: gRecipeManager is null
JavaScript warning: https://gen-bizbd.com/web/content/53594-92c9dad/web.assets_backend.js, line 5051: unreachable code after return statement
1650538076173	Marionette	INFO	Stopped listening on port 60601650538077859	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "58240" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofilel5iz1b"
1650538078436	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofilel5iz1b\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:58240/devtools/browser/f75e84ca-e7ea-42a3-9cdc-b51c91515fb5
1650538081163	Marionette	INFO	Listening on port 58246
1650538081613	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
JavaScript error: resource://gre/modules/LoginManagerParent.jsm, line 136: TypeError: gRecipeManager is null
JavaScript warning: https://gen-bizbd.com/web/content/53594-92c9dad/web.assets_backend.js, line 5051: unreachable code after return statement
SourceActor threw an exception: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:556:16
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 556, column: 16
console.error: (new Error("Failed to fetch https://gen-bizbd.com/web. Code 2152924148.", "resource://devtools/shared/DevToolsUtils.js", 556))
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 556: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
SourceActor threw an exception: [Exception... "Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]"  nsresult: "0x80470002 (NS_BASE_STREAM_CLOSED)"  location: "JS frame :: resource://devtools/shared/DevToolsUtils.js :: onResponse :: line 567"  data: no]
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:567:34
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 567, column: 0
console.error: ({})
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 567: NS_BASE_STREAM_CLOSED: Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]
console.error: (new TypeError("parent is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: parent is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

JavaScript error: resource://gre/modules/AsyncShutdown.jsm, 1650538245976	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "54499" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileKTOdjy"
1650538246590	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileKTOdjy\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:54499/devtools/browser/0c18bbb4-745b-4e76-92be-34a689fb84fd
1650538249054	Marionette	INFO	Listening on port 54504
1650538249196	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
JavaScript error: resource://gre/modules/LoginManagerParent.jsm, line 136: TypeError: gRecipeManager is null
JavaScript warning: https://gen-bizbd.com/web/content/53594-92c9dad/web.assets_backend.js, line 5051: unreachable code after return statement
SourceActor threw an exception: [Exception... "Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]"  nsresult: "0x80470002 (NS_BASE_STREAM_CLOSED)"  location: "JS frame :: resource://devtools/shared/DevToolsUtils.js :: onResponse :: line 567"  data: no]
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:567:34
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 567, column: 0
console.error: ({})
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 567: NS_BASE_STREAM_CLOSED: Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]
SourceActor threw an exception: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:556:16
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 556, column: 16
console.error: (new Error("Failed to fetch https://gen-bizbd.com/web. Code 2152924148.", "resource://devtools/shared/DevToolsUtils.js", 556))
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 556: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
console.error: (new TypeError("parent is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: parent is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

JavaScript error: resource://gre/modules/AsyncShutdown.jsm, 1650538354406	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "54565" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileZLQf3k"
1650538354981	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileZLQf3k\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:54565/devtools/browser/b18d2ec0-8f93-43f1-94b3-5673220e34fb
1650538357463	Marionette	INFO	Listening on port 54570
1650538357628	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
JavaScript error: resource://gre/modules/LoginManagerParent.jsm, line 136: TypeError: gRecipeManager is null
JavaScript warning: https://gen-bizbd.com/web/content/53594-92c9dad/web.assets_backend.js, line 5051: unreachable code after return statement
1650538538241	Marionette	INFO	Stopped listening on port 54570
console.warn: TopSitesFeed: Failed to fetch data from Contile server: NetworkError when attempting to fetch resource.
1650538884498	geckodriver	INFO	Listening on 127.0.0.1:64763
1650538887571	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "64764" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileeRwHVT"
1650538888184	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileeRwHVT\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:64764/devtools/browser/096e6149-6916-406c-9c8a-0ab33081736e
1650538890837	Marionette	INFO	Listening on port 64769
1650538891361	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
1650538902483	Marionette	INFO	Stopped listening on port 64769
console.warn: TopSitesFeed: Failed to fetch data from Contile server: NetworkError when attempting to fetch resource.
1650538909679	geckodriver	INFO	Listening on 127.0.0.1:64823
1650538912736	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "64824" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileL0lXhV"
1650538913311	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileL0lXhV\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:64824/devtools/browser/37c9fcd4-0a69-4e08-b4e1-7be0cfd15d65
1650538915853	Marionette	INFO	Listening on port 64829
1650538915978	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, 1650539030511	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "52068" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofilewDa9wZ"
1650539031070	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofilewDa9wZ\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:52068/devtools/browser/6ad009b3-375a-443e-9dbb-bbd134e6fb0a
1650539033546	Marionette	INFO	Listening on port 52073
1650539033744	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
1650541414156	Marionette	INFO	Stopped listening on port 52073
console.warn: TopSitesFeed: Failed to fetch data from Contile server: NetworkError when attempting to fetch resource.
1650778112071	geckodriver	INFO	Listening on 127.0.0.1:55756
1650778115305	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "55757" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofilefSC4Tu"
1650778116666	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofilefSC4Tu\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:55757/devtools/browser/0a1b8e74-8a8c-4220-9dbd-457c37b6561a
1650778120568	Marionette	INFO	Listening on port 55764
1650778120764	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
JavaScript error: resource://gre/modules/LoginManagerParent.jsm, line 136: TypeError: gRecipeManager is null
JavaScript error: , line 0: NS_ERROR_NOT_AVAILABLE
1650782078362	Marionette	INFO	Stopped listening on port 55764
console.warn: TopSitesFeed: Failed to fetch data from Contile server: NetworkError when attempting to fetch resource.
1650783246657	geckodriver	INFO	Listening on 127.0.0.1:58659
1650783249720	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "58660" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileSLqbwv"
1650783250453	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileSLqbwv\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:58660/devtools/browser/db33e84b-7a9c-4611-a98f-c85498a766fc
1650783253795	Marionette	INFO	Listening on port 58666
1650783253960	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
JavaScript error: resource://gre/modules/LoginManagerParent.jsm, line 136: TypeError: gRecipeManager is null
JavaScript warning: https://gen-bizbd.com/web/content/53594-92c9dad/web.assets_backend.js, line 5051: unreachable code after return statement
SourceActor threw an exception: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:556:16
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 556, column: 16
console.error: (new Error("Failed to fetch https://gen-bizbd.com/web. Code 2152924148.", "resource://devtools/shared/DevToolsUtils.js", 556))
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 556: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
SourceActor threw an exception: [Exception... "Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]"  nsresult: "0x80470002 (NS_BASE_STREAM_CLOSED)"  location: "JS frame :: resource://devtools/shared/DevToolsUtils.js :: onResponse :: line 567"  data: no]
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:567:34
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 567, column: 0
console.error: ({})
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 567: NS_BASE_STREAM_CLOSED: Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, 1650783335791	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "59385" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileF6e7OB"
1650783336464	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileF6e7OB\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:59385/devtools/browser/854745c6-2d52-4415-99a9-9d66af486267
1650783338972	Marionette	INFO	Listening on port 59390
1650783339052	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
JavaScript error: resource://gre/modules/LoginManagerParent.jsm, line 136: TypeError: gRecipeManager is null
JavaScript warning: https://gen-bizbd.com/web/content/53594-92c9dad/web.assets_backend.js, line 5051: unreachable code after return statement
SourceActor threw an exception: [Exception... "Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]"  nsresult: "0x80470002 (NS_BASE_STREAM_CLOSED)"  location: "JS frame :: resource://devtools/shared/DevToolsUtils.js :: onResponse :: line 567"  data: no]
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:567:34
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 567, column: 0
console.error: ({})
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 567: NS_BASE_STREAM_CLOSED: Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]
SourceActor threw an exception: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:556:16
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 556, column: 16
console.error: (new Error("Failed to fetch https://gen-bizbd.com/web. Code 2152924148.", "resource://devtools/shared/DevToolsUtils.js", 556))
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 556: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, 1650783439597	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "64121" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileLaWHs7"
1650783440206	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileLaWHs7\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:64121/devtools/browser/976c8775-09d3-4217-8745-15e70c1a462a
1650783442787	Marionette	INFO	Listening on port 64126
1650783442861	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
JavaScript error: resource://gre/modules/LoginManagerParent.jsm, line 136: TypeError: gRecipeManager is null
JavaScript warning: https://gen-bizbd.com/web/content/53594-92c9dad/web.assets_backend.js, line 5051: unreachable code after return statement
SourceActor threw an exception: [Exception... "Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]"  nsresult: "0x80470002 (NS_BASE_STREAM_CLOSED)"  location: "JS frame :: resource://devtools/shared/DevToolsUtils.js :: onResponse :: line 567"  data: no]
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:567:34
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 567, column: 0
console.error: ({})
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 567: NS_BASE_STREAM_CLOSED: Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]
SourceActor threw an exception: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:556:16
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 556, column: 16
console.error: (new Error("Failed to fetch https://gen-bizbd.com/web. Code 2152924148.", "resource://devtools/shared/DevToolsUtils.js", 556))
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 556: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
console.error: (new TypeError("parent is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: parent is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

console.error: (new TypeError("parent is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: parent is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

console.error: (new TypeError("parent is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: parent is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

console.error: "Error while calling actor 'pagestyle's method 'getLayout'" "node is null"
console.error: (new TypeError("node is null", "resource://devtools/server/actors/page-style.js", 1001))
console.error: (new Error("Protocol error (TypeError): node is null from: server0.conn0.windowGlobal4294967299/pagestyle26 (resource://devtools/server/actors/page-style.js:1001:5)", "resource://devtools/shared/protocol/Front.js", 365))
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, 1650783679723	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "53226" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileZEULpi"
1650783680366	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileZEULpi\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:53226/devtools/browser/6da50ffc-234a-4c22-994b-a5289f567f50
1650783683453	Marionette	INFO	Listening on port 53231
1650783683517	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
JavaScript error: resource://gre/modules/LoginManagerParent.jsm, line 136: TypeError: gRecipeManager is null
JavaScript warning: https://gen-bizbd.com/web/content/53594-92c9dad/web.assets_backend.js, line 5051: unreachable code after return statement
JavaScript error: , line 0: NS_ERROR_NOT_AVAILABLE
console.error: (new TypeError("parent is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: parent is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

console.error: (new TypeError("container.node.targetFront is null", "resource://devtools/client/inspector/markup/markup.js", 2320))
console.error: (new TypeError("parent is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: parent is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

console.error: (new TypeError("parent is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: parent is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

console.error: (new TypeError("parent is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: parent is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

JavaScript error: resource://gre/modules/AsyncShutdown.jsm, 1650786901265	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "53818" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileF4qaw9"
1650786902128	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileF4qaw9\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:53818/devtools/browser/9fc38eed-d6d0-4b71-a645-df4f02f96a5c
1650786905672	Marionette	INFO	Listening on port 53823
1650786906170	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
JavaScript error: resource://gre/modules/LoginManagerParent.jsm, line 136: TypeError: gRecipeManager is null
JavaScript warning: https://gen-bizbd.com/web/content/53594-92c9dad/web.assets_backend.js, line 5051: unreachable code after return statement
SourceActor threw an exception: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:556:16
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 556, column: 16
console.error: (new Error("Failed to fetch https://gen-bizbd.com/web. Code 2152924148.", "resource://devtools/shared/DevToolsUtils.js", 556))
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 556: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
SourceActor threw an exception: [Exception... "Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]"  nsresult: "0x80470002 (NS_BASE_STREAM_CLOSED)"  location: "JS frame :: resource://devtools/shared/DevToolsUtils.js :: onResponse :: line 567"  data: no]
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:567:34
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 567, column: 0
console.error: ({})
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 567: NS_BASE_STREAM_CLOSED: Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, 1650787030864	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "56177" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofile2CPG8c"
1650787031612	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofile2CPG8c\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:56177/devtools/browser/f6c4c245-b9e5-47a8-88f8-8efbda7272c4
1650787034306	Marionette	INFO	Listening on port 56182
1650787034647	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
JavaScript error: resource://gre/modules/LoginManagerParent.jsm, line 136: TypeError: gRecipeManager is null
JavaScript warning: https://gen-bizbd.com/web/content/53594-92c9dad/web.assets_backend.js, line 5051: unreachable code after return statement
1650787157466	Marionette	INFO	Stopped listening on port 56181650787159111	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "62782" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileQWb5jx"
1650787159728	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileQWb5jx\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:62782/devtools/browser/91ebb7cc-6653-4bdd-9169-c5492366282a
1650787162196	Marionette	INFO	Listening on port 62787
1650787162336	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
JavaScript error: resource://gre/modules/LoginManagerParent.jsm, line 136: TypeError: gRecipeManager is null
JavaScript warning: https://gen-bizbd.com/web/content/53594-92c9dad/web.assets_backend.js, line 5051: unreachable code after return statement
SourceActor threw an exception: [Exception... "Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]"  nsresult: "0x80470002 (NS_BASE_STREAM_CLOSED)"  location: "JS frame :: resource://devtools/shared/DevToolsUtils.js :: onResponse :: line 567"  data: no]
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:567:34
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 567, column: 0
console.error: ({})
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 567: NS_BASE_STREAM_CLOSED: Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]
SourceActor threw an exception: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:556:16
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 556, column: 16
console.error: (new Error("Failed to fetch https://gen-bizbd.com/web. Code 2152924148.", "resource://devtools/shared/DevToolsUtils.js", 556))
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 556: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, 1650787259062	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "59420" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileP2m8FG"
1650787259737	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileP2m8FG\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:59420/devtools/browser/26544d7c-06f4-4594-bb93-ac7a6249ce71
1650787262730	Marionette	INFO	Listening on port 59425
1650787262777	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
JavaScript error: resource://gre/modules/LoginManagerParent.jsm, line 136: TypeError: gRecipeManager is null
JavaScript warning: https://gen-bizbd.com/web/content/53594-92c9dad/web.assets_backend.js, line 5051: unreachable code after return statement
SourceActor threw an exception: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:556:16
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 556, column: 16
console.error: (new Error("Failed to fetch https://gen-bizbd.com/web. Code 2152924148.", "resource://devtools/shared/DevToolsUtils.js", 556))
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 556: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
SourceActor threw an exception: [Exception... "Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]"  nsresult: "0x80470002 (NS_BASE_STREAM_CLOSED)"  location: "JS frame :: resource://devtools/shared/DevToolsUtils.js :: onResponse :: line 567"  data: no]
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:567:34
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 567, column: 0
console.error: ({})
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 567: NS_BASE_STREAM_CLOSED: Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]
JavaScript error: , line 0: NS_ERROR_NOT_AVAILABLE
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 575: NotFoundError: No such JSWindowActor 'DevToolsFrame'
1650789389337	Marionette	INFO	Stopped listening on port 59425
1650789392482	geckodriver	INFO	Listening on 127.0.0.1:64976
1650789395519	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "64977" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileVoWqTX"
1650789396140	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileVoWqTX\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:64977/devtools/browser/620089ca-8c56-4159-966f-f03d86be6b7b
1650789399024	Marionette	INFO	Listening on port 64983
1650789399247	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
JavaScript error: resource://gre/modules/LoginManagerParent.jsm, line 136: TypeError: gRecipeManager is null
JavaScript warning: https://gen-bizbd.com/web/content/53594-92c9dad/web.assets_backend.js, line 5051: unreachable code after return statement
1650789649681	Marionette	INFO	Stopped listening on port 64983
console.warn: TopSitesFeed: Failed to fetch data from Contile server: NetworkError when attempting to fetch resource.

###!!! [Child][PContentChild] Error: RunMessage(msgname=PHttpChannel::Msg_DeleteSelf) Channel closing: too late to send/recv, messages will be lost

1650789654319	geckodriver	INFO	Listening on 127.0.0.1:61548
1650789657374	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "61549" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileUSd0Z4"
1650789657952	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileUSd0Z4\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:61549/devtools/browser/4903e5ad-8ecf-4766-a8e0-f6891b4de1bf
1650789660920	Marionette	INFO	Listening on port 61554
1650789661103	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
JavaScript error: resource://gre/modules/LoginManagerParent.jsm, line 136: TypeError: gRecipeManager is null
JavaScript warning: https://gen-bizbd.com/web/content/53594-92c9dad/web.assets_backend.js, line 5051: unreachable code after return statement
SourceActor threw an exception: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:556:16
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 556, column: 16
console.error: (new Error("Failed to fetch https://gen-bizbd.com/web. Code 2152924148.", "resource://devtools/shared/DevToolsUtils.js", 556))
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 556: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
SourceActor threw an exception: [Exception... "Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]"  nsresult: "0x80470002 (NS_BASE_STREAM_CLOSED)"  location: "JS frame :: resource://devtools/shared/DevToolsUtils.js :: onResponse :: line 567"  data: no]
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:567:34
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 567, column: 0
console.error: ({})
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 567: NS_BASE_STREAM_CLOSED: Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]
console.error: (new TypeError("parent is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: parent is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

console.error: (new TypeError("parent is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: parent is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

console.error: "Error while calling actor 'pagestyle's method 'getLayout'" "node is null"
console.error: (new TypeError("node is null", "resource://devtools/server/actors/page-style.js", 1001))
console.error: (new Error("Protocol error (TypeError): node is null from: server0.conn0.windowGlobal4294967299/pagestyle26 (resource://devtools/server/actors/page-style.js:1001:5)", "resource://devtools/shared/protocol/Front.js", 365))
JavaScript error: , line 0: NS_ERROR_NOT_AVAILABLE
console.error: (new TypeError("parent is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: parent is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

console.error: (new TypeError("parent is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: parent is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

JavaScript error: resource://gre/modules/AsyncShutdown.jsm, 1650792206787	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "64573" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileCJk4pW"
1650792207490	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileCJk4pW\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:64573/devtools/browser/e8ec4b90-6198-438d-b2ec-39c9b42efbf0
1650792210052	Marionette	INFO	Listening on port 64579
1650792210585	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
JavaScript error: resource://gre/modules/LoginManagerParent.jsm, line 136: TypeError: gRecipeManager is null
JavaScript warning: https://gen-bizbd.com/web/content/53594-92c9dad/web.assets_backend.js, line 5051: unreachable code after return statement
SourceActor threw an exception: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:556:16
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 556, column: 16
console.error: (new Error("Failed to fetch https://gen-bizbd.com/web. Code 2152924148.", "resource://devtools/shared/DevToolsUtils.js", 556))
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 556: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
SourceActor threw an exception: [Exception... "Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]"  nsresult: "0x80470002 (NS_BASE_STREAM_CLOSED)"  location: "JS frame :: resource://devtools/shared/DevToolsUtils.js :: onResponse :: line 567"  data: no]
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:567:34
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 567, column: 0
console.error: ({})
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 567: NS_BASE_STREAM_CLOSED: Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, 1650792385610	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "52821" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofile7TLaMR"
1650792386146	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofile7TLaMR\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:52821/devtools/browser/cc3d907a-9106-41fa-94e7-d4fd319cb0ce
1650792388651	Marionette	INFO	Listening on port 52826
1650792388841	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
JavaScript error: resource://gre/modules/LoginManagerParent.jsm, line 136: TypeError: gRecipeManager is null
JavaScript warning: https://gen-bizbd.com/web/content/53594-92c9dad/web.assets_backend.js, line 5051: unreachable code after return statement
SourceActor threw an exception: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:556:16
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 556, column: 16
console.error: (new Error("Failed to fetch https://gen-bizbd.com/web. Code 2152924148.", "resource://devtools/shared/DevToolsUtils.js", 556))
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 556: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
SourceActor threw an exception: [Exception... "Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]"  nsresult: "0x80470002 (NS_BASE_STREAM_CLOSED)"  location: "JS frame :: resource://devtools/shared/DevToolsUtils.js :: onResponse :: line 567"  data: no]
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:567:34
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 567, column: 0
console.error: ({})
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 567: NS_BASE_STREAM_CLOSED: Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]
console.error: "Error while calling actor 'pagestyle's method 'getLayout'" "node is null"
console.error: (new TypeError("node is null", "resource://devtools/server/actors/page-style.js", 1001))
console.error: (new TypeError("parent is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: parent is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

console.error: (new Error("Protocol error (TypeError): node is null from: server0.conn0.windowGlobal4294967299/pagestyle26 (resource://devtools/server/actors/page-style.js:1001:5)", "resource://devtools/shared/protocol/Front.js", 365))
console.error: "Error while calling actor 'pagestyle's method 'getLayout'" "node is null"
console.error: (new TypeError("node is null", "resource://devtools/server/actors/page-style.js", 1001))
console.error: (new TypeError("parent is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: parent is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

console.error: (new Error("Protocol error (TypeError): node is null from: server0.conn0.windowGlobal4294967299/pagestyle26 (resource://devtools/server/actors/page-style.js:1001:5)", "resource://devtools/shared/protocol/Front.js", 365))
console.error: "Error while calling actor 'pagestyle's method 'getLayout'" "node is null"
console.error: (new TypeError("node is null", "resource://devtools/server/actors/page-style.js", 1001))
console.error: (new TypeError("parent is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: parent is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

console.error: (new Error("Protocol error (TypeError): node is null from: server0.conn0.windowGlobal4294967299/pagestyle26 (resource://devtools/server/actors/page-style.js:1001:5)", "resource://devtools/shared/protocol/Front.js", 365))
JavaScript error: , line 0: NotFoundError: No such JSWindowActor 'DevToolsFrame'
SourceActor threw an exception: [Exception... "Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]"  nsresult: "0x80470002 (NS_BASE_STREAM_CLOSED)"  location: "JS frame :: resource://devtools/shared/DevToolsUtils.js :: onResponse :: line 567"  data: no]
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:567:34
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 567, column: 0
console.error: ({})
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 567: NS_BASE_STREAM_CLOSED: Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]
SourceActor threw an exception: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:556:16
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 556, column: 16
console.error: (new Error("Failed to fetch https://gen-bizbd.com/web. Code 2152924148.", "resource://devtools/shared/DevToolsUtils.js", 556))
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 556: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
console.error: "Error while calling actor 'pagestyle's method 'getLayout'" "node is null"
console.error: (new TypeError("node is null", "resource://devtools/server/actors/page-style.js", 1001))
console.error: (new TypeError("parent is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: parent is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

console.error: (new TypeError("container.node.targetFront is null", "resource://devtools/client/inspector/markup/markup.js", 2320))
console.error: (new Error("Protocol error (TypeError): node is null from: server0.conn1.windowGlobal4294967299/pagestyle26 (resource://devtools/server/actors/page-style.js:1001:5)", "resource://devtools/shared/protocol/Front.js", 365))
console.error: "Error while calling actor 'pagestyle's method 'getApplied'" "node is null"
console.error: (new TypeError("node is null", "resource://devtools/server/actors/page-style.js", 570))
console.error: (new TypeError("parent is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: parent is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

console.error: (new Error("Protocol error (TypeError): node is null from: server0.conn1.windowGlobal4294967299/pagestyle26 (resource://devtools/server/actors/page-style.js:570:5)", "resource://devtools/shared/protocol/Front.js", 365))
JavaScript error: , line 0: NS_ERROR_NOT_AVAILABLE
console.error: (new TypeError("parent is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: parent is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

console.error: (new TypeError("parent is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: parent is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

console.error: (new TypeError("parent is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: parent is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

JavaScript error: resource://gre/modules/AsyncShutdown.jsm, 1650793942318	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "58364" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileBgHGGl"
1650793942910	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileBgHGGl\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:58364/devtools/browser/a458ab3e-0454-437c-8662-f2bcc0149635
1650793945558	Marionette	INFO	Listening on port 58369
1650793946068	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
JavaScript error: resource://gre/modules/LoginManagerParent.jsm, line 136: TypeError: gRecipeManager is null
JavaScript warning: https://gen-bizbd.com/web/content/53594-92c9dad/web.assets_backend.js, line 5051: unreachable code after return statement
1650794300409	Marionette	INFO	Stopped listening on port 58369

###!!! [Parent][PContentParent] Error: Send(msgname=PContent::Reply_DiscardBrowsingContext) Closed channel: cannot send/recv


###!!! [Child][PContentChild] Error: RunMessage(msgname=PContent::Msg_DiscardBrowsingContext) Channel closing: too late to send/recv, messages will be lost


###!!! [Child][PContentChild] Error: RunMessage(msgname=PContent::Reply_DiscardBrowsingContext) Channel closing: too late to send/recv, messages will be lost


###!!! [Child][PContentChild] Error: RunMessage(msgname=PHttpChannel::Msg_DeleteSelf) Channel closing: too late to send/recv, messages will be lost


###!!! [Parent][PContentParent] Error: Send(msgname=PContent::Msg_DestroyBrowsingContextGroup) Closed channel: cannot send/recv

1650794540083	geckodriver	INFO	Listening on 127.0.0.1:51988
1650794543172	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "51989" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileal0Gk5"
1650794543857	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileal0Gk5\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:51989/devtools/browser/cd2c46fb-b728-468d-b1a5-1ad4f681314a
1650794546582	Marionette	INFO	Listening on port 51994
1650794547022	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
JavaScript error: resource://gre/modules/LoginManagerParent.jsm, line 136: TypeError: gRecipeManager is null
JavaScript warning: https://gen-bizbd.com/web/content/53594-92c9dad/web.assets_backend.js, line 5051: unreachable code after return statement
JavaScript error: , line 0: NS_ERROR_NOT_AVAILABLE
JavaScript error: , line 0: NotFoundError: No such JSWindowActor 'DevToolsFrame'
console.error: (new TypeError("parent is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: parent is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

console.error: (new TypeError("nodeFront.walkerFront is null", "resource://devtools/client/inspector/markup/markup.js", 956))
TypeError: nodeFront.walkerFront is null: _onNewSelection@resource://devtools/client/inspector/markup/markup.js:956:7
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
setNodeFront@resource://devtools/client/framework/selection.js:206:10
onDetached@resource://devtools/client/inspector/inspector.js:1700:20
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
_onMutations@resource://devtools/client/framework/selection.js:104:12
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

console.error: (new Error("Can not send request 'getUniqueSelector' because front 'domnode' is already destroyed.", "resource://devtools/shared/protocol/Front/FrontClassWithSpec.js", 28))
console.error: (new TypeError("parent is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: parent is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

console.error: (new TypeError("parent is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: parent is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

console.error: (new TypeError("parent is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: parent is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

console.error: (new TypeError("parent is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: parent is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

console.error: (new TypeError("parent is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: parent is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

console.error: (new TypeError("parent is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: parent is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

JavaScript error: resource://gre/modules/AsyncShutdown.jsm, 1650798603789	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "62975" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofile5rGF5s"
1650798604532	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofile5rGF5s\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:62975/devtools/browser/02eff496-05a7-43d7-9ca5-4dc915e4dd56
1650798607309	Marionette	INFO	Listening on port 62983
1650798607644	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
JavaScript error: resource://gre/modules/LoginManagerParent.jsm, line 136: TypeError: gRecipeManager is null
JavaScript warning: https://gen-bizbd.com/web/content/53594-92c9dad/web.assets_backend.js, line 5051: unreachable code after return statement
SourceActor threw an exception: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:556:16
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 556, column: 16
console.error: (new Error("Failed to fetch https://gen-bizbd.com/web. Code 2152924148.", "resource://devtools/shared/DevToolsUtils.js", 556))
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 556: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
SourceActor threw an exception: [Exception... "Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]"  nsresult: "0x80470002 (NS_BASE_STREAM_CLOSED)"  location: "JS frame :: resource://devtools/shared/DevToolsUtils.js :: onResponse :: line 567"  data: no]
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:567:34
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 567, column: 0
console.error: ({})
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 567: NS_BASE_STREAM_CLOSED: Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]
console.error: (new TypeError("parent is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: parent is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

console.error: (new TypeError("nodeFront.walkerFront is null", "resource://devtools/client/inspector/markup/markup.js", 956))
TypeError: nodeFront.walkerFront is null: _onNewSelection@resource://devtools/client/inspector/markup/markup.js:956:7
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
setNodeFront@resource://devtools/client/framework/selection.js:206:10
onDetached@resource://devtools/client/inspector/inspector.js:1700:20
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
_onMutations@resource://devtools/client/framework/selection.js:104:12
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

console.error: (new Error("Can not send request 'getUniqueSelector' because front 'domnode' is already destroyed.", "resource://devtools/shared/protocol/Front/FrontClassWithSpec.js", 28))
console.error: (new TypeError("parent is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: parent is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

console.error: (new TypeError("parent is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: parent is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

console.error: (new TypeError("parent is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: parent is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

console.error: (new TypeError("parent is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: parent is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

console.error: (new TypeError("parent is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: parent is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

console.error: (new TypeError("parent is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: parent is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

console.error: (new TypeError("parent is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: parent is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

console.error: (new TypeError("container.node.targetFront is null", "resource://devtools/client/inspector/markup/markup.js", 2320))
console.error: (new TypeError("container.node.targetFront is null", "resource://devtools/client/inspector/markup/markup.js", 2320))
console.error: (new TypeError("nodeFront.walkerFront is null", "resource://devtools/client/inspector/markup/markup.js", 956))
TypeError: nodeFront.walkerFront is null: _onNewSelection@resource://devtools/client/inspector/markup/markup.js:956:7
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
setNodeFront@resource://devtools/client/framework/selection.js:206:10
onDetached@resource://devtools/client/inspector/inspector.js:1700:20
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
_onMutations@resource://devtools/client/framework/selection.js:104:12
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

console.error: (new Error("Can not send request 'getUniqueSelector' because front 'domnode' is already destroyed.", "resource://devtools/shared/protocol/Front/FrontClassWithSpec.js", 28))
console.error: (new TypeError("parent is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: parent is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

console.error: (new TypeError("parent is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: parent is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

console.error: (new TypeError("parent is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: parent is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

console.error: (new TypeError("parent is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: parent is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

console.error: (new TypeError("parent is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: parent is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

console.error: (new TypeError("parent is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: parent is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

console.error: (new TypeError("parent is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: parent is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

console.error: (new TypeError("parent is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: parent is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

console.error: (new TypeError("container.node.targetFront is null", "resource://devtools/client/inspector/markup/markup.js", 2320))
console.error: (new TypeError("container.node.targetFront is null", "resource://devtools/client/inspector/markup/markup.js", 2320))
console.warn: "Error while destroying front:" "inspector" (new Error("Connection closed, pending request to server0.conn0.windowGlobal4294967309/inspectorActor4, type getWalker failed\n\nRequest stack:\nrequest@resource://devtools/shared/protocol/Front.js:292:14\ngenerateRequestMethods/</frontProto[name]@resource://devtools/shared/protocol/Front/FrontClassWithSpec.js:46:19\n_getWalker@resource://devtools/client/fronts/inspector.js:90:30\ninitialize@resource://devtools/client/fronts/inspector.js:79:12\n", "resource://devtools/shared/protocol/Front.js", 106))
console.error: "Failed to start [root-node] legacy listener for target null" (new Error("Connection closed, pending request to server0.conn0.windowGlobal4294967309/inspectorActor4, type getWalker failed\n\nRequest stack:\nrequest@resource://devtools/shared/protocol/Front.js:292:14\ngenerateRequestMethods/</frontProto[name]@resource://devtools/shared/protocol/Front/FrontClassWithSpec.js:46:19\n_getWalker@resource://devtools/client/fronts/inspector.js:90:30\ninitialize@resource://devtools/client/fronts/inspector.js:79:12\n", "resource://devtools/shared/protocol/Front.js", 106))
JavaScript error: resource://devtools/shared/protocol/Front.js, line 106: Error: Connection closed, pending request to server0.conn0.windowGlobal4294967309/inspectorActor4, type getWalker failed

Request stack:
request@resource://devtools/shared/protocol/Front.js:292:14
generateRequestMethods/</frontProto[name]@resource://devtools/shared/protocol/Front/FrontClassWithSpec.js:46:19
_getWalker@resource://devtools/client/fronts/inspector.js:90:30
initialize@resource://devtools/client/fronts/inspector.js:79:12

JavaScript error: , line 0: NotFoundError: No such JSWindowActor 'DevToolsFrame'
1650799109527	Marionette	INFO	Stopped listening on port 62983
console.warn: TopSitesFeed: Failed to fetch data from Contile server: NetworkError when attempting to fetch resource.
!!! error running onStopped callback: TypeError: callback is not a function
1650799120695	geckodriver	INFO	Listening on 127.0.0.1:63190
1650799123774	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "63191" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofile1gpwNY"
1650799124308	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofile1gpwNY\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:63191/devtools/browser/c9b4f18c-3ddb-4c22-82a5-7a5ab7da0701
1650799126946	Marionette	INFO	Listening on port 65153
1650799126988	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
JavaScript error: resource://gre/modules/LoginManagerParent.jsm, line 136: TypeError: gRecipeManager is null
JavaScript warning: https://gen-bizbd.com/web/content/53594-92c9dad/web.assets_backend.js, line 5051: unreachable code after return statement
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, 1650799857066	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "60198" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileiK8HlD"
1650799857627	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileiK8HlD\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:60198/devtools/browser/95ae5b61-04dd-4bce-8d4d-e77e2c87be4b
1650799860090	Marionette	INFO	Listening on port 60203
1650799860294	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
JavaScript error: resource://gre/modules/LoginManagerParent.jsm, line 136: TypeError: gRecipeManager is null
JavaScript warning: https://gen-bizbd.com/web/content/53594-92c9dad/web.assets_backend.js, line 5051: unreachable code after return statement
SourceActor threw an exception: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:556:16
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 556, column: 16
console.error: (new Error("Failed to fetch https://gen-bizbd.com/web. Code 2152924148.", "resource://devtools/shared/DevToolsUtils.js", 556))
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 556: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
SourceActor threw an exception: [Exception... "Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]"  nsresult: "0x80470002 (NS_BASE_STREAM_CLOSED)"  location: "JS frame :: resource://devtools/shared/DevToolsUtils.js :: onResponse :: line 567"  data: no]
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:567:34
onStopRequest@resource://gre/modules/NetUtil.jsm:128:18
Line: 567, column: 0
console.error: ({})
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 567: NS_BASE_STREAM_CLOSED: Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]
console.error: (new TypeError("nodeFront.walkerFront is null", "resource://devtools/client/inspector/markup/markup.js", 956))
TypeError: nodeFront.walkerFront is null: _onNewSelection@resource://devtools/client/inspector/markup/markup.js:956:7
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
setNodeFront@resource://devtools/client/framework/selection.js:206:10
onDetached@resource://devtools/client/inspector/inspector.js:1700:20
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
_onMutations@resource://devtools/client/framework/selection.js:104:12
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

console.error: (new Error("Can not send request 'getUniqueSelector' because front 'domnode' is already destroyed.", "resource://devtools/shared/protocol/Front/FrontClassWithSpec.js", 28))
console.error: (new TypeError("parent is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: parent is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

console.error: (new TypeError("parent is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: parent is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

console.error: (new TypeError("parent is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: parent is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

console.error: (new TypeError("parent is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: parent is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

console.error: (new TypeError("parent is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: parent is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

console.error: (new TypeError("parent is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: parent is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

console.error: "Error while calling actor 'pagestyle's method 'getApplied'" "node is null"
console.error: (new TypeError("node is null", "resource://devtools/server/actors/page-style.js", 570))
console.error: (new TypeError("parent is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: parent is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

console.error: (new TypeError("container.node.targetFront is null", "resource://devtools/client/inspector/markup/markup.js", 2320))
console.error: (new TypeError("container.node.targetFront is null", "resource://devtools/client/inspector/markup/markup.js", 2320))
console.error: (new Error("Protocol error (TypeError): node is null from: server0.conn0.windowGlobal4294967299/pagestyle24 (resource://devtools/server/actors/page-style.js:570:5)", "resource://devtools/shared/protocol/Front.js", 365))
console.error: "Error while calling actor 'pagestyle's method 'getLayout'" "node is null"
console.error: (new TypeError("node is null", "resource://devtools/server/actors/page-style.js", 1001))
console.error: (new TypeError("parent is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 67))
TypeError: parent is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:67:24
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:312:10

console.error: (new TypeError("container.node.targetFront is null", "resource://devtools/client/inspector/markup/markup.js", 2320))
console.error: (new Error("Protocol error (TypeError): node is null from: server0.conn0.windowGlobal4294967299/pagestyle24 (resource://devtools/server/actors/page-style.js:1001:5)", "resource://devtools/shared/protocol/Front.js", 365))
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, 1650800142236	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "61273" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileEPvPEv"
1650800142853	Marionette	INFO	Marionette enabled
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileEPvPEv\\search.json.mozlz4", (void 0)))
DevTools listening on ws://localhost:61273/devtools/browser/4728f71b-3a45-470c-8cfb-912643a573fa
1650800145508	Marionette	INFO	Listening on port 61279
1650800145977	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
console.warn: LoginRecipes: "getRecipes: falling back to a synchronous message for:" "https://gen-bizbd.com"
JavaScript error: resource://gre/modules/LoginManagerParent.jsm, line 136: TypeError: gRecipeManager is null
JavaScript warning: https://gen-bizbd.com/web/content/53594-92c9dad/web.assets_backend.js, line 5051: unreachable code after return statement
1650800244180	Marionette	INFO	Stopped listening on port 61279

###!!! [Parent][PContentParent] Error: Send(msgname=PContent::Msg_DestroyBrowsingContextGroup) Closed channel: cannot send/recv


###!!! [Parent][PContentParent] Error: Send(msgname=PContent::Reply_DiscardBrowsingContext) Closed channel: cannot send/recv

1670849657934	geckodriver	INFO	Listening on 127.0.0.1:53613
1670849660991	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "53614" "--remote-allow-hosts" "localhost" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileI26a0T"
1670849662013	Marionette	INFO	Marionette enabled
1670849662024	Marionette	INFO	Listening on port 53627
Read port: 53627
WebDriver BiDi listening on ws://127.0.0.1:53614
1670849662545	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
1670849676709	geckodriver	INFO	Listening on 127.0.0.1:53638
1670849679851	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "53639" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileuIXhhS"
1670849680423	Marionette	INFO	Marionette enabled
1670849680432	Marionette	INFO	Listening on port 53644
WebDriver BiDi listening on ws://127.0.0.1:53639
1670849680976	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileuIXhhS\\search.json.mozlz4", (void 0)))
DevTools listening on ws://127.0.0.1:53639/devtools/browser/cc2b3e61-ab9f-4050-9655-e7f0d87387e6
1670849894998	Marionette	INFO	Stopped listening on port 53644
console.warn: TopSitesFeed: Failed to fetch data from Contile server: NetworkError when attempting to fetch resource.
1670850014074	geckodriver	INFO	Listening on 127.0.0.1:53746
1670850017161	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "53747" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofilef6RFru"
1670850017800	Marionette	INFO	Marionette enabled
1670850017815	Marionette	INFO	Listening on port 53753
WebDriver BiDi listening on ws://127.0.0.1:53747
1670850018422	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofilef6RFru\\search.json.mozlz4", (void 0)))
DevTools listening on ws://127.0.0.1:53747/devtools/browser/ba4517ef-3584-4140-bc6c-e8d0b2d9303c
JavaScript error: , line 0: NS_ERROR_NOT_AVAILABLE
1670852811043	Marionette	INFO	Stopped listening on port 53753
console.warn: TopSitesFeed: Failed to fetch data from Contile server: NetworkError when attempting to fetch resource.
1670995642633	geckodriver	INFO	Listening on 127.0.0.1:50246
1670995645734	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "50247" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileBLyTXn"
1670995647278	Marionette	INFO	Marionette enabled
1670995647293	Marionette	INFO	Listening on port 50252
WebDriver BiDi listening on ws://127.0.0.1:50247
1670995647970	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileBLyTXn\\search.json.mozlz4", (void 0)))
DevTools listening on ws://127.0.0.1:50247/devtools/browser/4ef07b66-559c-4994-9ae1-37bf49caa793
1670995825455	Marionette	INFO	Stopped listening on port 50252
console.warn: TopSitesFeed: Failed to fetch data from Contile server: NetworkError when attempting to fetch resource.
1670995827594	geckodriver	INFO	Listening on 127.0.0.1:50327
1670995830663	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "50328" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofiledWf8YE"
1670995831406	Marionette	INFO	Marionette enabled
1670995831416	Marionette	INFO	Listening on port 50333
WebDriver BiDi listening on ws://127.0.0.1:50328
1670995831994	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofiledWf8YE\\search.json.mozlz4", (void 0)))
DevTools listening on ws://127.0.0.1:50328/devtools/browser/c90352b5-f9fa-46ca-bc29-586b9d2e064d
console.warn: LoginRecipes: "Falling back to a synchronous message for: https://gen-bizbd.com."
console.warn: LoginRecipes: "Falling back to a synchronous message for: https://gen-bizbd.com."
JavaScript warning: https://gen-bizbd.com/web/content/60727-e1edaad/web.assets_backend.js, line 5057: unreachable code after return statement
JavaScript error: , line 0: NS_ERROR_NOT_AVAILABLE
1670996617786	Marionette	INFO	Stopped listening on port 50333
console.warn: TopSitesFeed: Failed to fetch data from Contile server: NetworkError when attempting to fetch resource.
1670996620417	geckodriver	INFO	Listening on 127.0.0.1:50629
1670996623476	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "50630" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileMtCXCW"
1670996624020	Marionette	INFO	Marionette enabled
1670996624032	Marionette	INFO	Listening on port 50635
WebDriver BiDi listening on ws://127.0.0.1:50630
1670996624574	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileMtCXCW\\search.json.mozlz4", (void 0)))
DevTools listening on ws://127.0.0.1:50630/devtools/browser/ad5a3381-45f1-44c0-9ee0-e5922c0a8c5d
console.warn: LoginRecipes: "Falling back to a synchronous message for: https://gen-bizbd.com."
console.warn: LoginRecipes: "Falling back to a synchronous message for: https://gen-bizbd.com."
JavaScript warning: https://gen-bizbd.com/web/content/60727-e1edaad/web.assets_backend.js, line 5057: unreachable code after return statement
1670996780263	Marionette	INFO	Stopped listening on port 50635
console.warn: TopSitesFeed: Failed to fetch data from Contile server: NetworkError when attempting to fetch resource.
e" "--remote-debugging-port" "50698" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileq4r1Te"
1670996780654	Marionette	INFO	Marionette enabled
1670996780667	Marionette	INFO	Listening on port 50704
WebDriver BiDi listening on ws://127.0.0.1:50698
1670996781015	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileq4r1Te\\search.json.mozlz4", (void 0)))
DevTools listening on ws://127.0.0.1:50698/devtools/browser/ef7e1bde-837b-4873-886a-862c3c4e87ea
console.warn: LoginRecipes: "Falling back to a synchronous message for: https://gen-bizbd.com."
console.warn: LoginRecipes: "Falling back to a synchronous message for: https://gen-bizbd.com."
JavaScript warning: https://gen-bizbd.com/web/content/60727-e1edaad/web.assets_backend.js, line 5057: unreachable code after return statement
1670996907002	Marionette	INFO	Stopped listening on port 50704
console.warn: TopSitesFeed: Failed to fetch data from Contile server: NetworkError when attempting to fetch resource.
e" "--remote-debugging-port" "50770" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofilevYRtCG"
1670996903306	Marionette	INFO	Marionette enabled
1670996903322	Marionette	INFO	Listening on port 50775
WebDriver BiDi listening on ws://127.0.0.1:50770
1670996903770	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofilevYRtCG\\search.json.mozlz4", (void 0)))
DevTools listening on ws://127.0.0.1:50770/devtools/browser/68c80770-fc87-4040-9dce-24c27ed8d343
console.warn: LoginRecipes: "Falling back to a synchronous message for: https://gen-bizbd.com."
console.warn: LoginRecipes: "Falling back to a synchronous message for: https://gen-bizbd.com."
JavaScript warning: https://gen-bizbd.com/web/content/60727-e1edaad/web.assets_backend.js, line 5057: unreachable code after return statement
SourceActor threw an exception: [Exception... "Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]"  nsresult: "0x80470002 (NS_BASE_STREAM_CLOSED)"  location: "JS frame :: resource://devtools/shared/DevToolsUtils.js :: onResponse :: line 568"  data: no]
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:568:34
onStopRequest@resource://gre/modules/NetUtil.jsm:126:18
Line: 568, column: 0
console.error: ({})
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 568: NS_BASE_STREAM_CLOSED: Component returned failure code: 0x80470002 (NS_BASE_STREAM_CLOSED) [nsIInputStream.available]
SourceActor threw an exception: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
Stack: onResponse@resource://devtools/shared/DevToolsUtils.js:557:16
onStopRequest@resource://gre/modules/NetUtil.jsm:126:18
Line: 557, column: 16
console.error: (new Error("Failed to fetch https://gen-bizbd.com/web. Code 2152924148.", "resource://devtools/shared/DevToolsUtils.js", 557))
JavaScript error: resource://devtools/shared/DevToolsUtils.js, line 557: Error: Failed to fetch https://gen-bizbd.com/web. Code 2152924148.
console.error: (new TypeError("currentNode is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 66))
TypeError: currentNode is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:66:20
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:313:10

console.error: "Unable to find target with innerWindowId:4294967299"
console.error: "Unable to find target with innerWindowId:4294967299"
console.error: "Unable to find target with innerWindowId:4294967299"
console.error: "Unable to find target with innerWindowId:4294967299"
console.error: "Unable to find target with innerWindowId:4294967299"
JavaScript error: , line 0: NS_ERROR_NOT_AVAILABLE
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 560: NotFoundError: No such JSWindowActor 'DevToolsFrame'
1670998478261	Marionette	INFO	Stopped listening on port 50775
!!! error running onStopped callback: TypeError: callback is not a function
997098939	Marionette	INFO	Marionette enabled
1670997098952	Marionette	INFO	Listening on port 50865
WebDriver BiDi listening on ws://127.0.0.1:50860
1670997099543	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileREINWw\\search.json.mozlz4", (void 0)))
DevTools listening on ws://127.0.0.1:50860/devtools/browser/2fdc7945-ac1d-4665-89bd-2dca099b454f
console.warn: LoginRecipes: "Falling back to a synchronous message for: https://gen-bizbd.com."
console.warn: LoginRecipes: "Falling back to a synchronous message for: https://gen-bizbd.com."
JavaScript warning: https://gen-bizbd.com/web/content/60727-e1edaad/web.assets_backend.js, line 5057: unreachable code after return statement
JavaScript error: , line 0: NS_ERROR_NOT_AVAILABLE
1670998475833	Marionette	INFO	Stopped listening on port 50865
console.warn: TopSitesFeed: Failed to fetch data from Contile server: NetworkError when attempting to fetch resource.
e" "--remote-debugging-port" "51420" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofiley4DI2v"
1670998365543	Marionette	INFO	Marionette enabled
1670998365554	Marionette	INFO	Listening on port 51425
WebDriver BiDi listening on ws://127.0.0.1:51420
1670998365820	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofiley4DI2v\\search.json.mozlz4", (void 0)))
DevTools listening on ws://127.0.0.1:51420/devtools/browser/7532f7a7-ee84-4981-8e2b-ca1ecb1367c6
1670998471238	Marionette	INFO	Stopped listening on port 51425
console.warn: TopSitesFeed: Failed to fetch data from Contile server: NetworkError when attempting to fetch resource.
1670998482051	geckodriver	INFO	Listening on 127.0.0.1:51501
1670998485101	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "51502" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileFkbFrX"
1670998485654	Marionette	INFO	Marionette enabled
1670998485663	Marionette	INFO	Listening on port 51508
WebDriver BiDi listening on ws://127.0.0.1:51502
1670998486206	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileFkbFrX\\search.json.mozlz4", (void 0)))
DevTools listening on ws://127.0.0.1:51502/devtools/browser/5b129d32-d3b2-45e4-9745-1462bf595afa
console.warn: LoginRecipes: "Falling back to a synchronous message for: https://gen-bizbd.com."
console.warn: LoginRecipes: "Falling back to a synchronous message for: https://gen-bizbd.com."
JavaScript warning: https://gen-bizbd.com/web/content/60727-e1edaad/web.assets_backend.js, line 5057: unreachable code after return statement
1670998523727	Marionette	INFO	Stopped listening on port 51508
console.warn: TopSitesFeed: Failed to fetch data from Contile server: NetworkError when attempting to fetch resource.
WARNING: A blocker encountered an error while we were waiting.
          Blocker:  Waiting for ping task
          Phase: TelemetryController: Waiting for pending ping activity
          State: (none)
WARNING: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
WARNING: addBlocker@resource://gre/modules/AsyncShutdown.jsm:703:15
addBlocker@resource://gre/modules/AsyncShutdown.jsm:511:26
addBlocker@resource://gre/modules/AsyncShutdown.jsm:450:15
setupShutdown@resource://gre/modules/osfile/osfile_async_front.jsm:1563:28
@resource://gre/modules/osfile/osfile_async_front.jsm:1583:16
@resource://gre/modules/osfile.jsm:12:30
@resource://gre/modules/TelemetryStorage.jsm:19:28
promiseArchivePing@resource://gre/modules/TelemetryArchive.jsm:103:5
promiseArchivePing@resource://gre/modules/TelemetryArchive.jsm:63:33
_submitPingLogic@resource://gre/modules/TelemetryControllerParent.jsm:540:48
send@resource://gre/modules/TelemetryControllerParent.jsm:628:24
submitExternalPing@resource://gre/modules/TelemetryControllerParent.jsm:182:17
sendPing@resource://gre/modules/EventPing.jsm:51:30
_submitPing@resource://gre/modules/EventPing.jsm:229:12
shutdown@resource://gre/modules/EventPing.jsm:112:10
_cleanupOnShutdown@resource://gre/modules/TelemetryControllerParent.jsm:940:31
shutdown/<@resource://gre/modules/TelemetryControllerParent.jsm:1010:24
observe@resource://gre/modules/AsyncShutdown.jsm:560:16

WARNING: A blocker encountered an error while we were waiting.
          Blocker:  Waiting for ping task
          Phase: TelemetryController: Waiting for pending ping activity
          State: (none)
WARNING: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
WARNING: addBlocker@resource://gre/modules/AsyncShutdown.jsm:703:15
addBlocker@resource://gre/modules/AsyncShutdown.jsm:511:26
addBlocker@resource://gre/modules/AsyncShutdown.jsm:450:15
setupShutdown@resource://gre/modules/osfile/osfile_async_front.jsm:1563:28
@resource://gre/modules/osfile/osfile_async_front.jsm:1583:16
@resource://gre/modules/osfile.jsm:12:30
@resource://gre/modules/TelemetryStorage.jsm:19:28
promiseArchivePing@resource://gre/modules/TelemetryArchive.jsm:103:5
promiseArchivePing@resource://gre/modules/TelemetryArchive.jsm:63:33
_submitPingLogic@resource://gre/modules/TelemetryControllerParent.jsm:540:48
send@resource://gre/modules/TelemetryControllerParent.jsm:628:24
submitExternalPing@resource://gre/modules/TelemetryControllerParent.jsm:182:17
saveShutdownPings@resource://gre/modules/TelemetrySession.jsm:982:34
shutdownChromeProcess/cleanup/<@resource://gre/modules/TelemetrySession.jsm:1232:20
cleanup@resource://gre/modules/TelemetrySession.jsm:1239:9
shutdownChromeProcess@resource://gre/modules/TelemetrySession.jsm:1256:14
shutdown@resource://gre/modules/TelemetrySession.jsm:247:17
_cleanupOnShutdown@resource://gre/modules/TelemetryControllerParent.jsm:959:35
observe@resource://gre/modules/AsyncShutdown.jsm:560:16

WARNING: A blocker encountered an error while we were waiting.
          Blocker:  Waiting for ping task
          Phase: TelemetryController: Waiting for pending ping activity
          State: (none)
WARNING: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
WARNING: addBlocker@resource://gre/modules/AsyncShutdown.jsm:703:15
addBlocker@resource://gre/modules/AsyncShutdown.jsm:511:26
addBlocker@resource://gre/modules/AsyncShutdown.jsm:450:15
setupShutdown@resource://gre/modules/osfile/osfile_async_front.jsm:1563:28
@resource://gre/modules/osfile/osfile_async_front.jsm:1583:16
@resource://gre/modules/osfile.jsm:12:30
@resource://gre/modules/TelemetryStorage.jsm:19:28
promiseArchivePing@resource://gre/modules/TelemetryArchive.jsm:103:5
promiseArchivePing@resource://gre/modules/TelemetryArchive.jsm:63:33
_submitPingLogic@resource://gre/modules/TelemetryControllerParent.jsm:540:48
send@resource://gre/modules/TelemetryControllerParent.jsm:628:24
submitExternalPing@resource://gre/modules/TelemetryControllerParent.jsm:182:17
saveShutdownPings@resource://gre/modules/TelemetrySession.jsm:1014:36
shutdownChromeProcess/cleanup/<@resource://gre/modules/TelemetrySession.jsm:1232:20
cleanup@resource://gre/modules/TelemetrySession.jsm:1239:9
shutdownChromeProcess@resource://gre/modules/TelemetrySession.jsm:1256:14
shutdown@resource://gre/modules/TelemetrySession.jsm:247:17
_cleanupOnShutdown@resource://gre/modules/TelemetryControllerParent.jsm:959:35
observe@resource://gre/modules/AsyncShutdown.jsm:560:16

WARNING: A blocker encountered an error while we were waiting.
          Blocker:  TelemetryController: shutting down
          Phase: profile-before-change-telemetry
          State: Error getting state: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange" at addBlocker@resource://gre/modules/AsyncShutdown.jsm:703:15
addBlocker@resource://gre/modules/AsyncShutdown.jsm:511:26
addBlocker@resource://gre/modules/AsyncShutdown.jsm:450:15
setupShutdown@resource://gre/modules/osfile/osfile_async_front.jsm:1563:28
@resource://gre/modules/osfile/osfile_async_front.jsm:1583:16
@resource://gre/modules/osfile.jsm:12:30
@resource://gre/modules/TelemetryStorage.jsm:19:28
getShutdownState@resource://gre/modules/TelemetrySend.jsm:1687:7
getShutdownState@resource://gre/modules/TelemetrySend.jsm:369:30
_getState@resource://gre/modules/TelemetryControllerParent.jsm:1058:38
setupTelemetry/<@resource://gre/modules/TelemetryControllerParent.jsm:917:18
safeGetState@resource://gre/modules/AsyncShutdown.jsm:242:17
Barrier/addBlocker/promise<@resource://gre/modules/AsyncShutdown.jsm:751:20
observe@resource://gre/modules/AsyncShutdown.jsm:560:16

WARNING: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
WARNING: addBlocker@resource://gre/modules/AsyncShutdown.jsm:703:15
addBlocker@resource://gre/modules/AsyncShutdown.jsm:511:26
addBlocker@resource://gre/modules/AsyncShutdown.jsm:450:15
setupShutdown@resource://gre/modules/osfile/osfile_async_front.jsm:1563:28
@resource://gre/modules/osfile/osfile_async_front.jsm:1583:16
@resource://gre/modules/osfile.jsm:12:30
@resource://gre/modules/TelemetryStorage.jsm:19:28
removeAbortedSessionPing@resource://gre/modules/TelemetryControllerParent.jsm:721:5
removeAbortedSessionPing@resource://gre/modules/TelemetryControllerParent.jsm:249:17
shutdownChromeProcess/cleanup/<@resource://gre/modules/TelemetrySession.jsm:1235:42
observe@resource://gre/modules/AsyncShutdown.jsm:560:16

JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 703: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 703: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 703: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 703: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 703: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 703: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
1670998815436	geckodriver	INFO	Listening on 127.0.0.1:51843
1670998818724	mozrunner::runner	INFO	Running command: "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "51844" "-no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofilesYpH4p"
1670998819381	Marionette	INFO	Marionette enabled
Dynamically enable window occlusion 0
1670998819393	Marionette	INFO	Listening on port 51849
WebDriver BiDi listening on ws://127.0.0.1:51844
1670998820099	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofilesYpH4p\\search.json.mozlz4", (void 0)))
DevTools listening on ws://127.0.0.1:51844/devtools/browser/3ac3c74c-a342-43ac-afe0-607a7ba9c687
1670999345425	Marionette	INFO	Stopped listening on port 51849
Dynamically enable window occlusion 1
console.warn: TopSitesFeed: Failed to fetch data from Contile server: NetworkError when attempting to fetch resource.
no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofilex1mdBs"
1670999227586	Marionette	INFO	Marionette enabled
Dynamically enable window occlusion 0
1670999227598	Marionette	INFO	Listening on port 52416
WebDriver BiDi listening on ws://127.0.0.1:52411
1670999228349	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofilex1mdBs\\search.json.mozlz4", (void 0)))
DevTools listening on ws://127.0.0.1:52411/devtools/browser/e32aa904-f645-4015-8ad8-5dc45d156040
1670999343225	Marionette	INFO	Stopped listening on port 52416
Dynamically enable window occlusion 1
console.warn: TopSitesFeed: Failed to fetch data from Contile server: NetworkError when attempting to fetch resource.
no-remote" "-profile" "C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileYjJCIG"
1670999322774	Marionette	INFO	Marionette enabled
Dynamically enable window occlusion 0
1670999322784	Marionette	INFO	Listening on port 52741
WebDriver BiDi listening on ws://127.0.0.1:52733
1670999323109	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofileYjJCIG\\search.json.mozlz4", (void 0)))
DevTools listening on ws://127.0.0.1:52733/devtools/browser/846d40a6-c8c1-4ee2-bb9d-e766002fb62f
console.warn: LoginRecipes: "Falling back to a synchronous message for: https://gen-bizbd.com."
console.warn: LoginRecipes: "Falling back to a synchronous message for: https://gen-bizbd.com."
1670999397547	Marionette	INFO	Stopped listening on port 52741
Dynamically enable window occlusion 1
console.warn: TopSitesFeed: Failed to fetch data from Contile server: NetworkError when attempting to fetch resource.
!!! error running onStopped callback: TypeError: callback is not a function
rofile8319BZ"
1670999393453	Marionette	INFO	Marionette enabled
Dynamically enable window occlusion 0
1670999393464	Marionette	INFO	Listening on port 52817
WebDriver BiDi listening on ws://127.0.0.1:52811
1670999394153	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\ALAM~1.RAS\\AppData\\Local\\Temp\\rust_mozprofile8319BZ\\search.json.mozlz4", (void 0)))
DevTools listening on ws://127.0.0.1:52811/devtools/browser/20e9d371-5af1-4e3e-8d23-4383d318d001
console.warn: LoginRecipes: "Falling back to a synchronous message for: https://gen-bizbd.com."
console.warn: LoginRecipes: "Falling back to a synchronous message for: https://gen-bizbd.com."
JavaScript warning: https://gen-bizbd.com/web/content/60727-e1edaad/web.assets_backend.js, line 5057: unreachable code after return statement
1670999515695	Marionette	INFO	Stopped listening on port 52817
Dynamically enable window occlusion 1
console.warn: TopSitesFeed: Failed to fetch data from Contile server: NetworkError when attempting to fetch resource.
